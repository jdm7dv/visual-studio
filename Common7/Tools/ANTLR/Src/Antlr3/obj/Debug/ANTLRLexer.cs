//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\ANTLR.g3 2013-06-14 09:39:33

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using ErrorManager = Antlr3.Tool.ErrorManager;
using Grammar = Antlr3.Tool.Grammar;
using StringBuffer = System.Text.StringBuilder;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.Grammars
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ANTLRLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ACTION_CHAR_LITERAL=5;
	public const int ACTION_ESC=6;
	public const int ACTION_STRING_LITERAL=7;
	public const int ALT=8;
	public const int AMPERSAND=9;
	public const int ARG=10;
	public const int ARGLIST=11;
	public const int ARG_ACTION=12;
	public const int ASSIGN=13;
	public const int BACKTRACK_SEMPRED=14;
	public const int BANG=15;
	public const int BLOCK=16;
	public const int CATCH=17;
	public const int CHAR_LITERAL=18;
	public const int CHAR_RANGE=19;
	public const int CLOSE_ELEMENT_OPTION=20;
	public const int CLOSURE=21;
	public const int COLON=22;
	public const int COMBINED_GRAMMAR=23;
	public const int COMMA=24;
	public const int COMMENT=25;
	public const int DIGIT=26;
	public const int DOC_COMMENT=27;
	public const int DOLLAR=28;
	public const int DOT=29;
	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
	public const int EOA=32;
	public const int EOB=33;
	public const int EOR=34;
	public const int EPSILON=35;
	public const int ESC=36;
	public const int ETC=37;
	public const int FINALLY=38;
	public const int FORCED_ACTION=39;
	public const int FRAGMENT=40;
	public const int GATED_SEMPRED=41;
	public const int GRAMMAR=42;
	public const int ID=43;
	public const int IMPLIES=44;
	public const int IMPORT=45;
	public const int INITACTION=46;
	public const int INT=47;
	public const int LABEL=48;
	public const int LEXER=49;
	public const int LEXER_GRAMMAR=50;
	public const int LPAREN=51;
	public const int ML_COMMENT=52;
	public const int NESTED_ACTION=53;
	public const int NESTED_ARG_ACTION=54;
	public const int NOT=55;
	public const int OPEN_ELEMENT_OPTION=56;
	public const int OPTIONAL=57;
	public const int OPTIONS=58;
	public const int OR=59;
	public const int PARSER=60;
	public const int PARSER_GRAMMAR=61;
	public const int PLUS=62;
	public const int PLUS_ASSIGN=63;
	public const int POSITIVE_CLOSURE=64;
	public const int PREC_RULE=65;
	public const int PRIVATE=66;
	public const int PROTECTED=67;
	public const int PUBLIC=68;
	public const int QUESTION=69;
	public const int RANGE=70;
	public const int RCURLY=71;
	public const int RECURSIVE_RULE_REF=72;
	public const int RET=73;
	public const int RETURNS=74;
	public const int REWRITE=75;
	public const int REWRITES=76;
	public const int ROOT=77;
	public const int RPAREN=78;
	public const int RULE=79;
	public const int RULE_REF=80;
	public const int SCOPE=81;
	public const int SEMI=82;
	public const int SEMPRED=83;
	public const int SL_COMMENT=84;
	public const int SRC=85;
	public const int STAR=86;
	public const int STRAY_BRACKET=87;
	public const int STRING_LITERAL=88;
	public const int SYNPRED=89;
	public const int SYN_SEMPRED=90;
	public const int TEMPLATE=91;
	public const int THROWS=92;
	public const int TOKENS=93;
	public const int TOKEN_REF=94;
	public const int TREE=95;
	public const int TREE_BEGIN=96;
	public const int TREE_GRAMMAR=97;
	public const int WILDCARD=98;
	public const int WS=99;
	public const int WS_LOOP=100;
	public const int WS_OPT=101;
	public const int XDIGIT=102;

	// delegates
	// delegators

	public ANTLRLexer()
	{
		OnCreated();
	}

	public ANTLRLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public ANTLRLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Grammars\\ANTLR.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_CATCH();
	partial void LeaveRule_CATCH();

	// $ANTLR start "CATCH"
	[GrammarRule("CATCH")]
	private void mCATCH()
	{
		EnterRule_CATCH();
		EnterRule("CATCH", 1);
		TraceIn("CATCH", 1);
		try
		{
			int _type = CATCH;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:14:7: ( 'catch' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:14:9: 'catch'
			{
			DebugLocation(14, 9);
			Match("catch"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CATCH", 1);
			LeaveRule("CATCH", 1);
			LeaveRule_CATCH();
		}
	}
	// $ANTLR end "CATCH"

	partial void EnterRule_FINALLY();
	partial void LeaveRule_FINALLY();

	// $ANTLR start "FINALLY"
	[GrammarRule("FINALLY")]
	private void mFINALLY()
	{
		EnterRule_FINALLY();
		EnterRule("FINALLY", 2);
		TraceIn("FINALLY", 2);
		try
		{
			int _type = FINALLY;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:15:9: ( 'finally' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:15:11: 'finally'
			{
			DebugLocation(15, 11);
			Match("finally"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FINALLY", 2);
			LeaveRule("FINALLY", 2);
			LeaveRule_FINALLY();
		}
	}
	// $ANTLR end "FINALLY"

	partial void EnterRule_FRAGMENT();
	partial void LeaveRule_FRAGMENT();

	// $ANTLR start "FRAGMENT"
	[GrammarRule("FRAGMENT")]
	private void mFRAGMENT()
	{
		EnterRule_FRAGMENT();
		EnterRule("FRAGMENT", 3);
		TraceIn("FRAGMENT", 3);
		try
		{
			int _type = FRAGMENT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:16:10: ( 'fragment' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:16:12: 'fragment'
			{
			DebugLocation(16, 12);
			Match("fragment"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FRAGMENT", 3);
			LeaveRule("FRAGMENT", 3);
			LeaveRule_FRAGMENT();
		}
	}
	// $ANTLR end "FRAGMENT"

	partial void EnterRule_GRAMMAR();
	partial void LeaveRule_GRAMMAR();

	// $ANTLR start "GRAMMAR"
	[GrammarRule("GRAMMAR")]
	private void mGRAMMAR()
	{
		EnterRule_GRAMMAR();
		EnterRule("GRAMMAR", 4);
		TraceIn("GRAMMAR", 4);
		try
		{
			int _type = GRAMMAR;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:17:9: ( 'grammar' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:17:11: 'grammar'
			{
			DebugLocation(17, 11);
			Match("grammar"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GRAMMAR", 4);
			LeaveRule("GRAMMAR", 4);
			LeaveRule_GRAMMAR();
		}
	}
	// $ANTLR end "GRAMMAR"

	partial void EnterRule_IMPORT();
	partial void LeaveRule_IMPORT();

	// $ANTLR start "IMPORT"
	[GrammarRule("IMPORT")]
	private void mIMPORT()
	{
		EnterRule_IMPORT();
		EnterRule("IMPORT", 5);
		TraceIn("IMPORT", 5);
		try
		{
			int _type = IMPORT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:18:8: ( 'import' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:18:10: 'import'
			{
			DebugLocation(18, 10);
			Match("import"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IMPORT", 5);
			LeaveRule("IMPORT", 5);
			LeaveRule_IMPORT();
		}
	}
	// $ANTLR end "IMPORT"

	partial void EnterRule_LEXER();
	partial void LeaveRule_LEXER();

	// $ANTLR start "LEXER"
	[GrammarRule("LEXER")]
	private void mLEXER()
	{
		EnterRule_LEXER();
		EnterRule("LEXER", 6);
		TraceIn("LEXER", 6);
		try
		{
			int _type = LEXER;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:19:7: ( 'lexer' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:19:9: 'lexer'
			{
			DebugLocation(19, 9);
			Match("lexer"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LEXER", 6);
			LeaveRule("LEXER", 6);
			LeaveRule_LEXER();
		}
	}
	// $ANTLR end "LEXER"

	partial void EnterRule_PARSER();
	partial void LeaveRule_PARSER();

	// $ANTLR start "PARSER"
	[GrammarRule("PARSER")]
	private void mPARSER()
	{
		EnterRule_PARSER();
		EnterRule("PARSER", 7);
		TraceIn("PARSER", 7);
		try
		{
			int _type = PARSER;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:20:8: ( 'parser' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:20:10: 'parser'
			{
			DebugLocation(20, 10);
			Match("parser"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PARSER", 7);
			LeaveRule("PARSER", 7);
			LeaveRule_PARSER();
		}
	}
	// $ANTLR end "PARSER"

	partial void EnterRule_PRIVATE();
	partial void LeaveRule_PRIVATE();

	// $ANTLR start "PRIVATE"
	[GrammarRule("PRIVATE")]
	private void mPRIVATE()
	{
		EnterRule_PRIVATE();
		EnterRule("PRIVATE", 8);
		TraceIn("PRIVATE", 8);
		try
		{
			int _type = PRIVATE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:21:9: ( 'private' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:21:11: 'private'
			{
			DebugLocation(21, 11);
			Match("private"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PRIVATE", 8);
			LeaveRule("PRIVATE", 8);
			LeaveRule_PRIVATE();
		}
	}
	// $ANTLR end "PRIVATE"

	partial void EnterRule_PROTECTED();
	partial void LeaveRule_PROTECTED();

	// $ANTLR start "PROTECTED"
	[GrammarRule("PROTECTED")]
	private void mPROTECTED()
	{
		EnterRule_PROTECTED();
		EnterRule("PROTECTED", 9);
		TraceIn("PROTECTED", 9);
		try
		{
			int _type = PROTECTED;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:22:11: ( 'protected' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:22:13: 'protected'
			{
			DebugLocation(22, 13);
			Match("protected"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROTECTED", 9);
			LeaveRule("PROTECTED", 9);
			LeaveRule_PROTECTED();
		}
	}
	// $ANTLR end "PROTECTED"

	partial void EnterRule_PUBLIC();
	partial void LeaveRule_PUBLIC();

	// $ANTLR start "PUBLIC"
	[GrammarRule("PUBLIC")]
	private void mPUBLIC()
	{
		EnterRule_PUBLIC();
		EnterRule("PUBLIC", 10);
		TraceIn("PUBLIC", 10);
		try
		{
			int _type = PUBLIC;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:23:8: ( 'public' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:23:10: 'public'
			{
			DebugLocation(23, 10);
			Match("public"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PUBLIC", 10);
			LeaveRule("PUBLIC", 10);
			LeaveRule_PUBLIC();
		}
	}
	// $ANTLR end "PUBLIC"

	partial void EnterRule_RETURNS();
	partial void LeaveRule_RETURNS();

	// $ANTLR start "RETURNS"
	[GrammarRule("RETURNS")]
	private void mRETURNS()
	{
		EnterRule_RETURNS();
		EnterRule("RETURNS", 11);
		TraceIn("RETURNS", 11);
		try
		{
			int _type = RETURNS;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:24:9: ( 'returns' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:24:11: 'returns'
			{
			DebugLocation(24, 11);
			Match("returns"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURNS", 11);
			LeaveRule("RETURNS", 11);
			LeaveRule_RETURNS();
		}
	}
	// $ANTLR end "RETURNS"

	partial void EnterRule_SCOPE();
	partial void LeaveRule_SCOPE();

	// $ANTLR start "SCOPE"
	[GrammarRule("SCOPE")]
	private void mSCOPE()
	{
		EnterRule_SCOPE();
		EnterRule("SCOPE", 12);
		TraceIn("SCOPE", 12);
		try
		{
			int _type = SCOPE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:25:7: ( 'scope' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:25:9: 'scope'
			{
			DebugLocation(25, 9);
			Match("scope"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SCOPE", 12);
			LeaveRule("SCOPE", 12);
			LeaveRule_SCOPE();
		}
	}
	// $ANTLR end "SCOPE"

	partial void EnterRule_THROWS();
	partial void LeaveRule_THROWS();

	// $ANTLR start "THROWS"
	[GrammarRule("THROWS")]
	private void mTHROWS()
	{
		EnterRule_THROWS();
		EnterRule("THROWS", 13);
		TraceIn("THROWS", 13);
		try
		{
			int _type = THROWS;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:26:8: ( 'throws' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:26:10: 'throws'
			{
			DebugLocation(26, 10);
			Match("throws"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("THROWS", 13);
			LeaveRule("THROWS", 13);
			LeaveRule_THROWS();
		}
	}
	// $ANTLR end "THROWS"

	partial void EnterRule_TREE();
	partial void LeaveRule_TREE();

	// $ANTLR start "TREE"
	[GrammarRule("TREE")]
	private void mTREE()
	{
		EnterRule_TREE();
		EnterRule("TREE", 14);
		TraceIn("TREE", 14);
		try
		{
			int _type = TREE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:27:6: ( 'tree' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:27:8: 'tree'
			{
			DebugLocation(27, 8);
			Match("tree"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TREE", 14);
			LeaveRule("TREE", 14);
			LeaveRule_TREE();
		}
	}
	// $ANTLR end "TREE"

	partial void EnterRule_STRING_LITERAL();
	partial void LeaveRule_STRING_LITERAL();

	// $ANTLR start "STRING_LITERAL"
	[GrammarRule("STRING_LITERAL")]
	private void mSTRING_LITERAL()
	{
		EnterRule_STRING_LITERAL();
		EnterRule("STRING_LITERAL", 15);
		TraceIn("STRING_LITERAL", 15);
		try
		{
			// Grammars\\ANTLR.g3:735:25: ()
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:735:27: 
			{
			}

		}
		finally
		{
			TraceOut("STRING_LITERAL", 15);
			LeaveRule("STRING_LITERAL", 15);
			LeaveRule_STRING_LITERAL();
		}
	}
	// $ANTLR end "STRING_LITERAL"

	partial void EnterRule_FORCED_ACTION();
	partial void LeaveRule_FORCED_ACTION();

	// $ANTLR start "FORCED_ACTION"
	[GrammarRule("FORCED_ACTION")]
	private void mFORCED_ACTION()
	{
		EnterRule_FORCED_ACTION();
		EnterRule("FORCED_ACTION", 16);
		TraceIn("FORCED_ACTION", 16);
		try
		{
			// Grammars\\ANTLR.g3:736:24: ()
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:736:26: 
			{
			}

		}
		finally
		{
			TraceOut("FORCED_ACTION", 16);
			LeaveRule("FORCED_ACTION", 16);
			LeaveRule_FORCED_ACTION();
		}
	}
	// $ANTLR end "FORCED_ACTION"

	partial void EnterRule_DOC_COMMENT();
	partial void LeaveRule_DOC_COMMENT();

	// $ANTLR start "DOC_COMMENT"
	[GrammarRule("DOC_COMMENT")]
	private void mDOC_COMMENT()
	{
		EnterRule_DOC_COMMENT();
		EnterRule("DOC_COMMENT", 17);
		TraceIn("DOC_COMMENT", 17);
		try
		{
			// Grammars\\ANTLR.g3:737:22: ()
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:737:24: 
			{
			}

		}
		finally
		{
			TraceOut("DOC_COMMENT", 17);
			LeaveRule("DOC_COMMENT", 17);
			LeaveRule_DOC_COMMENT();
		}
	}
	// $ANTLR end "DOC_COMMENT"

	partial void EnterRule_SEMPRED();
	partial void LeaveRule_SEMPRED();

	// $ANTLR start "SEMPRED"
	[GrammarRule("SEMPRED")]
	private void mSEMPRED()
	{
		EnterRule_SEMPRED();
		EnterRule("SEMPRED", 18);
		TraceIn("SEMPRED", 18);
		try
		{
			// Grammars\\ANTLR.g3:738:18: ()
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:738:20: 
			{
			}

		}
		finally
		{
			TraceOut("SEMPRED", 18);
			LeaveRule("SEMPRED", 18);
			LeaveRule_SEMPRED();
		}
	}
	// $ANTLR end "SEMPRED"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 19);
		TraceIn("WS", 19);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:741:2: ( ( ' ' | '\\t' | ( '\\r' )? '\\n' ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:741:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
			{
			DebugLocation(741, 4);
			// Grammars\\ANTLR.g3:741:4: ( ' ' | '\\t' | ( '\\r' )? '\\n' )
			int alt2=3;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case ' ':
				{
				alt2 = 1;
				}
				break;
			case '\t':
				{
				alt2 = 2;
				}
				break;
			case '\n':
			case '\r':
				{
				alt2 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:741:6: ' '
				{
				DebugLocation(741, 6);
				Match(' '); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:742:5: '\\t'
				{
				DebugLocation(742, 5);
				Match('\t'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:743:5: ( '\\r' )? '\\n'
				{
				DebugLocation(743, 5);
				// Grammars\\ANTLR.g3:743:5: ( '\\r' )?
				int alt1=2;
				try { DebugEnterSubRule(1);
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1=='\r'))
				{
					alt1 = 1;
				}
				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:743:6: '\\r'
					{
					DebugLocation(743, 6);
					Match('\r'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(1); }

				DebugLocation(743, 13);
				Match('\n'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(745, 3);
			if (state.backtracking == 0)
			{
				 _channel = Hidden; 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 19);
			LeaveRule("WS", 19);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 20);
		TraceIn("COMMENT", 20);
		try
		{
			int _type = COMMENT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:749:2: ( ( SL_COMMENT | ML_COMMENT[ref $type] ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:749:4: ( SL_COMMENT | ML_COMMENT[ref $type] )
			{
			DebugLocation(749, 4);
			// Grammars\\ANTLR.g3:749:4: ( SL_COMMENT | ML_COMMENT[ref $type] )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1=='/'))
			{
				int LA3_2 = input.LA(2);

				if ((LA3_2=='/'))
				{
					alt3 = 1;
				}
				else if ((LA3_2=='*'))
				{
					alt3 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:749:6: SL_COMMENT
				{
				DebugLocation(749, 6);
				mSL_COMMENT(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:749:19: ML_COMMENT[ref $type]
				{
				DebugLocation(749, 19);
				mML_COMMENT(ref _type); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(750, 3);
			if (state.backtracking == 0)
			{

							if ( _type != DOC_COMMENT )
								_channel = Hidden;
						
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMENT", 20);
			LeaveRule("COMMENT", 20);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_SL_COMMENT();
	partial void LeaveRule_SL_COMMENT();

	// $ANTLR start "SL_COMMENT"
	[GrammarRule("SL_COMMENT")]
	private void mSL_COMMENT()
	{
		EnterRule_SL_COMMENT();
		EnterRule("SL_COMMENT", 21);
		TraceIn("SL_COMMENT", 21);
		try
		{
			// Grammars\\ANTLR.g3:759:2: ( '//' ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:759:4: '//' ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
			{
			DebugLocation(759, 4);
			Match("//"); if (state.failed) return;

			DebugLocation(760, 3);
			// Grammars\\ANTLR.g3:760:3: ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			try
			{
				alt9 = dfa9.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:760:5: ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )?
				{
				DebugLocation(760, 20);
				Match(" $ANTLR "); if (state.failed) return;

				DebugLocation(760, 31);
				mSRC(); if (state.failed) return;
				DebugLocation(760, 35);
				// Grammars\\ANTLR.g3:760:35: ( ( '\\r' )? '\\n' )?
				int alt5=2;
				try { DebugEnterSubRule(5);
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1=='\n'||LA5_1=='\r'))
				{
					alt5 = 1;
				}
				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:760:36: ( '\\r' )? '\\n'
					{
					DebugLocation(760, 36);
					// Grammars\\ANTLR.g3:760:36: ( '\\r' )?
					int alt4=2;
					try { DebugEnterSubRule(4);
					try { DebugEnterDecision(4, false);
					int LA4_1 = input.LA(1);

					if ((LA4_1=='\r'))
					{
						alt4 = 1;
					}
					} finally { DebugExitDecision(4); }
					switch (alt4)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:760:37: '\\r'
						{
						DebugLocation(760, 37);
						Match('\r'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(4); }

					DebugLocation(760, 44);
					Match('\n'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(5); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:761:5: (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )?
				{
				DebugLocation(761, 5);
				// Grammars\\ANTLR.g3:761:5: (~ ( '\\r' | '\\n' ) )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if (((LA6_1>='\u0000' && LA6_1<='\t')||(LA6_1>='\u000B' && LA6_1<='\f')||(LA6_1>='\u000E' && LA6_1<='\uFFFF')))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:
						{
						DebugLocation(761, 5);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }

				DebugLocation(761, 19);
				// Grammars\\ANTLR.g3:761:19: ( ( '\\r' )? '\\n' )?
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1=='\n'||LA8_1=='\r'))
				{
					alt8 = 1;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:761:20: ( '\\r' )? '\\n'
					{
					DebugLocation(761, 20);
					// Grammars\\ANTLR.g3:761:20: ( '\\r' )?
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_1 = input.LA(1);

					if ((LA7_1=='\r'))
					{
						alt7 = 1;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:761:21: '\\r'
						{
						DebugLocation(761, 21);
						Match('\r'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(761, 28);
					Match('\n'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

		}
		finally
		{
			TraceOut("SL_COMMENT", 21);
			LeaveRule("SL_COMMENT", 21);
			LeaveRule_SL_COMMENT();
		}
	}
	// $ANTLR end "SL_COMMENT"

	partial void EnterRule_ML_COMMENT();
	partial void LeaveRule_ML_COMMENT();

	// $ANTLR start "ML_COMMENT"
	[GrammarRule("ML_COMMENT")]
	private void mML_COMMENT(ref int type)
	{
		EnterRule_ML_COMMENT();
		EnterRule("ML_COMMENT", 22);
		TraceIn("ML_COMMENT", 22);
		try
		{
			// Grammars\\ANTLR.g3:767:2: ( '/*' ( . )* '*/' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:767:4: '/*' ( . )* '*/'
			{
			DebugLocation(767, 4);
			Match("/*"); if (state.failed) return;

			DebugLocation(768, 3);
			if (state.backtracking == 0)
			{
				type = (input.LA(1) == '*' && input.LA(2) != '/') ? DOC_COMMENT : ML_COMMENT;
			}
			DebugLocation(769, 3);
			// Grammars\\ANTLR.g3:769:3: ( . )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1=='*'))
				{
					int LA10_2 = input.LA(2);

					if ((LA10_2=='/'))
					{
						alt10 = 2;
					}
					else if (((LA10_2>='\u0000' && LA10_2<='.')||(LA10_2>='0' && LA10_2<='\uFFFF')))
					{
						alt10 = 1;
					}


				}
				else if (((LA10_1>='\u0000' && LA10_1<=')')||(LA10_1>='+' && LA10_1<='\uFFFF')))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:769:3: .
					{
					DebugLocation(769, 3);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(770, 3);
			Match("*/"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("ML_COMMENT", 22);
			LeaveRule("ML_COMMENT", 22);
			LeaveRule_ML_COMMENT();
		}
	}
	// $ANTLR end "ML_COMMENT"

	partial void EnterRule_OPEN_ELEMENT_OPTION();
	partial void LeaveRule_OPEN_ELEMENT_OPTION();

	// $ANTLR start "OPEN_ELEMENT_OPTION"
	[GrammarRule("OPEN_ELEMENT_OPTION")]
	private void mOPEN_ELEMENT_OPTION()
	{
		EnterRule_OPEN_ELEMENT_OPTION();
		EnterRule("OPEN_ELEMENT_OPTION", 23);
		TraceIn("OPEN_ELEMENT_OPTION", 23);
		try
		{
			int _type = OPEN_ELEMENT_OPTION;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:773:2: ( '<' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:773:4: '<'
			{
			DebugLocation(773, 4);
			Match('<'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OPEN_ELEMENT_OPTION", 23);
			LeaveRule("OPEN_ELEMENT_OPTION", 23);
			LeaveRule_OPEN_ELEMENT_OPTION();
		}
	}
	// $ANTLR end "OPEN_ELEMENT_OPTION"

	partial void EnterRule_CLOSE_ELEMENT_OPTION();
	partial void LeaveRule_CLOSE_ELEMENT_OPTION();

	// $ANTLR start "CLOSE_ELEMENT_OPTION"
	[GrammarRule("CLOSE_ELEMENT_OPTION")]
	private void mCLOSE_ELEMENT_OPTION()
	{
		EnterRule_CLOSE_ELEMENT_OPTION();
		EnterRule("CLOSE_ELEMENT_OPTION", 24);
		TraceIn("CLOSE_ELEMENT_OPTION", 24);
		try
		{
			int _type = CLOSE_ELEMENT_OPTION;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:777:2: ( '>' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:777:4: '>'
			{
			DebugLocation(777, 4);
			Match('>'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CLOSE_ELEMENT_OPTION", 24);
			LeaveRule("CLOSE_ELEMENT_OPTION", 24);
			LeaveRule_CLOSE_ELEMENT_OPTION();
		}
	}
	// $ANTLR end "CLOSE_ELEMENT_OPTION"

	partial void EnterRule_AMPERSAND();
	partial void LeaveRule_AMPERSAND();

	// $ANTLR start "AMPERSAND"
	[GrammarRule("AMPERSAND")]
	private void mAMPERSAND()
	{
		EnterRule_AMPERSAND();
		EnterRule("AMPERSAND", 25);
		TraceIn("AMPERSAND", 25);
		try
		{
			int _type = AMPERSAND;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:780:11: ( '@' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:780:13: '@'
			{
			DebugLocation(780, 13);
			Match('@'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AMPERSAND", 25);
			LeaveRule("AMPERSAND", 25);
			LeaveRule_AMPERSAND();
		}
	}
	// $ANTLR end "AMPERSAND"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 26);
		TraceIn("COMMA", 26);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:782:7: ( ',' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:782:9: ','
			{
			DebugLocation(782, 9);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 26);
			LeaveRule("COMMA", 26);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_QUESTION();
	partial void LeaveRule_QUESTION();

	// $ANTLR start "QUESTION"
	[GrammarRule("QUESTION")]
	private void mQUESTION()
	{
		EnterRule_QUESTION();
		EnterRule("QUESTION", 27);
		TraceIn("QUESTION", 27);
		try
		{
			int _type = QUESTION;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:784:10: ( '?' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:784:12: '?'
			{
			DebugLocation(784, 12);
			Match('?'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("QUESTION", 27);
			LeaveRule("QUESTION", 27);
			LeaveRule_QUESTION();
		}
	}
	// $ANTLR end "QUESTION"

	partial void EnterRule_TREE_BEGIN();
	partial void LeaveRule_TREE_BEGIN();

	// $ANTLR start "TREE_BEGIN"
	[GrammarRule("TREE_BEGIN")]
	private void mTREE_BEGIN()
	{
		EnterRule_TREE_BEGIN();
		EnterRule("TREE_BEGIN", 28);
		TraceIn("TREE_BEGIN", 28);
		try
		{
			int _type = TREE_BEGIN;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:786:12: ( '^(' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:786:14: '^('
			{
			DebugLocation(786, 14);
			Match("^("); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TREE_BEGIN", 28);
			LeaveRule("TREE_BEGIN", 28);
			LeaveRule_TREE_BEGIN();
		}
	}
	// $ANTLR end "TREE_BEGIN"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 29);
		TraceIn("LPAREN", 29);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:788:7: ( '(' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:788:9: '('
			{
			DebugLocation(788, 9);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 29);
			LeaveRule("LPAREN", 29);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 30);
		TraceIn("RPAREN", 30);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:790:7: ( ')' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:790:9: ')'
			{
			DebugLocation(790, 9);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 30);
			LeaveRule("RPAREN", 30);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 31);
		TraceIn("COLON", 31);
		try
		{
			int _type = COLON;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:792:7: ( ':' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:792:9: ':'
			{
			DebugLocation(792, 9);
			Match(':'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLON", 31);
			LeaveRule("COLON", 31);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_STAR();
	partial void LeaveRule_STAR();

	// $ANTLR start "STAR"
	[GrammarRule("STAR")]
	private void mSTAR()
	{
		EnterRule_STAR();
		EnterRule("STAR", 32);
		TraceIn("STAR", 32);
		try
		{
			int _type = STAR;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:794:5: ( '*' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:794:7: '*'
			{
			DebugLocation(794, 7);
			Match('*'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STAR", 32);
			LeaveRule("STAR", 32);
			LeaveRule_STAR();
		}
	}
	// $ANTLR end "STAR"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 33);
		TraceIn("PLUS", 33);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:796:5: ( '+' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:796:7: '+'
			{
			DebugLocation(796, 7);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 33);
			LeaveRule("PLUS", 33);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 34);
		TraceIn("ASSIGN", 34);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:798:8: ( '=' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:798:10: '='
			{
			DebugLocation(798, 10);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 34);
			LeaveRule("ASSIGN", 34);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_PLUS_ASSIGN();
	partial void LeaveRule_PLUS_ASSIGN();

	// $ANTLR start "PLUS_ASSIGN"
	[GrammarRule("PLUS_ASSIGN")]
	private void mPLUS_ASSIGN()
	{
		EnterRule_PLUS_ASSIGN();
		EnterRule("PLUS_ASSIGN", 35);
		TraceIn("PLUS_ASSIGN", 35);
		try
		{
			int _type = PLUS_ASSIGN;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:800:13: ( '+=' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:800:15: '+='
			{
			DebugLocation(800, 15);
			Match("+="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS_ASSIGN", 35);
			LeaveRule("PLUS_ASSIGN", 35);
			LeaveRule_PLUS_ASSIGN();
		}
	}
	// $ANTLR end "PLUS_ASSIGN"

	partial void EnterRule_IMPLIES();
	partial void LeaveRule_IMPLIES();

	// $ANTLR start "IMPLIES"
	[GrammarRule("IMPLIES")]
	private void mIMPLIES()
	{
		EnterRule_IMPLIES();
		EnterRule("IMPLIES", 36);
		TraceIn("IMPLIES", 36);
		try
		{
			int _type = IMPLIES;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:802:9: ( '=>' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:802:11: '=>'
			{
			DebugLocation(802, 11);
			Match("=>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IMPLIES", 36);
			LeaveRule("IMPLIES", 36);
			LeaveRule_IMPLIES();
		}
	}
	// $ANTLR end "IMPLIES"

	partial void EnterRule_REWRITE();
	partial void LeaveRule_REWRITE();

	// $ANTLR start "REWRITE"
	[GrammarRule("REWRITE")]
	private void mREWRITE()
	{
		EnterRule_REWRITE();
		EnterRule("REWRITE", 37);
		TraceIn("REWRITE", 37);
		try
		{
			int _type = REWRITE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:804:9: ( '->' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:804:11: '->'
			{
			DebugLocation(804, 11);
			Match("->"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REWRITE", 37);
			LeaveRule("REWRITE", 37);
			LeaveRule_REWRITE();
		}
	}
	// $ANTLR end "REWRITE"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 38);
		TraceIn("SEMI", 38);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:806:5: ( ';' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:806:7: ';'
			{
			DebugLocation(806, 7);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 38);
			LeaveRule("SEMI", 38);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_ROOT();
	partial void LeaveRule_ROOT();

	// $ANTLR start "ROOT"
	[GrammarRule("ROOT")]
	private void mROOT()
	{
		EnterRule_ROOT();
		EnterRule("ROOT", 39);
		TraceIn("ROOT", 39);
		try
		{
			int _type = ROOT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:808:6: ( '^' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:808:8: '^'
			{
			DebugLocation(808, 8);
			Match('^'); if (state.failed) return;
			DebugLocation(808, 12);
			if (state.backtracking == 0)
			{
				hasASTOperator=true;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ROOT", 39);
			LeaveRule("ROOT", 39);
			LeaveRule_ROOT();
		}
	}
	// $ANTLR end "ROOT"

	partial void EnterRule_BANG();
	partial void LeaveRule_BANG();

	// $ANTLR start "BANG"
	[GrammarRule("BANG")]
	private void mBANG()
	{
		EnterRule_BANG();
		EnterRule("BANG", 40);
		TraceIn("BANG", 40);
		try
		{
			int _type = BANG;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:810:6: ( '!' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:810:8: '!'
			{
			DebugLocation(810, 8);
			Match('!'); if (state.failed) return;
			DebugLocation(810, 12);
			if (state.backtracking == 0)
			{
				hasASTOperator=true;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BANG", 40);
			LeaveRule("BANG", 40);
			LeaveRule_BANG();
		}
	}
	// $ANTLR end "BANG"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 41);
		TraceIn("OR", 41);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:812:4: ( '|' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:812:6: '|'
			{
			DebugLocation(812, 6);
			Match('|'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 41);
			LeaveRule("OR", 41);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_WILDCARD();
	partial void LeaveRule_WILDCARD();

	// $ANTLR start "WILDCARD"
	[GrammarRule("WILDCARD")]
	private void mWILDCARD()
	{
		EnterRule_WILDCARD();
		EnterRule("WILDCARD", 42);
		TraceIn("WILDCARD", 42);
		try
		{
			int _type = WILDCARD;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:814:10: ( '.' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:814:12: '.'
			{
			DebugLocation(814, 12);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WILDCARD", 42);
			LeaveRule("WILDCARD", 42);
			LeaveRule_WILDCARD();
		}
	}
	// $ANTLR end "WILDCARD"

	partial void EnterRule_ETC();
	partial void LeaveRule_ETC();

	// $ANTLR start "ETC"
	[GrammarRule("ETC")]
	private void mETC()
	{
		EnterRule_ETC();
		EnterRule("ETC", 43);
		TraceIn("ETC", 43);
		try
		{
			int _type = ETC;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:816:5: ( '...' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:816:7: '...'
			{
			DebugLocation(816, 7);
			Match("..."); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ETC", 43);
			LeaveRule("ETC", 43);
			LeaveRule_ETC();
		}
	}
	// $ANTLR end "ETC"

	partial void EnterRule_RANGE();
	partial void LeaveRule_RANGE();

	// $ANTLR start "RANGE"
	[GrammarRule("RANGE")]
	private void mRANGE()
	{
		EnterRule_RANGE();
		EnterRule("RANGE", 44);
		TraceIn("RANGE", 44);
		try
		{
			int _type = RANGE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:818:7: ( '..' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:818:9: '..'
			{
			DebugLocation(818, 9);
			Match(".."); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RANGE", 44);
			LeaveRule("RANGE", 44);
			LeaveRule_RANGE();
		}
	}
	// $ANTLR end "RANGE"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 45);
		TraceIn("NOT", 45);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:820:5: ( '~' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:820:7: '~'
			{
			DebugLocation(820, 7);
			Match('~'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 45);
			LeaveRule("NOT", 45);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_RCURLY();
	partial void LeaveRule_RCURLY();

	// $ANTLR start "RCURLY"
	[GrammarRule("RCURLY")]
	private void mRCURLY()
	{
		EnterRule_RCURLY();
		EnterRule("RCURLY", 46);
		TraceIn("RCURLY", 46);
		try
		{
			int _type = RCURLY;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:822:7: ( '}' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:822:9: '}'
			{
			DebugLocation(822, 9);
			Match('}'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RCURLY", 46);
			LeaveRule("RCURLY", 46);
			LeaveRule_RCURLY();
		}
	}
	// $ANTLR end "RCURLY"

	partial void EnterRule_DOLLAR();
	partial void LeaveRule_DOLLAR();

	// $ANTLR start "DOLLAR"
	[GrammarRule("DOLLAR")]
	private void mDOLLAR()
	{
		EnterRule_DOLLAR();
		EnterRule("DOLLAR", 47);
		TraceIn("DOLLAR", 47);
		try
		{
			int _type = DOLLAR;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:824:8: ( '$' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:824:10: '$'
			{
			DebugLocation(824, 10);
			Match('$'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOLLAR", 47);
			LeaveRule("DOLLAR", 47);
			LeaveRule_DOLLAR();
		}
	}
	// $ANTLR end "DOLLAR"

	partial void EnterRule_STRAY_BRACKET();
	partial void LeaveRule_STRAY_BRACKET();

	// $ANTLR start "STRAY_BRACKET"
	[GrammarRule("STRAY_BRACKET")]
	private void mSTRAY_BRACKET()
	{
		EnterRule_STRAY_BRACKET();
		EnterRule("STRAY_BRACKET", 48);
		TraceIn("STRAY_BRACKET", 48);
		try
		{
			int _type = STRAY_BRACKET;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:827:2: ( ']' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:827:4: ']'
			{
			DebugLocation(827, 4);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRAY_BRACKET", 48);
			LeaveRule("STRAY_BRACKET", 48);
			LeaveRule_STRAY_BRACKET();
		}
	}
	// $ANTLR end "STRAY_BRACKET"

	partial void EnterRule_CHAR_LITERAL();
	partial void LeaveRule_CHAR_LITERAL();

	// $ANTLR start "CHAR_LITERAL"
	[GrammarRule("CHAR_LITERAL")]
	private void mCHAR_LITERAL()
	{
		EnterRule_CHAR_LITERAL();
		EnterRule("CHAR_LITERAL", 49);
		TraceIn("CHAR_LITERAL", 49);
		try
		{
			int _type = CHAR_LITERAL;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:831:2: ( '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:831:4: '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\''
			{
			DebugLocation(831, 4);
			Match('\''); if (state.failed) return;
			DebugLocation(832, 3);
			// Grammars\\ANTLR.g3:832:3: ( ESC |~ ( '\\\\' | '\\'' ) )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=3;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1=='\\'))
				{
					alt11 = 1;
				}
				else if (((LA11_1>='\u0000' && LA11_1<='&')||(LA11_1>='(' && LA11_1<='[')||(LA11_1>=']' && LA11_1<='\uFFFF')))
				{
					alt11 = 2;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:832:5: ESC
					{
					DebugLocation(832, 5);
					mESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:833:5: ~ ( '\\\\' | '\\'' )
					{
					DebugLocation(833, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(835, 3);
			Match('\''); if (state.failed) return;
			DebugLocation(836, 3);
			if (state.backtracking == 0)
			{

							StringBuffer s = Grammar.GetUnescapedStringFromGrammarStringLiteral(Text);
							if ( s.Length > 1 )
							{
								_type = STRING_LITERAL;
							}
						
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CHAR_LITERAL", 49);
			LeaveRule("CHAR_LITERAL", 49);
			LeaveRule_CHAR_LITERAL();
		}
	}
	// $ANTLR end "CHAR_LITERAL"

	partial void EnterRule_DOUBLE_QUOTE_STRING_LITERAL();
	partial void LeaveRule_DOUBLE_QUOTE_STRING_LITERAL();

	// $ANTLR start "DOUBLE_QUOTE_STRING_LITERAL"
	[GrammarRule("DOUBLE_QUOTE_STRING_LITERAL")]
	private void mDOUBLE_QUOTE_STRING_LITERAL()
	{
		EnterRule_DOUBLE_QUOTE_STRING_LITERAL();
		EnterRule("DOUBLE_QUOTE_STRING_LITERAL", 50);
		TraceIn("DOUBLE_QUOTE_STRING_LITERAL", 50);
		try
		{
			int _type = DOUBLE_QUOTE_STRING_LITERAL;
			int _channel = DefaultTokenChannel;
			int c = 0;


				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Grammars\\ANTLR.g3:850:2: ( '\"' ( ( '\\\\\\\"' )=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:850:4: '\"' ( ( '\\\\\\\"' )=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"'
			{
			DebugLocation(850, 4);
			Match('\"'); if (state.failed) return;
			DebugLocation(850, 14);
			if (state.backtracking == 0)
			{
				builder.Append('"');
			}
			DebugLocation(851, 3);
			// Grammars\\ANTLR.g3:851:3: ( ( '\\\\\\\"' )=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=4;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1=='\\'))
				{
					int LA12_2 = input.LA(2);

					if ((LA12_2=='\"') && (EvaluatePredicate(synpred2_ANTLR_fragment)))
					{
						alt12 = 1;
					}
					else if (((LA12_2>='\u0000' && LA12_2<='!')||(LA12_2>='#' && LA12_2<='\uFFFF')))
					{
						alt12 = 2;
					}


				}
				else if (((LA12_1>='\u0000' && LA12_1<='!')||(LA12_1>='#' && LA12_1<='[')||(LA12_1>=']' && LA12_1<='\uFFFF')))
				{
					alt12 = 3;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:851:5: ( '\\\\\\\"' )=> '\\\\' '\"'
					{
					DebugLocation(851, 17);
					Match('\\'); if (state.failed) return;
					DebugLocation(851, 22);
					Match('\"'); if (state.failed) return;
					DebugLocation(851, 26);
					if (state.backtracking == 0)
					{
						builder.Append('"');
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:852:5: '\\\\' c=~ '\"'
					{
					DebugLocation(852, 5);
					Match('\\'); if (state.failed) return;
					DebugLocation(852, 11);
					c= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(852, 20);
					if (state.backtracking == 0)
					{
						builder.Append("\\" + (char)c);
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\ANTLR.g3:853:5: c=~ ( '\\\\' | '\"' )
					{
					DebugLocation(853, 6);
					c= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(853, 21);
					if (state.backtracking == 0)
					{
						builder.Append((char)c);
					}

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(855, 3);
			Match('\"'); if (state.failed) return;
			DebugLocation(855, 13);
			if (state.backtracking == 0)
			{
				builder.Append('"');
			}
			DebugLocation(856, 3);
			if (state.backtracking == 0)
			{

							Text = builder.ToString();
						
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOUBLE_QUOTE_STRING_LITERAL", 50);
			LeaveRule("DOUBLE_QUOTE_STRING_LITERAL", 50);
			LeaveRule_DOUBLE_QUOTE_STRING_LITERAL();
		}
	}
	// $ANTLR end "DOUBLE_QUOTE_STRING_LITERAL"

	partial void EnterRule_DOUBLE_ANGLE_STRING_LITERAL();
	partial void LeaveRule_DOUBLE_ANGLE_STRING_LITERAL();

	// $ANTLR start "DOUBLE_ANGLE_STRING_LITERAL"
	[GrammarRule("DOUBLE_ANGLE_STRING_LITERAL")]
	private void mDOUBLE_ANGLE_STRING_LITERAL()
	{
		EnterRule_DOUBLE_ANGLE_STRING_LITERAL();
		EnterRule("DOUBLE_ANGLE_STRING_LITERAL", 51);
		TraceIn("DOUBLE_ANGLE_STRING_LITERAL", 51);
		try
		{
			int _type = DOUBLE_ANGLE_STRING_LITERAL;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:862:2: ( '<<' ( . )* '>>' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:862:4: '<<' ( . )* '>>'
			{
			DebugLocation(862, 4);
			Match("<<"); if (state.failed) return;

			DebugLocation(862, 9);
			// Grammars\\ANTLR.g3:862:9: ( . )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1=='>'))
				{
					int LA13_2 = input.LA(2);

					if ((LA13_2=='>'))
					{
						alt13 = 2;
					}
					else if (((LA13_2>='\u0000' && LA13_2<='=')||(LA13_2>='?' && LA13_2<='\uFFFF')))
					{
						alt13 = 1;
					}


				}
				else if (((LA13_1>='\u0000' && LA13_1<='=')||(LA13_1>='?' && LA13_1<='\uFFFF')))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:862:9: .
					{
					DebugLocation(862, 9);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(862, 12);
			Match(">>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOUBLE_ANGLE_STRING_LITERAL", 51);
			LeaveRule("DOUBLE_ANGLE_STRING_LITERAL", 51);
			LeaveRule_DOUBLE_ANGLE_STRING_LITERAL();
		}
	}
	// $ANTLR end "DOUBLE_ANGLE_STRING_LITERAL"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	private void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 52);
		TraceIn("ESC", 52);
		try
		{
			// Grammars\\ANTLR.g3:868:2: ( '\\\\' ( . ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:868:4: '\\\\' ( . )
			{
			DebugLocation(868, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(869, 3);
			// Grammars\\ANTLR.g3:869:3: ( . )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:880:7: .
			{
			DebugLocation(880, 7);
			MatchAny(); if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("ESC", 52);
			LeaveRule("ESC", 52);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 53);
		TraceIn("DIGIT", 53);
		try
		{
			// Grammars\\ANTLR.g3:886:2: ( '0' .. '9' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:
			{
			DebugLocation(886, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 53);
			LeaveRule("DIGIT", 53);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_XDIGIT();
	partial void LeaveRule_XDIGIT();

	// $ANTLR start "XDIGIT"
	[GrammarRule("XDIGIT")]
	private void mXDIGIT()
	{
		EnterRule_XDIGIT();
		EnterRule("XDIGIT", 54);
		TraceIn("XDIGIT", 54);
		try
		{
			// Grammars\\ANTLR.g3:891:2: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:
			{
			DebugLocation(891, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("XDIGIT", 54);
			LeaveRule("XDIGIT", 54);
			LeaveRule_XDIGIT();
		}
	}
	// $ANTLR end "XDIGIT"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 55);
		TraceIn("INT", 55);
		try
		{
			int _type = INT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:896:2: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:896:4: ( '0' .. '9' )+
			{
			DebugLocation(896, 4);
			// Grammars\\ANTLR.g3:896:4: ( '0' .. '9' )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if (((LA14_1>='0' && LA14_1<='9')))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:
					{
					DebugLocation(896, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INT", 55);
			LeaveRule("INT", 55);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_ARG_ACTION();
	partial void LeaveRule_ARG_ACTION();

	// $ANTLR start "ARG_ACTION"
	[GrammarRule("ARG_ACTION")]
	private void mARG_ACTION()
	{
		EnterRule_ARG_ACTION();
		EnterRule("ARG_ACTION", 56);
		TraceIn("ARG_ACTION", 56);
		try
		{
			int _type = ARG_ACTION;
			int _channel = DefaultTokenChannel;

				string text_ = string.Empty;

			// Grammars\\ANTLR.g3:904:2: ( '[' NESTED_ARG_ACTION[out text_] ']' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:904:4: '[' NESTED_ARG_ACTION[out text_] ']'
			{
			DebugLocation(904, 4);
			Match('['); if (state.failed) return;
			DebugLocation(905, 3);
			mNESTED_ARG_ACTION(out text_); if (state.failed) return;
			DebugLocation(906, 3);
			Match(']'); if (state.failed) return;
			DebugLocation(907, 3);
			if (state.backtracking == 0)
			{
				 Text = text_; 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ARG_ACTION", 56);
			LeaveRule("ARG_ACTION", 56);
			LeaveRule_ARG_ACTION();
		}
	}
	// $ANTLR end "ARG_ACTION"

	partial void EnterRule_NESTED_ARG_ACTION();
	partial void LeaveRule_NESTED_ARG_ACTION();

	// $ANTLR start "NESTED_ARG_ACTION"
	[GrammarRule("NESTED_ARG_ACTION")]
	private void mNESTED_ARG_ACTION(out string text_)
	{
		EnterRule_NESTED_ARG_ACTION();
		EnterRule("NESTED_ARG_ACTION", 57);
		TraceIn("NESTED_ARG_ACTION", 57);
		try
		{
			CommonToken ACTION_STRING_LITERAL1 = default(CommonToken);
			CommonToken ACTION_CHAR_LITERAL2 = default(CommonToken);
			int c = 0;


				text_ = string.Empty;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Grammars\\ANTLR.g3:918:2: ( ( ( '\\\\]' )=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:918:4: ( ( '\\\\]' )=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
			{
			DebugLocation(918, 4);
			// Grammars\\ANTLR.g3:918:4: ( ( '\\\\]' )=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=6;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1=='\\'))
				{
					int LA15_2 = input.LA(2);

					if ((LA15_2==']') && (EvaluatePredicate(synpred3_ANTLR_fragment)))
					{
						alt15 = 1;
					}
					else if (((LA15_2>='\u0000' && LA15_2<='\\')||(LA15_2>='^' && LA15_2<='\uFFFF')))
					{
						alt15 = 2;
					}


				}
				else if ((LA15_1=='\"'))
				{
					alt15 = 3;
				}
				else if ((LA15_1=='\''))
				{
					alt15 = 4;
				}
				else if (((LA15_1>='\u0000' && LA15_1<='!')||(LA15_1>='#' && LA15_1<='&')||(LA15_1>='(' && LA15_1<='[')||(LA15_1>='^' && LA15_1<='\uFFFF')))
				{
					alt15 = 5;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:918:6: ( '\\\\]' )=> '\\\\' ']'
					{
					DebugLocation(918, 17);
					Match('\\'); if (state.failed) return;
					DebugLocation(918, 22);
					Match(']'); if (state.failed) return;
					DebugLocation(918, 27);
					if (state.backtracking == 0)
					{
						builder.Append("]");
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:919:5: '\\\\' c=~ ( ']' )
					{
					DebugLocation(919, 5);
					Match('\\'); if (state.failed) return;
					DebugLocation(919, 11);
					c= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(919, 21);
					if (state.backtracking == 0)
					{
						builder.Append("\\" + (char)c);
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\ANTLR.g3:920:5: ACTION_STRING_LITERAL
					{
					DebugLocation(920, 5);
					int ACTION_STRING_LITERAL1Start853 = CharIndex;
					int ACTION_STRING_LITERAL1StartLine853 = Line;
					int ACTION_STRING_LITERAL1StartCharPos853 = CharPositionInLine;
					mACTION_STRING_LITERAL(); if (state.failed) return;
					ACTION_STRING_LITERAL1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ACTION_STRING_LITERAL1Start853, CharIndex-1);
					ACTION_STRING_LITERAL1.Line = ACTION_STRING_LITERAL1StartLine853;
					ACTION_STRING_LITERAL1.CharPositionInLine = ACTION_STRING_LITERAL1StartCharPos853;
					DebugLocation(920, 27);
					if (state.backtracking == 0)
					{
						builder.Append((ACTION_STRING_LITERAL1!=null?ACTION_STRING_LITERAL1.Text:default(string)));
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammars\\ANTLR.g3:921:5: ACTION_CHAR_LITERAL
					{
					DebugLocation(921, 5);
					int ACTION_CHAR_LITERAL2Start861 = CharIndex;
					int ACTION_CHAR_LITERAL2StartLine861 = Line;
					int ACTION_CHAR_LITERAL2StartCharPos861 = CharPositionInLine;
					mACTION_CHAR_LITERAL(); if (state.failed) return;
					ACTION_CHAR_LITERAL2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ACTION_CHAR_LITERAL2Start861, CharIndex-1);
					ACTION_CHAR_LITERAL2.Line = ACTION_CHAR_LITERAL2StartLine861;
					ACTION_CHAR_LITERAL2.CharPositionInLine = ACTION_CHAR_LITERAL2StartCharPos861;
					DebugLocation(921, 26);
					if (state.backtracking == 0)
					{
						builder.Append((ACTION_CHAR_LITERAL2!=null?ACTION_CHAR_LITERAL2.Text:default(string)));
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammars\\ANTLR.g3:922:5: c=~ ( '\\\\' | '\"' | '\\'' | ']' )
					{
					DebugLocation(922, 6);
					c= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(922, 28);
					if (state.backtracking == 0)
					{
						builder.Append((char)c);
					}

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(924, 3);
			if (state.backtracking == 0)
			{

							text_ = builder.ToString();
						
			}

			}

		}
		finally
		{
			TraceOut("NESTED_ARG_ACTION", 57);
			LeaveRule("NESTED_ARG_ACTION", 57);
			LeaveRule_NESTED_ARG_ACTION();
		}
	}
	// $ANTLR end "NESTED_ARG_ACTION"

	partial void EnterRule_ACTION();
	partial void LeaveRule_ACTION();

	// $ANTLR start "ACTION"
	[GrammarRule("ACTION")]
	private void mACTION()
	{
		EnterRule_ACTION();
		EnterRule("ACTION", 58);
		TraceIn("ACTION", 58);
		try
		{
			int _type = ACTION;
			int _channel = DefaultTokenChannel;

				int actionLine = Line;
				int actionColumn = CharPositionInLine;

			// Grammars\\ANTLR.g3:934:2: ( NESTED_ACTION ( '?' )? )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:934:4: NESTED_ACTION ( '?' )?
			{
			DebugLocation(934, 4);
			mNESTED_ACTION(); if (state.failed) return;
			DebugLocation(935, 3);
			// Grammars\\ANTLR.g3:935:3: ( '?' )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1=='?'))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:935:4: '?'
				{
				DebugLocation(935, 4);
				Match('?'); if (state.failed) return;
				DebugLocation(935, 8);
				if (state.backtracking == 0)
				{
					_type = SEMPRED;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(936, 3);
			if (state.backtracking == 0)
			{

							string action = Text;
							int n = 1; // num delimiter chars
							if ( action.StartsWith("{{") && action.EndsWith("}}") )
							{
								_type = FORCED_ACTION;
								n = 2;
							}
							action = action.Substring(n,action.Length-n - (_type==SEMPRED ? 1 : 0) - n);
							Text = action;
						
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ACTION", 58);
			LeaveRule("ACTION", 58);
			LeaveRule_ACTION();
		}
	}
	// $ANTLR end "ACTION"

	partial void EnterRule_NESTED_ACTION();
	partial void LeaveRule_NESTED_ACTION();

	// $ANTLR start "NESTED_ACTION"
	[GrammarRule("NESTED_ACTION")]
	private void mNESTED_ACTION()
	{
		EnterRule_NESTED_ACTION();
		EnterRule("NESTED_ACTION", 59);
		TraceIn("NESTED_ACTION", 59);
		try
		{
			// Grammars\\ANTLR.g3:952:2: ( '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL | ( '//' | '/*' )=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:952:4: '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL | ( '//' | '/*' )=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}'
			{
			DebugLocation(952, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(953, 3);
			// Grammars\\ANTLR.g3:953:3: ( NESTED_ACTION | ACTION_CHAR_LITERAL | ( '//' | '/*' )=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=7;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1=='{'))
				{
					alt17 = 1;
				}
				else if ((LA17_1=='\''))
				{
					alt17 = 2;
				}
				else if ((LA17_1=='/'))
				{
					int LA17_2 = input.LA(2);

					if ((EvaluatePredicate(synpred4_ANTLR_fragment)))
					{
						alt17 = 3;
					}
					else if ((true))
					{
						alt17 = 6;
					}


				}
				else if ((LA17_1=='\"'))
				{
					alt17 = 4;
				}
				else if ((LA17_1=='\\'))
				{
					alt17 = 5;
				}
				else if (((LA17_1>='\u0000' && LA17_1<='!')||(LA17_1>='#' && LA17_1<='&')||(LA17_1>='(' && LA17_1<='.')||(LA17_1>='0' && LA17_1<='[')||(LA17_1>=']' && LA17_1<='z')||LA17_1=='|'||(LA17_1>='~' && LA17_1<='\uFFFF')))
				{
					alt17 = 6;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:953:5: NESTED_ACTION
					{
					DebugLocation(953, 5);
					mNESTED_ACTION(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:954:5: ACTION_CHAR_LITERAL
					{
					DebugLocation(954, 5);
					mACTION_CHAR_LITERAL(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\ANTLR.g3:955:5: ( '//' | '/*' )=> COMMENT
					{
					DebugLocation(955, 22);
					mCOMMENT(); if (state.failed) return;

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Grammars\\ANTLR.g3:956:5: ACTION_STRING_LITERAL
					{
					DebugLocation(956, 5);
					mACTION_STRING_LITERAL(); if (state.failed) return;

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Grammars\\ANTLR.g3:957:5: ACTION_ESC
					{
					DebugLocation(957, 5);
					mACTION_ESC(); if (state.failed) return;

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Grammars\\ANTLR.g3:958:5: ~ ( '{' | '\\'' | '\"' | '\\\\' | '}' )
					{
					DebugLocation(958, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(960, 3);
			Match('}'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("NESTED_ACTION", 59);
			LeaveRule("NESTED_ACTION", 59);
			LeaveRule_NESTED_ACTION();
		}
	}
	// $ANTLR end "NESTED_ACTION"

	partial void EnterRule_ACTION_CHAR_LITERAL();
	partial void LeaveRule_ACTION_CHAR_LITERAL();

	// $ANTLR start "ACTION_CHAR_LITERAL"
	[GrammarRule("ACTION_CHAR_LITERAL")]
	private void mACTION_CHAR_LITERAL()
	{
		EnterRule_ACTION_CHAR_LITERAL();
		EnterRule("ACTION_CHAR_LITERAL", 60);
		TraceIn("ACTION_CHAR_LITERAL", 60);
		try
		{
			// Grammars\\ANTLR.g3:965:2: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:965:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\''
			{
			DebugLocation(965, 4);
			Match('\''); if (state.failed) return;
			DebugLocation(966, 3);
			// Grammars\\ANTLR.g3:966:3: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=3;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1=='\\'))
				{
					alt18 = 1;
				}
				else if (((LA18_1>='\u0000' && LA18_1<='&')||(LA18_1>='(' && LA18_1<='[')||(LA18_1>=']' && LA18_1<='\uFFFF')))
				{
					alt18 = 2;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:966:5: ACTION_ESC
					{
					DebugLocation(966, 5);
					mACTION_ESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:967:5: ~ ( '\\\\' | '\\'' )
					{
					DebugLocation(967, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(969, 3);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ACTION_CHAR_LITERAL", 60);
			LeaveRule("ACTION_CHAR_LITERAL", 60);
			LeaveRule_ACTION_CHAR_LITERAL();
		}
	}
	// $ANTLR end "ACTION_CHAR_LITERAL"

	partial void EnterRule_ACTION_STRING_LITERAL();
	partial void LeaveRule_ACTION_STRING_LITERAL();

	// $ANTLR start "ACTION_STRING_LITERAL"
	[GrammarRule("ACTION_STRING_LITERAL")]
	private void mACTION_STRING_LITERAL()
	{
		EnterRule_ACTION_STRING_LITERAL();
		EnterRule("ACTION_STRING_LITERAL", 61);
		TraceIn("ACTION_STRING_LITERAL", 61);
		try
		{
			// Grammars\\ANTLR.g3:974:2: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:974:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
			{
			DebugLocation(974, 4);
			Match('\"'); if (state.failed) return;
			DebugLocation(975, 3);
			// Grammars\\ANTLR.g3:975:3: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=3;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1=='\\'))
				{
					alt19 = 1;
				}
				else if (((LA19_1>='\u0000' && LA19_1<='!')||(LA19_1>='#' && LA19_1<='[')||(LA19_1>=']' && LA19_1<='\uFFFF')))
				{
					alt19 = 2;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:975:5: ACTION_ESC
					{
					DebugLocation(975, 5);
					mACTION_ESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:976:5: ~ ( '\\\\' | '\"' )
					{
					DebugLocation(976, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(978, 3);
			Match('\"'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ACTION_STRING_LITERAL", 61);
			LeaveRule("ACTION_STRING_LITERAL", 61);
			LeaveRule_ACTION_STRING_LITERAL();
		}
	}
	// $ANTLR end "ACTION_STRING_LITERAL"

	partial void EnterRule_ACTION_ESC();
	partial void LeaveRule_ACTION_ESC();

	// $ANTLR start "ACTION_ESC"
	[GrammarRule("ACTION_ESC")]
	private void mACTION_ESC()
	{
		EnterRule_ACTION_ESC();
		EnterRule("ACTION_ESC", 62);
		TraceIn("ACTION_ESC", 62);
		try
		{
			// Grammars\\ANTLR.g3:983:2: ( '\\\\\\'' | '\\\\\\\"' | '\\\\' ~ ( '\\'' | '\"' ) )
			int alt20=3;
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1=='\\'))
			{
				int LA20_2 = input.LA(2);

				if ((LA20_2=='\''))
				{
					alt20 = 1;
				}
				else if ((LA20_2=='\"'))
				{
					alt20 = 2;
				}
				else if (((LA20_2>='\u0000' && LA20_2<='!')||(LA20_2>='#' && LA20_2<='&')||(LA20_2>='(' && LA20_2<='\uFFFF')))
				{
					alt20 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 20, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:983:4: '\\\\\\''
				{
				DebugLocation(983, 4);
				Match("\\'"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:984:4: '\\\\\\\"'
				{
				DebugLocation(984, 4);
				Match("\\\""); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:985:4: '\\\\' ~ ( '\\'' | '\"' )
				{
				DebugLocation(985, 4);
				Match('\\'); if (state.failed) return;
				DebugLocation(985, 9);
				input.Consume();
				state.failed=false;

				}
				break;

			}
		}
		finally
		{
			TraceOut("ACTION_ESC", 62);
			LeaveRule("ACTION_ESC", 62);
			LeaveRule_ACTION_ESC();
		}
	}
	// $ANTLR end "ACTION_ESC"

	partial void EnterRule_TOKEN_REF();
	partial void LeaveRule_TOKEN_REF();

	// $ANTLR start "TOKEN_REF"
	[GrammarRule("TOKEN_REF")]
	private void mTOKEN_REF()
	{
		EnterRule_TOKEN_REF();
		EnterRule("TOKEN_REF", 63);
		TraceIn("TOKEN_REF", 63);
		try
		{
			int _type = TOKEN_REF;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:988:2: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:988:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			{
			DebugLocation(988, 7);
			MatchRange('A','Z'); if (state.failed) return;
			DebugLocation(989, 3);
			// Grammars\\ANTLR.g3:989:3: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if (((LA21_1>='0' && LA21_1<='9')||(LA21_1>='A' && LA21_1<='Z')||LA21_1=='_'||(LA21_1>='a' && LA21_1<='z')))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:
					{
					DebugLocation(989, 3);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TOKEN_REF", 63);
			LeaveRule("TOKEN_REF", 63);
			LeaveRule_TOKEN_REF();
		}
	}
	// $ANTLR end "TOKEN_REF"

	partial void EnterRule_TOKENS();
	partial void LeaveRule_TOKENS();

	// $ANTLR start "TOKENS"
	[GrammarRule("TOKENS")]
	private void mTOKENS()
	{
		EnterRule_TOKENS();
		EnterRule("TOKENS", 64);
		TraceIn("TOKENS", 64);
		try
		{
			int _type = TOKENS;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:994:2: ( 'tokens' WS_LOOP '{' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:994:4: 'tokens' WS_LOOP '{'
			{
			DebugLocation(994, 4);
			Match("tokens"); if (state.failed) return;

			DebugLocation(994, 13);
			mWS_LOOP(); if (state.failed) return;
			DebugLocation(994, 21);
			Match('{'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TOKENS", 64);
			LeaveRule("TOKENS", 64);
			LeaveRule_TOKENS();
		}
	}
	// $ANTLR end "TOKENS"

	partial void EnterRule_OPTIONS();
	partial void LeaveRule_OPTIONS();

	// $ANTLR start "OPTIONS"
	[GrammarRule("OPTIONS")]
	private void mOPTIONS()
	{
		EnterRule_OPTIONS();
		EnterRule("OPTIONS", 65);
		TraceIn("OPTIONS", 65);
		try
		{
			int _type = OPTIONS;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:998:2: ( 'options' WS_LOOP '{' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:998:4: 'options' WS_LOOP '{'
			{
			DebugLocation(998, 4);
			Match("options"); if (state.failed) return;

			DebugLocation(998, 14);
			mWS_LOOP(); if (state.failed) return;
			DebugLocation(998, 22);
			Match('{'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OPTIONS", 65);
			LeaveRule("OPTIONS", 65);
			LeaveRule_OPTIONS();
		}
	}
	// $ANTLR end "OPTIONS"

	partial void EnterRule_RULE_REF();
	partial void LeaveRule_RULE_REF();

	// $ANTLR start "RULE_REF"
	[GrammarRule("RULE_REF")]
	private void mRULE_REF()
	{
		EnterRule_RULE_REF();
		EnterRule("RULE_REF", 66);
		TraceIn("RULE_REF", 66);
		try
		{
			int _type = RULE_REF;
			int _channel = DefaultTokenChannel;
			// Grammars\\ANTLR.g3:1003:2: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:1003:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			{
			DebugLocation(1003, 7);
			MatchRange('a','z'); if (state.failed) return;
			DebugLocation(1003, 13);
			// Grammars\\ANTLR.g3:1003:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if (((LA22_1>='0' && LA22_1<='9')||(LA22_1>='A' && LA22_1<='Z')||LA22_1=='_'||(LA22_1>='a' && LA22_1<='z')))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:
					{
					DebugLocation(1003, 13);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RULE_REF", 66);
			LeaveRule("RULE_REF", 66);
			LeaveRule_RULE_REF();
		}
	}
	// $ANTLR end "RULE_REF"

	partial void EnterRule_WS_LOOP();
	partial void LeaveRule_WS_LOOP();

	// $ANTLR start "WS_LOOP"
	[GrammarRule("WS_LOOP")]
	private void mWS_LOOP()
	{
		EnterRule_WS_LOOP();
		EnterRule("WS_LOOP", 67);
		TraceIn("WS_LOOP", 67);
		try
		{
			// Grammars\\ANTLR.g3:1009:2: ( ( WS | COMMENT )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:1009:4: ( WS | COMMENT )*
			{
			DebugLocation(1009, 4);
			// Grammars\\ANTLR.g3:1009:4: ( WS | COMMENT )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=3;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if (((LA23_1>='\t' && LA23_1<='\n')||LA23_1=='\r'||LA23_1==' '))
				{
					alt23 = 1;
				}
				else if ((LA23_1=='/'))
				{
					alt23 = 2;
				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:1009:6: WS
					{
					DebugLocation(1009, 6);
					mWS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:1010:5: COMMENT
					{
					DebugLocation(1010, 5);
					mCOMMENT(); if (state.failed) return;

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}

		}
		finally
		{
			TraceOut("WS_LOOP", 67);
			LeaveRule("WS_LOOP", 67);
			LeaveRule_WS_LOOP();
		}
	}
	// $ANTLR end "WS_LOOP"

	partial void EnterRule_WS_OPT();
	partial void LeaveRule_WS_OPT();

	// $ANTLR start "WS_OPT"
	[GrammarRule("WS_OPT")]
	private void mWS_OPT()
	{
		EnterRule_WS_OPT();
		EnterRule("WS_OPT", 68);
		TraceIn("WS_OPT", 68);
		try
		{
			// Grammars\\ANTLR.g3:1016:2: ( ( WS )? )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:1016:4: ( WS )?
			{
			DebugLocation(1016, 4);
			// Grammars\\ANTLR.g3:1016:4: ( WS )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if (((LA24_1>='\t' && LA24_1<='\n')||LA24_1=='\r'||LA24_1==' '))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:1016:4: WS
				{
				DebugLocation(1016, 4);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(24); }


			}

		}
		finally
		{
			TraceOut("WS_OPT", 68);
			LeaveRule("WS_OPT", 68);
			LeaveRule_WS_OPT();
		}
	}
	// $ANTLR end "WS_OPT"

	partial void EnterRule_SRC();
	partial void LeaveRule_SRC();

	// $ANTLR start "SRC"
	[GrammarRule("SRC")]
	private void mSRC()
	{
		EnterRule_SRC();
		EnterRule("SRC", 69);
		TraceIn("SRC", 69);
		try
		{
			CommonToken file = default(CommonToken);
			CommonToken line = default(CommonToken);

			// Grammars\\ANTLR.g3:1029:2: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:1029:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
			{
			DebugLocation(1029, 4);
			Match("src"); if (state.failed) return;

			DebugLocation(1029, 10);
			Match(' '); if (state.failed) return;
			DebugLocation(1029, 18);
			int fileStart1259 = CharIndex;
			int fileStartLine1259 = Line;
			int fileStartCharPos1259 = CharPositionInLine;
			mACTION_STRING_LITERAL(); if (state.failed) return;
			file = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, fileStart1259, CharIndex-1);
			file.Line = fileStartLine1259;
			file.CharPositionInLine = fileStartCharPos1259;
			DebugLocation(1029, 41);
			Match(' '); if (state.failed) return;
			DebugLocation(1029, 49);
			int lineStart1265 = CharIndex;
			int lineStartLine1265 = Line;
			int lineStartCharPos1265 = CharPositionInLine;
			mINT(); if (state.failed) return;
			line = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, lineStart1265, CharIndex-1);
			line.Line = lineStartLine1265;
			line.CharPositionInLine = lineStartCharPos1265;
			DebugLocation(1030, 3);
			if (state.backtracking == 0)
			{

							Filename = (file!=null?file.Text:default(string)).Substring(1,(file!=null?file.Text:default(string)).Length-2);
							Line = int.Parse((line!=null?line.Text:default(string))) - 1;  // -1 because SL_COMMENT will increment the line no. KR
						
			}

			}

		}
		finally
		{
			TraceOut("SRC", 69);
			LeaveRule("SRC", 69);
			LeaveRule_SRC();
		}
	}
	// $ANTLR end "SRC"

	public override void mTokens()
	{
		// Grammars\\ANTLR.g3:1:8: ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF )
		int alt25=52;
		try { DebugEnterDecision(25, false);
		try
		{
			alt25 = dfa25.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(25); }
		switch (alt25)
		{
		case 1:
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:1:10: CATCH
			{
			DebugLocation(1, 10);
			mCATCH(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Grammars\\ANTLR.g3:1:16: FINALLY
			{
			DebugLocation(1, 16);
			mFINALLY(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Grammars\\ANTLR.g3:1:24: FRAGMENT
			{
			DebugLocation(1, 24);
			mFRAGMENT(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Grammars\\ANTLR.g3:1:33: GRAMMAR
			{
			DebugLocation(1, 33);
			mGRAMMAR(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Grammars\\ANTLR.g3:1:41: IMPORT
			{
			DebugLocation(1, 41);
			mIMPORT(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Grammars\\ANTLR.g3:1:48: LEXER
			{
			DebugLocation(1, 48);
			mLEXER(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Grammars\\ANTLR.g3:1:54: PARSER
			{
			DebugLocation(1, 54);
			mPARSER(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Grammars\\ANTLR.g3:1:61: PRIVATE
			{
			DebugLocation(1, 61);
			mPRIVATE(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Grammars\\ANTLR.g3:1:69: PROTECTED
			{
			DebugLocation(1, 69);
			mPROTECTED(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Grammars\\ANTLR.g3:1:79: PUBLIC
			{
			DebugLocation(1, 79);
			mPUBLIC(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Grammars\\ANTLR.g3:1:86: RETURNS
			{
			DebugLocation(1, 86);
			mRETURNS(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Grammars\\ANTLR.g3:1:94: SCOPE
			{
			DebugLocation(1, 94);
			mSCOPE(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Grammars\\ANTLR.g3:1:100: THROWS
			{
			DebugLocation(1, 100);
			mTHROWS(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Grammars\\ANTLR.g3:1:107: TREE
			{
			DebugLocation(1, 107);
			mTREE(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Grammars\\ANTLR.g3:1:112: WS
			{
			DebugLocation(1, 112);
			mWS(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Grammars\\ANTLR.g3:1:115: COMMENT
			{
			DebugLocation(1, 115);
			mCOMMENT(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Grammars\\ANTLR.g3:1:123: OPEN_ELEMENT_OPTION
			{
			DebugLocation(1, 123);
			mOPEN_ELEMENT_OPTION(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Grammars\\ANTLR.g3:1:143: CLOSE_ELEMENT_OPTION
			{
			DebugLocation(1, 143);
			mCLOSE_ELEMENT_OPTION(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Grammars\\ANTLR.g3:1:164: AMPERSAND
			{
			DebugLocation(1, 164);
			mAMPERSAND(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Grammars\\ANTLR.g3:1:174: COMMA
			{
			DebugLocation(1, 174);
			mCOMMA(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Grammars\\ANTLR.g3:1:180: QUESTION
			{
			DebugLocation(1, 180);
			mQUESTION(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Grammars\\ANTLR.g3:1:189: TREE_BEGIN
			{
			DebugLocation(1, 189);
			mTREE_BEGIN(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Grammars\\ANTLR.g3:1:200: LPAREN
			{
			DebugLocation(1, 200);
			mLPAREN(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Grammars\\ANTLR.g3:1:207: RPAREN
			{
			DebugLocation(1, 207);
			mRPAREN(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Grammars\\ANTLR.g3:1:214: COLON
			{
			DebugLocation(1, 214);
			mCOLON(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Grammars\\ANTLR.g3:1:220: STAR
			{
			DebugLocation(1, 220);
			mSTAR(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Grammars\\ANTLR.g3:1:225: PLUS
			{
			DebugLocation(1, 225);
			mPLUS(); if (state.failed) return;

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Grammars\\ANTLR.g3:1:230: ASSIGN
			{
			DebugLocation(1, 230);
			mASSIGN(); if (state.failed) return;

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Grammars\\ANTLR.g3:1:237: PLUS_ASSIGN
			{
			DebugLocation(1, 237);
			mPLUS_ASSIGN(); if (state.failed) return;

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Grammars\\ANTLR.g3:1:249: IMPLIES
			{
			DebugLocation(1, 249);
			mIMPLIES(); if (state.failed) return;

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Grammars\\ANTLR.g3:1:257: REWRITE
			{
			DebugLocation(1, 257);
			mREWRITE(); if (state.failed) return;

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Grammars\\ANTLR.g3:1:265: SEMI
			{
			DebugLocation(1, 265);
			mSEMI(); if (state.failed) return;

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Grammars\\ANTLR.g3:1:270: ROOT
			{
			DebugLocation(1, 270);
			mROOT(); if (state.failed) return;

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Grammars\\ANTLR.g3:1:275: BANG
			{
			DebugLocation(1, 275);
			mBANG(); if (state.failed) return;

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Grammars\\ANTLR.g3:1:280: OR
			{
			DebugLocation(1, 280);
			mOR(); if (state.failed) return;

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Grammars\\ANTLR.g3:1:283: WILDCARD
			{
			DebugLocation(1, 283);
			mWILDCARD(); if (state.failed) return;

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// Grammars\\ANTLR.g3:1:292: ETC
			{
			DebugLocation(1, 292);
			mETC(); if (state.failed) return;

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// Grammars\\ANTLR.g3:1:296: RANGE
			{
			DebugLocation(1, 296);
			mRANGE(); if (state.failed) return;

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// Grammars\\ANTLR.g3:1:302: NOT
			{
			DebugLocation(1, 302);
			mNOT(); if (state.failed) return;

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// Grammars\\ANTLR.g3:1:306: RCURLY
			{
			DebugLocation(1, 306);
			mRCURLY(); if (state.failed) return;

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// Grammars\\ANTLR.g3:1:313: DOLLAR
			{
			DebugLocation(1, 313);
			mDOLLAR(); if (state.failed) return;

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// Grammars\\ANTLR.g3:1:320: STRAY_BRACKET
			{
			DebugLocation(1, 320);
			mSTRAY_BRACKET(); if (state.failed) return;

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// Grammars\\ANTLR.g3:1:334: CHAR_LITERAL
			{
			DebugLocation(1, 334);
			mCHAR_LITERAL(); if (state.failed) return;

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// Grammars\\ANTLR.g3:1:347: DOUBLE_QUOTE_STRING_LITERAL
			{
			DebugLocation(1, 347);
			mDOUBLE_QUOTE_STRING_LITERAL(); if (state.failed) return;

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// Grammars\\ANTLR.g3:1:375: DOUBLE_ANGLE_STRING_LITERAL
			{
			DebugLocation(1, 375);
			mDOUBLE_ANGLE_STRING_LITERAL(); if (state.failed) return;

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// Grammars\\ANTLR.g3:1:403: INT
			{
			DebugLocation(1, 403);
			mINT(); if (state.failed) return;

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// Grammars\\ANTLR.g3:1:407: ARG_ACTION
			{
			DebugLocation(1, 407);
			mARG_ACTION(); if (state.failed) return;

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// Grammars\\ANTLR.g3:1:418: ACTION
			{
			DebugLocation(1, 418);
			mACTION(); if (state.failed) return;

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// Grammars\\ANTLR.g3:1:425: TOKEN_REF
			{
			DebugLocation(1, 425);
			mTOKEN_REF(); if (state.failed) return;

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// Grammars\\ANTLR.g3:1:435: TOKENS
			{
			DebugLocation(1, 435);
			mTOKENS(); if (state.failed) return;

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// Grammars\\ANTLR.g3:1:442: OPTIONS
			{
			DebugLocation(1, 442);
			mOPTIONS(); if (state.failed) return;

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// Grammars\\ANTLR.g3:1:450: RULE_REF
			{
			DebugLocation(1, 450);
			mRULE_REF(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_ANTLR_fragment();
	partial void LeaveRule_synpred1_ANTLR_fragment();

	// $ANTLR start synpred1_ANTLR
	private void synpred1_ANTLR_fragment()
	{
		EnterRule_synpred1_ANTLR_fragment();
		EnterRule("synpred1_ANTLR_fragment", 71);
		TraceIn("synpred1_ANTLR_fragment", 71);
		try
		{
			// Grammars\\ANTLR.g3:760:5: ( ' $ANTLR' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:760:6: ' $ANTLR'
			{
			DebugLocation(760, 6);
			Match(" $ANTLR"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred1_ANTLR_fragment", 71);
			LeaveRule("synpred1_ANTLR_fragment", 71);
			LeaveRule_synpred1_ANTLR_fragment();
		}
	}
	// $ANTLR end synpred1_ANTLR

	partial void EnterRule_synpred2_ANTLR_fragment();
	partial void LeaveRule_synpred2_ANTLR_fragment();

	// $ANTLR start synpred2_ANTLR
	private void synpred2_ANTLR_fragment()
	{
		EnterRule_synpred2_ANTLR_fragment();
		EnterRule("synpred2_ANTLR_fragment", 72);
		TraceIn("synpred2_ANTLR_fragment", 72);
		try
		{
			// Grammars\\ANTLR.g3:851:5: ( '\\\\\\\"' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:851:6: '\\\\\\\"'
			{
			DebugLocation(851, 6);
			Match("\\\""); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred2_ANTLR_fragment", 72);
			LeaveRule("synpred2_ANTLR_fragment", 72);
			LeaveRule_synpred2_ANTLR_fragment();
		}
	}
	// $ANTLR end synpred2_ANTLR

	partial void EnterRule_synpred3_ANTLR_fragment();
	partial void LeaveRule_synpred3_ANTLR_fragment();

	// $ANTLR start synpred3_ANTLR
	private void synpred3_ANTLR_fragment()
	{
		EnterRule_synpred3_ANTLR_fragment();
		EnterRule("synpred3_ANTLR_fragment", 73);
		TraceIn("synpred3_ANTLR_fragment", 73);
		try
		{
			// Grammars\\ANTLR.g3:918:6: ( '\\\\]' )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:918:7: '\\\\]'
			{
			DebugLocation(918, 7);
			Match("\\]"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred3_ANTLR_fragment", 73);
			LeaveRule("synpred3_ANTLR_fragment", 73);
			LeaveRule_synpred3_ANTLR_fragment();
		}
	}
	// $ANTLR end synpred3_ANTLR

	partial void EnterRule_synpred4_ANTLR_fragment();
	partial void LeaveRule_synpred4_ANTLR_fragment();

	// $ANTLR start synpred4_ANTLR
	private void synpred4_ANTLR_fragment()
	{
		EnterRule_synpred4_ANTLR_fragment();
		EnterRule("synpred4_ANTLR_fragment", 74);
		TraceIn("synpred4_ANTLR_fragment", 74);
		try
		{
			// Grammars\\ANTLR.g3:955:5: ( '//' | '/*' )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1=='/'))
			{
				int LA26_2 = input.LA(2);

				if ((LA26_2=='/'))
				{
					alt26 = 1;
				}
				else if ((LA26_2=='*'))
				{
					alt26 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 26, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:955:6: '//'
				{
				DebugLocation(955, 6);
				Match("//"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:955:13: '/*'
				{
				DebugLocation(955, 13);
				Match("/*"); if (state.failed) return;


				}
				break;

			}
		}
		finally
		{
			TraceOut("synpred4_ANTLR_fragment", 74);
			LeaveRule("synpred4_ANTLR_fragment", 74);
			LeaveRule_synpred4_ANTLR_fragment();
		}
	}
	// $ANTLR end synpred4_ANTLR

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA9 dfa9;
	DFA25 dfa25;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa9 = new DFA9(this, SpecialStateTransition9);
		dfa25 = new DFA25(this);
	}

	private class DFA9 : DFA
	{
		private const string DFA9_eotS =
			"\x2\x2\x1\xFFFF\xD\x2\x1\xFFFF\x5\x2\x1\xFFFF\x2\x2\x3\xFFFF\x1\x2\x1"+
			"\xFFFF";
		private const string DFA9_eofS =
			"\x1E\xFFFF";
		private const string DFA9_minS =
			"\x1\x20\x1\x24\x1\xFFFF\x1\x41\x1\x4E\x1\x54\x1\x4C\x1\x52\x1\x20\x1"+
			"\x73\x1\x72\x1\x63\x1\x20\x1\x22\x3\x0\x1\x20\x7\x0\x3\xFFFF\x1\x30\x1"+
			"\x0";
		private const string DFA9_maxS =
			"\x1\x20\x1\x24\x1\xFFFF\x1\x41\x1\x4E\x1\x54\x1\x4C\x1\x52\x1\x20\x1"+
			"\x73\x1\x72\x1\x63\x1\x20\x1\x22\x3\xFFFF\x1\x20\x7\xFFFF\x3\xFFFF\x1"+
			"\x39\x1\x0";
		private const string DFA9_acceptS =
			"\x2\xFFFF\x1\x2\x16\xFFFF\x3\x1\x2\xFFFF";
		private const string DFA9_specialS =
			"\xE\xFFFF\x1\x0\x1\x1\x1\x2\x1\xFFFF\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1"+
			"\x8\x1\x9\x4\xFFFF\x1\xA}>";
		private static readonly string[] DFA9_transitionS =
			{
				"\x1\x1",
				"\x1\x3",
				"",
				"\x1\x4",
				"\x1\x5",
				"\x1\x6",
				"\x1\x7",
				"\x1\x8",
				"\x1\x9",
				"\x1\xA",
				"\x1\xB",
				"\x1\xC",
				"\x1\xD",
				"\x1\xE",
				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
				"\xA\x18\x1\x17\x2\x18\x1\x16\x14\x18\x1\x15\x4\x18\x1\x14\xFFD8\x18",
				"\xA\x1B\x1\x12\x17\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
				"\x1\x1C",
				"\x22\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
				"\xA\x1B\x1\x12\x17\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
				"\x22\x1B\x1\x19\x39\x1B\x1\x1A\xFFA3\x1B",
				"\xA\x13\x1\x12\x2\x13\x1\x10\x14\x13\x1\x11\x39\x13\x1\xF\xFFA3\x13",
				"",
				"",
				"",
				"\xA\x1D",
				"\x1\xFFFF"
			};

		private static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
		private static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
		private static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
		private static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
		private static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
		private static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
		private static readonly short[][] DFA9_transition;

		static DFA9()
		{
			int numStates = DFA9_transitionS.Length;
			DFA9_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
			}
		}

		public DFA9( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 9;
			this.eot = DFA9_eot;
			this.eof = DFA9_eof;
			this.min = DFA9_min;
			this.max = DFA9_max;
			this.accept = DFA9_accept;
			this.special = DFA9_special;
			this.transition = DFA9_transition;
		}

		public override string Description { get { return "760:3: ( ( ' $ANTLR' )=> ' $ANTLR ' SRC ( ( '\\r' )? '\\n' )? | (~ ( '\\r' | '\\n' ) )* ( ( '\\r' )? '\\n' )? )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition9(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA9_1 = input.LA(1);
		int index9_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				if ((LA9_1=='\\')) {s = 15;}

				else if ((LA9_1=='\r')) {s = 16;}

				else if ((LA9_1=='\"')) {s = 17;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF'))) {s = 19;}

				else s = 2;

				break;
			}
		case 1:
			{
				if ((LA9_1=='\'')) {s = 20;}

				else if ((LA9_1=='\"')) {s = 21;}

				else if ((LA9_1=='\r')) {s = 22;}

				else if ((LA9_1=='\n')) {s = 23;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='&')||(LA9_1>='(' && LA9_1<='\uFFFF'))) {s = 24;}

				else s = 2;

				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA9_1=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}

				else if ((LA9_1=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}

				input.Seek(index9_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((LA9_1=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}

				else if ((LA9_1=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}

				else if (((LA9_1>='\u0000' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}

				else s = 2;

				input.Seek(index9_1);
				break;
			}
		case 4:
			{
				if ((LA9_1=='\"')) {s = 17;}

				else if ((LA9_1=='\\')) {s = 15;}

				else if ((LA9_1=='\r')) {s = 16;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF'))) {s = 19;}

				else s = 2;

				break;
			}
		case 5:
			{
				if ((LA9_1=='\"')) {s = 17;}

				else if ((LA9_1=='\\')) {s = 15;}

				else if ((LA9_1=='\r')) {s = 16;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF'))) {s = 19;}

				else s = 2;

				break;
			}
		case 6:
			{
				if ((LA9_1=='\"')) {s = 17;}

				else if ((LA9_1=='\\')) {s = 15;}

				else if ((LA9_1=='\r')) {s = 16;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF'))) {s = 19;}

				else s = 2;

				break;
			}
		case 7:
			{
				input.Rewind();
				if ((LA9_1=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}

				else if ((LA9_1=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}

				input.Seek(index9_1);
				break;
			}
		case 8:
			{
				input.Rewind();
				if ((LA9_1=='\"') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 25;}

				else if ((LA9_1=='\\') && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 26;}

				else if (((LA9_1>='\u0000' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF')) && (EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}

				else s = 2;

				input.Seek(index9_1);
				break;
			}
		case 9:
			{
				if ((LA9_1=='\"')) {s = 17;}

				else if ((LA9_1=='\\')) {s = 15;}

				else if ((LA9_1=='\r')) {s = 16;}

				else if ((LA9_1=='\n')) {s = 18;}

				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='!')||(LA9_1>='#' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF'))) {s = 19;}

				else s = 2;

				break;
			}
		case 10:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_ANTLR_fragment))) {s = 27;}

				else if ((true)) {s = 2;}

				input.Seek(index9_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 9, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA25 : DFA
	{
		private const string DFA25_eotS =
			"\x1\xFFFF\x9\x28\x2\xFFFF\x1\x38\x4\xFFFF\x1\x3A\x4\xFFFF\x1\x3C\x1\x3E"+
			"\x4\xFFFF\x1\x40\xA\xFFFF\x1\x28\x1\xFFFF\xE\x28\x8\xFFFF\x1\x52\x1\xFFFF"+
			"\x10\x28\x2\xFFFF\xE\x28\x1\x71\x2\x28\x1\x74\x4\x28\x1\x79\x5\x28\x1"+
			"\x7F\x1\x28\x1\xFFFF\x2\x28\x1\xFFFF\x3\x28\x1\x86\x1\xFFFF\x1\x87\x2"+
			"\x28\x1\x8A\x1\x28\x1\xFFFF\x1\x8C\x2\x28\x1\x8F\x1\x28\x1\x91\x2\xFFFF"+
			"\x1\x92\x1\x28\x1\xFFFF\x1\x94\x2\xFFFF\x1\x28\x1\xFFFF\x1\x96\x2\xFFFF"+
			"\x1\x28\x3\xFFFF\x1\x98\x1\xFFFF";
		private const string DFA25_eofS =
			"\x99\xFFFF";
		private const string DFA25_minS =
			"\x1\x9\x1\x61\x1\x69\x1\x72\x1\x6D\x1\x65\x1\x61\x1\x65\x1\x63\x1\x68"+
			"\x2\xFFFF\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E"+
			"\xA\xFFFF\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1"+
			"\x69\x1\x62\x1\x74\x1\x6F\x1\x72\x1\x65\x1\x6B\x8\xFFFF\x1\x2E\x1\xFFFF"+
			"\x1\x74\x1\x63\x1\x61\x1\x67\x1\x6D\x1\x6F\x1\x65\x1\x73\x1\x76\x1\x74"+
			"\x1\x6C\x1\x75\x1\x70\x1\x6F\x2\x65\x2\xFFFF\x1\x69\x1\x68\x1\x6C\x2"+
			"\x6D\x2\x72\x1\x65\x1\x61\x1\x65\x1\x69\x1\x72\x1\x65\x1\x77\x1\x30\x1"+
			"\x6E\x1\x6F\x1\x30\x1\x6C\x1\x65\x1\x61\x1\x74\x1\x30\x1\x72\x1\x74\x2"+
			"\x63\x1\x6E\x1\x30\x1\x73\x1\xFFFF\x1\x73\x1\x6E\x1\xFFFF\x1\x79\x1\x6E"+
			"\x1\x72\x1\x30\x1\xFFFF\x1\x30\x1\x65\x1\x74\x1\x30\x1\x73\x1\xFFFF\x1"+
			"\x30\x1\x9\x1\x73\x1\x30\x1\x74\x1\x30\x2\xFFFF\x1\x30\x1\x65\x1\xFFFF"+
			"\x1\x30\x2\xFFFF\x1\x9\x1\xFFFF\x1\x30\x2\xFFFF\x1\x64\x3\xFFFF\x1\x30"+
			"\x1\xFFFF";
		private const string DFA25_maxS =
			"\x1\x7E\x1\x61\x2\x72\x1\x6D\x1\x65\x1\x75\x1\x65\x1\x63\x1\x72\x2\xFFFF"+
			"\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E\xA\xFFFF"+
			"\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1\x6F\x1"+
			"\x62\x1\x74\x1\x6F\x1\x72\x1\x65\x1\x6B\x8\xFFFF\x1\x2E\x1\xFFFF\x1\x74"+
			"\x1\x63\x1\x61\x1\x67\x1\x6D\x1\x6F\x1\x65\x1\x73\x1\x76\x1\x74\x1\x6C"+
			"\x1\x75\x1\x70\x1\x6F\x2\x65\x2\xFFFF\x1\x69\x1\x68\x1\x6C\x2\x6D\x2"+
			"\x72\x1\x65\x1\x61\x1\x65\x1\x69\x1\x72\x1\x65\x1\x77\x1\x7A\x1\x6E\x1"+
			"\x6F\x1\x7A\x1\x6C\x1\x65\x1\x61\x1\x74\x1\x7A\x1\x72\x1\x74\x2\x63\x1"+
			"\x6E\x1\x7A\x1\x73\x1\xFFFF\x1\x73\x1\x6E\x1\xFFFF\x1\x79\x1\x6E\x1\x72"+
			"\x1\x7A\x1\xFFFF\x1\x7A\x1\x65\x1\x74\x1\x7A\x1\x73\x1\xFFFF\x1\x7A\x1"+
			"\x7B\x1\x73\x1\x7A\x1\x74\x1\x7A\x2\xFFFF\x1\x7A\x1\x65\x1\xFFFF\x1\x7A"+
			"\x2\xFFFF\x1\x7B\x1\xFFFF\x1\x7A\x2\xFFFF\x1\x64\x3\xFFFF\x1\x7A\x1\xFFFF";
		private const string DFA25_acceptS =
			"\xA\xFFFF\x1\xF\x1\x10\x1\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\xFFFF"+
			"\x1\x17\x1\x18\x1\x19\x1\x1A\x2\xFFFF\x1\x1F\x1\x20\x1\x22\x1\x23\x1"+
			"\xFFFF\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x2E\x1\x2F\x1\x30"+
			"\x1\x31\x1\xFFFF\x1\x34\xE\xFFFF\x1\x2D\x1\x11\x1\x16\x1\x21\x1\x1D\x1"+
			"\x1B\x1\x1E\x1\x1C\x1\xFFFF\x1\x24\x10\xFFFF\x1\x25\x1\x26\x1E\xFFFF"+
			"\x1\xE\x2\xFFFF\x1\x1\x4\xFFFF\x1\x6\x5\xFFFF\x1\xC\x6\xFFFF\x1\x5\x1"+
			"\x7\x2\xFFFF\x1\xA\x1\xFFFF\x1\xD\x1\x32\x1\xFFFF\x1\x2\x1\xFFFF\x1\x4"+
			"\x1\x8\x1\xFFFF\x1\xB\x1\x33\x1\x3\x1\xFFFF\x1\x9";
		private const string DFA25_specialS =
			"\x99\xFFFF}>";
		private static readonly string[] DFA25_transitionS =
			{
				"\x2\xA\x2\xFFFF\x1\xA\x12\xFFFF\x1\xA\x1\x1A\x1\x22\x1\xFFFF\x1\x1F"+
				"\x2\xFFFF\x1\x21\x1\x12\x1\x13\x1\x15\x1\x16\x1\xF\x1\x18\x1\x1C\x1"+
				"\xB\xA\x23\x1\x14\x1\x19\x1\xC\x1\x17\x1\xD\x1\x10\x1\xE\x1A\x26\x1"+
				"\x24\x1\xFFFF\x1\x20\x1\x11\x2\xFFFF\x2\x28\x1\x1\x2\x28\x1\x2\x1\x3"+
				"\x1\x28\x1\x4\x2\x28\x1\x5\x2\x28\x1\x27\x1\x6\x1\x28\x1\x7\x1\x8\x1"+
				"\x9\x6\x28\x1\x25\x1\x1B\x1\x1E\x1\x1D",
				"\x1\x29",
				"\x1\x2A\x8\xFFFF\x1\x2B",
				"\x1\x2C",
				"\x1\x2D",
				"\x1\x2E",
				"\x1\x2F\x10\xFFFF\x1\x30\x2\xFFFF\x1\x31",
				"\x1\x32",
				"\x1\x33",
				"\x1\x34\x6\xFFFF\x1\x36\x2\xFFFF\x1\x35",
				"",
				"",
				"\x1\x37",
				"",
				"",
				"",
				"",
				"\x1\x39",
				"",
				"",
				"",
				"",
				"\x1\x3B",
				"\x1\x3D",
				"",
				"",
				"",
				"",
				"\x1\x3F",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x41",
				"",
				"\x1\x42",
				"\x1\x43",
				"\x1\x44",
				"\x1\x45",
				"\x1\x46",
				"\x1\x47",
				"\x1\x48",
				"\x1\x49\x5\xFFFF\x1\x4A",
				"\x1\x4B",
				"\x1\x4C",
				"\x1\x4D",
				"\x1\x4E",
				"\x1\x4F",
				"\x1\x50",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x51",
				"",
				"\x1\x53",
				"\x1\x54",
				"\x1\x55",
				"\x1\x56",
				"\x1\x57",
				"\x1\x58",
				"\x1\x59",
				"\x1\x5A",
				"\x1\x5B",
				"\x1\x5C",
				"\x1\x5D",
				"\x1\x5E",
				"\x1\x5F",
				"\x1\x60",
				"\x1\x61",
				"\x1\x62",
				"",
				"",
				"\x1\x63",
				"\x1\x64",
				"\x1\x65",
				"\x1\x66",
				"\x1\x67",
				"\x1\x68",
				"\x1\x69",
				"\x1\x6A",
				"\x1\x6B",
				"\x1\x6C",
				"\x1\x6D",
				"\x1\x6E",
				"\x1\x6F",
				"\x1\x70",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x72",
				"\x1\x73",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x75",
				"\x1\x76",
				"\x1\x77",
				"\x1\x78",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x7A",
				"\x1\x7B",
				"\x1\x7C",
				"\x1\x7D",
				"\x1\x7E",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x80",
				"",
				"\x1\x81",
				"\x1\x82",
				"",
				"\x1\x83",
				"\x1\x84",
				"\x1\x85",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x88",
				"\x1\x89",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x8B",
				"",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x2\x8D\x2\xFFFF\x1\x8D\x12\xFFFF\x1\x8D\xE\xFFFF\x1\x8D\x4B\xFFFF\x1"+
				"\x8D",
				"\x1\x8E",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x90",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"",
				"",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"\x1\x93",
				"",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"",
				"",
				"\x2\x95\x2\xFFFF\x1\x95\x12\xFFFF\x1\x95\xE\xFFFF\x1\x95\x4B\xFFFF\x1"+
				"\x95",
				"",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				"",
				"",
				"\x1\x97",
				"",
				"",
				"",
				"\xA\x28\x7\xFFFF\x1A\x28\x4\xFFFF\x1\x28\x1\xFFFF\x1A\x28",
				""
			};

		private static readonly short[] DFA25_eot = DFA.UnpackEncodedString(DFA25_eotS);
		private static readonly short[] DFA25_eof = DFA.UnpackEncodedString(DFA25_eofS);
		private static readonly char[] DFA25_min = DFA.UnpackEncodedStringToUnsignedChars(DFA25_minS);
		private static readonly char[] DFA25_max = DFA.UnpackEncodedStringToUnsignedChars(DFA25_maxS);
		private static readonly short[] DFA25_accept = DFA.UnpackEncodedString(DFA25_acceptS);
		private static readonly short[] DFA25_special = DFA.UnpackEncodedString(DFA25_specialS);
		private static readonly short[][] DFA25_transition;

		static DFA25()
		{
			int numStates = DFA25_transitionS.Length;
			DFA25_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA25_transition[i] = DFA.UnpackEncodedString(DFA25_transitionS[i]);
			}
		}

		public DFA25( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 25;
			this.eot = DFA25_eot;
			this.eof = DFA25_eof;
			this.min = DFA25_min;
			this.max = DFA25_max;
			this.accept = DFA25_accept;
			this.special = DFA25_special;
			this.transition = DFA25_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion

}

} // namespace Antlr3.Grammars
