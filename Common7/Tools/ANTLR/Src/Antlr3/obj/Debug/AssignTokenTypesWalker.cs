//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\AssignTokenTypesWalker.g3 2013-06-14 09:39:33

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Antlr3.Grammars
{
/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
 *   but since it's probably still useful, I'll leave in.  Don't have energy
 *   to update at the moment.]
 *
 *  Compute the token types for all literals and rules etc..  There are
 *  a few different cases to consider for grammar types and a few situations
 *  within.
 *
 *  CASE 1 : pure parser grammar
 *	a) Any reference to a token gets a token type.
 *  b) The tokens section may alias a token name to a string or char
 *
 *  CASE 2 : pure lexer grammar
 *  a) Import token vocabulary if available. Set token types for any new tokens
 *     to values above last imported token type
 *  b) token rule definitions get token types if not already defined
 *  c) literals do NOT get token types
 *
 *  CASE 3 : merged parser / lexer grammar
 *	a) Any char or string literal gets a token type in a parser rule
 *  b) Any reference to a token gets a token type if not referencing
 *     a fragment lexer rule
 *  c) The tokens section may alias a token name to a string or char
 *     which must add a rule to the lexer
 *  d) token rule definitions get token types if not already defined
 *  e) token rule definitions may also alias a token name to a literal.
 *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
 *     references to either in the parser grammar will yield the token type
 *
 *  What this pass does:
 *
 *  0. Collects basic info about the grammar like grammar name and type;
 *     Oh, I have go get the options in case they affect the token types.
 *     E.g., tokenVocab option.
 *     Imports any token vocab name/type pairs into a local hashtable.
 *  1. Finds a list of all literals and token names.
 *  2. Finds a list of all token name rule definitions;
 *     no token rules implies pure parser.
 *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
 *     and aliases them.
 *  4. Walks token names table and assign types to any unassigned
 *  5. Walks aliases and assign types to referenced literals
 *  6. Walks literals, assigning types if untyped
 *  4. Informs the Grammar object of the type definitions such as:
 *     g.defineToken(<charliteral>, ttype);
 *     g.defineToken(<stringliteral>, ttype);
 *     g.defineToken(<tokenID>, ttype);
 *     where some of the ttype values will be the same for aliases tokens.
 */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class AssignTokenTypesWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", "ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", "TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT", "CHARSET"
	};
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ACTION_CHAR_LITERAL=5;
	public const int ACTION_ESC=6;
	public const int ACTION_STRING_LITERAL=7;
	public const int ALT=8;
	public const int AMPERSAND=9;
	public const int ARG=10;
	public const int ARGLIST=11;
	public const int ARG_ACTION=12;
	public const int ASSIGN=13;
	public const int BACKTRACK_SEMPRED=14;
	public const int BANG=15;
	public const int BLOCK=16;
	public const int CATCH=17;
	public const int CHAR_LITERAL=18;
	public const int CHAR_RANGE=19;
	public const int CLOSE_ELEMENT_OPTION=20;
	public const int CLOSURE=21;
	public const int COLON=22;
	public const int COMBINED_GRAMMAR=23;
	public const int COMMA=24;
	public const int COMMENT=25;
	public const int DIGIT=26;
	public const int DOC_COMMENT=27;
	public const int DOLLAR=28;
	public const int DOT=29;
	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
	public const int EOA=32;
	public const int EOB=33;
	public const int EOR=34;
	public const int EPSILON=35;
	public const int ESC=36;
	public const int ETC=37;
	public const int FINALLY=38;
	public const int FORCED_ACTION=39;
	public const int FRAGMENT=40;
	public const int GATED_SEMPRED=41;
	public const int GRAMMAR=42;
	public const int ID=43;
	public const int IMPLIES=44;
	public const int IMPORT=45;
	public const int INITACTION=46;
	public const int INT=47;
	public const int LABEL=48;
	public const int LEXER=49;
	public const int LEXER_GRAMMAR=50;
	public const int LPAREN=51;
	public const int ML_COMMENT=52;
	public const int NESTED_ACTION=53;
	public const int NESTED_ARG_ACTION=54;
	public const int NOT=55;
	public const int OPEN_ELEMENT_OPTION=56;
	public const int OPTIONAL=57;
	public const int OPTIONS=58;
	public const int OR=59;
	public const int PARSER=60;
	public const int PARSER_GRAMMAR=61;
	public const int PLUS=62;
	public const int PLUS_ASSIGN=63;
	public const int POSITIVE_CLOSURE=64;
	public const int PREC_RULE=65;
	public const int PRIVATE=66;
	public const int PROTECTED=67;
	public const int PUBLIC=68;
	public const int QUESTION=69;
	public const int RANGE=70;
	public const int RCURLY=71;
	public const int RECURSIVE_RULE_REF=72;
	public const int RET=73;
	public const int RETURNS=74;
	public const int REWRITE=75;
	public const int REWRITES=76;
	public const int ROOT=77;
	public const int RPAREN=78;
	public const int RULE=79;
	public const int RULE_REF=80;
	public const int SCOPE=81;
	public const int SEMI=82;
	public const int SEMPRED=83;
	public const int SL_COMMENT=84;
	public const int SRC=85;
	public const int STAR=86;
	public const int STRAY_BRACKET=87;
	public const int STRING_LITERAL=88;
	public const int SYNPRED=89;
	public const int SYN_SEMPRED=90;
	public const int TEMPLATE=91;
	public const int THROWS=92;
	public const int TOKENS=93;
	public const int TOKEN_REF=94;
	public const int TREE=95;
	public const int TREE_BEGIN=96;
	public const int TREE_GRAMMAR=97;
	public const int WILDCARD=98;
	public const int WS=99;
	public const int WS_LOOP=100;
	public const int WS_OPT=101;
	public const int XDIGIT=102;
	public const int CHARSET=103;

	public AssignTokenTypesWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public AssignTokenTypesWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return AssignTokenTypesWalker.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\AssignTokenTypesWalker.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_grammar_();
	partial void LeaveRule_grammar_();
	// $ANTLR start "grammar_"
	// Grammars\\AssignTokenTypesWalker.g3:100:1: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
	[GrammarRule("grammar_")]
	public void grammar_(Grammar g)
	{
		EnterRule_grammar_();
		EnterRule("grammar_", 1);
		TraceIn("grammar_", 1);

			if ( state.backtracking == 0 )
				Init(g);

		try { DebugEnterRule(GrammarFileName, "grammar_");
		DebugLocation(100, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:106:2: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:106:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
			{
			DebugLocation(106, 4);
			// Grammars\\AssignTokenTypesWalker.g3:106:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
			int alt1=4;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case LEXER_GRAMMAR:
				{
				alt1 = 1;
				}
				break;
			case PARSER_GRAMMAR:
				{
				alt1 = 2;
				}
				break;
			case TREE_GRAMMAR:
				{
				alt1 = 3;
				}
				break;
			case COMBINED_GRAMMAR:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:106:6: ^( LEXER_GRAMMAR grammarSpec )
				{
				DebugLocation(106, 6);
				DebugLocation(106, 8);
				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_67); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(106, 25);
				PushFollow(Follow._grammarSpec_in_grammar_72);
				grammarSpec();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:107:5: ^( PARSER_GRAMMAR grammarSpec )
				{
				DebugLocation(107, 5);
				DebugLocation(107, 7);
				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_80); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(107, 24);
				PushFollow(Follow._grammarSpec_in_grammar_84);
				grammarSpec();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\AssignTokenTypesWalker.g3:108:5: ^( TREE_GRAMMAR grammarSpec )
				{
				DebugLocation(108, 5);
				DebugLocation(108, 7);
				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_92); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(108, 24);
				PushFollow(Follow._grammarSpec_in_grammar_98);
				grammarSpec();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\AssignTokenTypesWalker.g3:109:5: ^( COMBINED_GRAMMAR grammarSpec )
				{
				DebugLocation(109, 5);
				DebugLocation(109, 7);
				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_106); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(109, 24);
				PushFollow(Follow._grammarSpec_in_grammar_108);
				grammarSpec();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("grammar_", 1);
			LeaveRule("grammar_", 1);
			LeaveRule_grammar_();
		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "grammar_"); }
		return;

	}
	// $ANTLR end "grammar_"

	partial void EnterRule_grammarSpec();
	partial void LeaveRule_grammarSpec();
	// $ANTLR start "grammarSpec"
	// Grammars\\AssignTokenTypesWalker.g3:113:1: grammarSpec : ID ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
	[GrammarRule("grammarSpec")]
	private void grammarSpec()
	{
		EnterRule_grammarSpec();
		EnterRule("grammarSpec", 2);
		TraceIn("grammarSpec", 2);
		try { DebugEnterRule(GrammarFileName, "grammarSpec");
		DebugLocation(113, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:114:2: ( ID ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:114:4: ID ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
			{
			DebugLocation(114, 4);
			Match(input,ID,Follow._ID_in_grammarSpec124); 
			DebugLocation(115, 3);
			// Grammars\\AssignTokenTypesWalker.g3:115:3: ( DOC_COMMENT )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==DOC_COMMENT))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:115:3: DOC_COMMENT
				{
				DebugLocation(115, 3);
				Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec128); 

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(116, 3);
			// Grammars\\AssignTokenTypesWalker.g3:116:3: ( optionsSpec )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==OPTIONS))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:116:3: optionsSpec
				{
				DebugLocation(116, 3);
				PushFollow(Follow._optionsSpec_in_grammarSpec133);
				optionsSpec();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(117, 3);
			// Grammars\\AssignTokenTypesWalker.g3:117:3: ( delegateGrammars )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==IMPORT))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:117:3: delegateGrammars
				{
				DebugLocation(117, 3);
				PushFollow(Follow._delegateGrammars_in_grammarSpec138);
				delegateGrammars();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(118, 3);
			// Grammars\\AssignTokenTypesWalker.g3:118:3: ( tokensSpec )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==TOKENS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:118:3: tokensSpec
				{
				DebugLocation(118, 3);
				PushFollow(Follow._tokensSpec_in_grammarSpec143);
				tokensSpec();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(119, 3);
			// Grammars\\AssignTokenTypesWalker.g3:119:3: ( attrScope )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==SCOPE))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:119:3: attrScope
					{
					DebugLocation(119, 3);
					PushFollow(Follow._attrScope_in_grammarSpec148);
					attrScope();
					PopFollow();


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(120, 3);
			// Grammars\\AssignTokenTypesWalker.g3:120:3: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==AMPERSAND))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:120:5: ^( AMPERSAND ( . )* )
					{
					DebugLocation(120, 5);
					DebugLocation(120, 7);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec156); 

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); 
						DebugLocation(120, 17);
						// Grammars\\AssignTokenTypesWalker.g3:120:17: ( . )*
						try { DebugEnterSubRule(7);
						while (true)
						{
							int alt7=2;
							try { DebugEnterDecision(7, false);
							int LA7_1 = input.LA(1);

							if (((LA7_1>=ACTION && LA7_1<=CHARSET)))
							{
								alt7 = 1;
							}
							else if ((LA7_1==UP))
							{
								alt7 = 2;
							}


							} finally { DebugExitDecision(7); }
							switch ( alt7 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\AssignTokenTypesWalker.g3:120:17: .
								{
								DebugLocation(120, 17);
								MatchAny(input); 

								}
								break;

							default:
								goto loop7;
							}
						}

						loop7:
							;

						} finally { DebugExitSubRule(7); }


						Match(input, TokenTypes.Up, null); 
					}


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(121, 3);
			PushFollow(Follow._rules_in_grammarSpec168);
			rules();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("grammarSpec", 2);
			LeaveRule("grammarSpec", 2);
			LeaveRule_grammarSpec();
		}
		DebugLocation(122, 1);
		} finally { DebugExitRule(GrammarFileName, "grammarSpec"); }
		return;

	}
	// $ANTLR end "grammarSpec"

	partial void EnterRule_attrScope();
	partial void LeaveRule_attrScope();
	// $ANTLR start "attrScope"
	// Grammars\\AssignTokenTypesWalker.g3:124:1: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
	[GrammarRule("attrScope")]
	private void attrScope()
	{
		EnterRule_attrScope();
		EnterRule("attrScope", 3);
		TraceIn("attrScope", 3);
		try { DebugEnterRule(GrammarFileName, "attrScope");
		DebugLocation(124, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:125:2: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:125:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
			{
			DebugLocation(125, 4);
			DebugLocation(125, 6);
			Match(input,SCOPE,Follow._SCOPE_in_attrScope180); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(125, 14);
			Match(input,ID,Follow._ID_in_attrScope182); 
			DebugLocation(125, 17);
			// Grammars\\AssignTokenTypesWalker.g3:125:17: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==AMPERSAND))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:125:19: ^( AMPERSAND ( . )* )
					{
					DebugLocation(125, 19);
					DebugLocation(125, 21);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope187); 

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); 
						DebugLocation(125, 31);
						// Grammars\\AssignTokenTypesWalker.g3:125:31: ( . )*
						try { DebugEnterSubRule(9);
						while (true)
						{
							int alt9=2;
							try { DebugEnterDecision(9, false);
							int LA9_1 = input.LA(1);

							if (((LA9_1>=ACTION && LA9_1<=CHARSET)))
							{
								alt9 = 1;
							}
							else if ((LA9_1==UP))
							{
								alt9 = 2;
							}


							} finally { DebugExitDecision(9); }
							switch ( alt9 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\AssignTokenTypesWalker.g3:125:31: .
								{
								DebugLocation(125, 31);
								MatchAny(input); 

								}
								break;

							default:
								goto loop9;
							}
						}

						loop9:
							;

						} finally { DebugExitSubRule(9); }


						Match(input, TokenTypes.Up, null); 
					}


					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(125, 38);
			Match(input,ACTION,Follow._ACTION_in_attrScope196); 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attrScope", 3);
			LeaveRule("attrScope", 3);
			LeaveRule_attrScope();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "attrScope"); }
		return;

	}
	// $ANTLR end "attrScope"

	partial void EnterRule_optionsSpec();
	partial void LeaveRule_optionsSpec();
	// $ANTLR start "optionsSpec"
	// Grammars\\AssignTokenTypesWalker.g3:128:1: optionsSpec returns [IDictionary<object, object> opts = new Dictionary<object, object>()] : ^( OPTIONS ( option[$opts] )* ) ;
	[GrammarRule("optionsSpec")]
	private IDictionary<object, object> optionsSpec()
	{
		EnterRule_optionsSpec();
		EnterRule("optionsSpec", 4);
		TraceIn("optionsSpec", 4);
		IDictionary<object, object> opts =  new Dictionary<object, object>();


		try { DebugEnterRule(GrammarFileName, "optionsSpec");
		DebugLocation(128, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:129:2: ( ^( OPTIONS ( option[$opts] )* ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:129:4: ^( OPTIONS ( option[$opts] )* )
			{
			DebugLocation(129, 4);
			DebugLocation(129, 6);
			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec213); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(129, 14);
				// Grammars\\AssignTokenTypesWalker.g3:129:14: ( option[$opts] )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==ASSIGN))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:129:15: option[$opts]
						{
						DebugLocation(129, 15);
						PushFollow(Follow._option_in_optionsSpec216);
						option(opts);
						PopFollow();


						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("optionsSpec", 4);
			LeaveRule("optionsSpec", 4);
			LeaveRule_optionsSpec();
		}
		DebugLocation(130, 1);
		} finally { DebugExitRule(GrammarFileName, "optionsSpec"); }
		return opts;

	}
	// $ANTLR end "optionsSpec"

	partial void EnterRule_option();
	partial void LeaveRule_option();
	// $ANTLR start "option"
	// Grammars\\AssignTokenTypesWalker.g3:132:1: option[IDictionary<object, object> opts] : ^( ASSIGN ID optionValue ) ;
	[GrammarRule("option")]
	private void option(IDictionary<object, object> opts)
	{
		EnterRule_option();
		EnterRule("option", 5);
		TraceIn("option", 5);
		GrammarAST ID1 = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> optionValue2 = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "option");
		DebugLocation(132, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:133:2: ( ^( ASSIGN ID optionValue ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:133:4: ^( ASSIGN ID optionValue )
			{
			DebugLocation(133, 4);
			DebugLocation(133, 6);
			Match(input,ASSIGN,Follow._ASSIGN_in_option233); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(133, 13);
			ID1=(GrammarAST)Match(input,ID,Follow._ID_in_option235); 
			DebugLocation(133, 16);
			PushFollow(Follow._optionValue_in_option237);
			optionValue2=optionValue();
			PopFollow();


			Match(input, TokenTypes.Up, null); 

			DebugLocation(134, 3);

						string key = (ID1!=null?ID1.Text:default(string));
						opts[key] = (optionValue2!=null?((AssignTokenTypesWalker.optionValue_return)optionValue2).value:default(object));
						// check for grammar-level option to import vocabulary
						if ( currentRuleName==null && key.Equals("tokenVocab") )
						{
							grammar.ImportTokenVocabulary(ID1,(string)(optionValue2!=null?((AssignTokenTypesWalker.optionValue_return)optionValue2).value:default(object)));
						}
					

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("option", 5);
			LeaveRule("option", 5);
			LeaveRule_option();
		}
		DebugLocation(143, 1);
		} finally { DebugExitRule(GrammarFileName, "option"); }
		return;

	}
	// $ANTLR end "option"

	private sealed partial class optionValue_return : TreeRuleReturnScope<GrammarAST>
	{
		public object value=null;
		public optionValue_return(AssignTokenTypesWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(AssignTokenTypesWalker grammar);
	}

	partial void EnterRule_optionValue();
	partial void LeaveRule_optionValue();
	// $ANTLR start "optionValue"
	// Grammars\\AssignTokenTypesWalker.g3:145:1: optionValue returns [object value=null] : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
	[GrammarRule("optionValue")]
	private AssignTokenTypesWalker.optionValue_return optionValue()
	{
		EnterRule_optionValue();
		EnterRule("optionValue", 6);
		TraceIn("optionValue", 6);
		AssignTokenTypesWalker.optionValue_return retval = new AssignTokenTypesWalker.optionValue_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST INT3 = default(GrammarAST);


			if (state.backtracking == 0)
				retval.value = retval.Start.Text;

		try { DebugEnterRule(GrammarFileName, "optionValue");
		DebugLocation(145, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:151:2: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
			int alt12=4;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt12 = 1;
				}
				break;
			case STRING_LITERAL:
				{
				alt12 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt12 = 3;
				}
				break;
			case INT:
				{
				alt12 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:151:4: ID
				{
				DebugLocation(151, 4);
				Match(input,ID,Follow._ID_in_optionValue262); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:152:4: STRING_LITERAL
				{
				DebugLocation(152, 4);
				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue267); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\AssignTokenTypesWalker.g3:153:4: CHAR_LITERAL
				{
				DebugLocation(153, 4);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue272); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\AssignTokenTypesWalker.g3:154:4: INT
				{
				DebugLocation(154, 4);
				INT3=(GrammarAST)Match(input,INT,Follow._INT_in_optionValue277); 
				DebugLocation(154, 11);
				retval.value = int.Parse((INT3!=null?INT3.Text:default(string)));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("optionValue", 6);
			LeaveRule("optionValue", 6);
			LeaveRule_optionValue();
		}
		DebugLocation(156, 1);
		} finally { DebugExitRule(GrammarFileName, "optionValue"); }
		return retval;

	}
	// $ANTLR end "optionValue"

	partial void EnterRule_charSet();
	partial void LeaveRule_charSet();
	// $ANTLR start "charSet"
	// Grammars\\AssignTokenTypesWalker.g3:158:1: charSet : ^( CHARSET charSetElement ) ;
	[GrammarRule("charSet")]
	private void charSet()
	{
		EnterRule_charSet();
		EnterRule("charSet", 7);
		TraceIn("charSet", 7);
		try { DebugEnterRule(GrammarFileName, "charSet");
		DebugLocation(158, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:159:2: ( ^( CHARSET charSetElement ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:159:4: ^( CHARSET charSetElement )
			{
			DebugLocation(159, 4);
			DebugLocation(159, 6);
			Match(input,CHARSET,Follow._CHARSET_in_charSet295); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(159, 14);
			PushFollow(Follow._charSetElement_in_charSet297);
			charSetElement();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("charSet", 7);
			LeaveRule("charSet", 7);
			LeaveRule_charSet();
		}
		DebugLocation(160, 1);
		} finally { DebugExitRule(GrammarFileName, "charSet"); }
		return;

	}
	// $ANTLR end "charSet"

	partial void EnterRule_charSetElement();
	partial void LeaveRule_charSetElement();
	// $ANTLR start "charSetElement"
	// Grammars\\AssignTokenTypesWalker.g3:162:1: charSetElement : ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) );
	[GrammarRule("charSetElement")]
	private void charSetElement()
	{
		EnterRule_charSetElement();
		EnterRule("charSetElement", 8);
		TraceIn("charSetElement", 8);
		try { DebugEnterRule(GrammarFileName, "charSetElement");
		DebugLocation(162, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:163:2: ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) )
			int alt13=3;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				alt13 = 1;
				}
				break;
			case OR:
				{
				alt13 = 2;
				}
				break;
			case RANGE:
				{
				alt13 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:163:4: CHAR_LITERAL
				{
				DebugLocation(163, 4);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement309); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:164:4: ^( OR CHAR_LITERAL CHAR_LITERAL )
				{
				DebugLocation(164, 4);
				DebugLocation(164, 6);
				Match(input,OR,Follow._OR_in_charSetElement315); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(164, 9);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement317); 
				DebugLocation(164, 22);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement319); 

				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\AssignTokenTypesWalker.g3:165:4: ^( RANGE CHAR_LITERAL CHAR_LITERAL )
				{
				DebugLocation(165, 4);
				DebugLocation(165, 6);
				Match(input,RANGE,Follow._RANGE_in_charSetElement326); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(165, 12);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement328); 
				DebugLocation(165, 25);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement330); 

				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("charSetElement", 8);
			LeaveRule("charSetElement", 8);
			LeaveRule_charSetElement();
		}
		DebugLocation(166, 1);
		} finally { DebugExitRule(GrammarFileName, "charSetElement"); }
		return;

	}
	// $ANTLR end "charSetElement"

	partial void EnterRule_delegateGrammars();
	partial void LeaveRule_delegateGrammars();
	// $ANTLR start "delegateGrammars"
	// Grammars\\AssignTokenTypesWalker.g3:168:1: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
	[GrammarRule("delegateGrammars")]
	private void delegateGrammars()
	{
		EnterRule_delegateGrammars();
		EnterRule("delegateGrammars", 9);
		TraceIn("delegateGrammars", 9);
		try { DebugEnterRule(GrammarFileName, "delegateGrammars");
		DebugLocation(168, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:169:2: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:169:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
			{
			DebugLocation(169, 4);
			DebugLocation(169, 7);
			Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars344); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(170, 4);
			// Grammars\\AssignTokenTypesWalker.g3:170:4: ( ^( ASSIGN ID ID ) | ID )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=3;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==ASSIGN))
				{
					alt14 = 1;
				}
				else if ((LA14_1==ID))
				{
					alt14 = 2;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:170:6: ^( ASSIGN ID ID )
					{
					DebugLocation(170, 6);
					DebugLocation(170, 8);
					Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars352); 

					Match(input, TokenTypes.Down, null); 
					DebugLocation(170, 15);
					Match(input,ID,Follow._ID_in_delegateGrammars354); 
					DebugLocation(170, 18);
					Match(input,ID,Follow._ID_in_delegateGrammars356); 

					Match(input, TokenTypes.Up, null); 


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\AssignTokenTypesWalker.g3:171:6: ID
					{
					DebugLocation(171, 6);
					Match(input,ID,Follow._ID_in_delegateGrammars364); 

					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("delegateGrammars", 9);
			LeaveRule("delegateGrammars", 9);
			LeaveRule_delegateGrammars();
		}
		DebugLocation(174, 1);
		} finally { DebugExitRule(GrammarFileName, "delegateGrammars"); }
		return;

	}
	// $ANTLR end "delegateGrammars"

	partial void EnterRule_tokensSpec();
	partial void LeaveRule_tokensSpec();
	// $ANTLR start "tokensSpec"
	// Grammars\\AssignTokenTypesWalker.g3:176:1: tokensSpec : ^( TOKENS ( tokenSpec )* ) ;
	[GrammarRule("tokensSpec")]
	private void tokensSpec()
	{
		EnterRule_tokensSpec();
		EnterRule("tokensSpec", 10);
		TraceIn("tokensSpec", 10);
		try { DebugEnterRule(GrammarFileName, "tokensSpec");
		DebugLocation(176, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:177:2: ( ^( TOKENS ( tokenSpec )* ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:177:4: ^( TOKENS ( tokenSpec )* )
			{
			DebugLocation(177, 4);
			DebugLocation(177, 6);
			Match(input,TOKENS,Follow._TOKENS_in_tokensSpec386); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(177, 13);
				// Grammars\\AssignTokenTypesWalker.g3:177:13: ( tokenSpec )*
				try { DebugEnterSubRule(15);
				while (true)
				{
					int alt15=2;
					try { DebugEnterDecision(15, false);
					int LA15_1 = input.LA(1);

					if ((LA15_1==ASSIGN||LA15_1==TOKEN_REF))
					{
						alt15 = 1;
					}


					} finally { DebugExitDecision(15); }
					switch ( alt15 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:177:13: tokenSpec
						{
						DebugLocation(177, 13);
						PushFollow(Follow._tokenSpec_in_tokensSpec388);
						tokenSpec();
						PopFollow();


						}
						break;

					default:
						goto loop15;
					}
				}

				loop15:
					;

				} finally { DebugExitSubRule(15); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tokensSpec", 10);
			LeaveRule("tokensSpec", 10);
			LeaveRule_tokensSpec();
		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "tokensSpec"); }
		return;

	}
	// $ANTLR end "tokensSpec"

	partial void EnterRule_tokenSpec();
	partial void LeaveRule_tokenSpec();
	// $ANTLR start "tokenSpec"
	// Grammars\\AssignTokenTypesWalker.g3:180:1: tokenSpec : (t= TOKEN_REF | ^( ASSIGN t= TOKEN_REF (s= STRING_LITERAL |s= CHAR_LITERAL ) ) );
	[GrammarRule("tokenSpec")]
	private void tokenSpec()
	{
		EnterRule_tokenSpec();
		EnterRule("tokenSpec", 11);
		TraceIn("tokenSpec", 11);
		GrammarAST t = default(GrammarAST);
		GrammarAST s = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "tokenSpec");
		DebugLocation(180, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:181:2: (t= TOKEN_REF | ^( ASSIGN t= TOKEN_REF (s= STRING_LITERAL |s= CHAR_LITERAL ) ) )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==TOKEN_REF))
			{
				alt17 = 1;
			}
			else if ((LA17_1==ASSIGN))
			{
				alt17 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:181:4: t= TOKEN_REF
				{
				DebugLocation(181, 5);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec403); 
				DebugLocation(181, 20);
				TrackToken(t);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:182:4: ^( ASSIGN t= TOKEN_REF (s= STRING_LITERAL |s= CHAR_LITERAL ) )
				{
				DebugLocation(182, 4);
				DebugLocation(182, 7);
				Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec416); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(183, 5);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec423); 
				DebugLocation(183, 19);
				TrackToken(t);
				DebugLocation(184, 4);
				// Grammars\\AssignTokenTypesWalker.g3:184:4: (s= STRING_LITERAL |s= CHAR_LITERAL )
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==STRING_LITERAL))
				{
					alt16 = 1;
				}
				else if ((LA16_1==CHAR_LITERAL))
				{
					alt16 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:184:6: s= STRING_LITERAL
					{
					DebugLocation(184, 7);
					s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_tokenSpec437); 
					DebugLocation(184, 23);
					TrackString(s); Alias(t, s);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\AssignTokenTypesWalker.g3:185:6: s= CHAR_LITERAL
					{
					DebugLocation(185, 7);
					s=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_tokenSpec448); 
					DebugLocation(185, 22);
					TrackString(s); Alias(t, s);

					}
					break;

				}
				} finally { DebugExitSubRule(16); }


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tokenSpec", 11);
			LeaveRule("tokenSpec", 11);
			LeaveRule_tokenSpec();
		}
		DebugLocation(188, 1);
		} finally { DebugExitRule(GrammarFileName, "tokenSpec"); }
		return;

	}
	// $ANTLR end "tokenSpec"

	partial void EnterRule_rules();
	partial void LeaveRule_rules();
	// $ANTLR start "rules"
	// Grammars\\AssignTokenTypesWalker.g3:190:1: rules : ( rule )+ ;
	[GrammarRule("rules")]
	private void rules()
	{
		EnterRule_rules();
		EnterRule("rules", 12);
		TraceIn("rules", 12);
		try { DebugEnterRule(GrammarFileName, "rules");
		DebugLocation(190, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:191:2: ( ( rule )+ )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:191:4: ( rule )+
			{
			DebugLocation(191, 4);
			// Grammars\\AssignTokenTypesWalker.g3:191:4: ( rule )+
			int cnt18=0;
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==PREC_RULE||LA18_1==RULE))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:191:4: rule
					{
					DebugLocation(191, 4);
					PushFollow(Follow._rule_in_rules471);
					rule();
					PopFollow();


					}
					break;

				default:
					if (cnt18 >= 1)
						goto loop18;

					EarlyExitException eee18 = new EarlyExitException( 18, input );
					DebugRecognitionException(eee18);
					throw eee18;
				}
				cnt18++;
			}
			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rules", 12);
			LeaveRule("rules", 12);
			LeaveRule_rules();
		}
		DebugLocation(192, 1);
		} finally { DebugExitRule(GrammarFileName, "rules"); }
		return;

	}
	// $ANTLR end "rules"

	partial void EnterRule_rule();
	partial void LeaveRule_rule();
	// $ANTLR start "rule"
	// Grammars\\AssignTokenTypesWalker.g3:194:1: rule : ( ^( RULE ruleBody ) | ^( PREC_RULE ruleBody ) );
	[GrammarRule("rule")]
	private void rule()
	{
		EnterRule_rule();
		EnterRule("rule", 13);
		TraceIn("rule", 13);
		try { DebugEnterRule(GrammarFileName, "rule");
		DebugLocation(194, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:195:2: ( ^( RULE ruleBody ) | ^( PREC_RULE ruleBody ) )
			int alt19=2;
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==RULE))
			{
				alt19 = 1;
			}
			else if ((LA19_1==PREC_RULE))
			{
				alt19 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:195:4: ^( RULE ruleBody )
				{
				DebugLocation(195, 4);
				DebugLocation(195, 6);
				Match(input,RULE,Follow._RULE_in_rule484); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(195, 11);
				PushFollow(Follow._ruleBody_in_rule486);
				ruleBody();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:196:4: ^( PREC_RULE ruleBody )
				{
				DebugLocation(196, 4);
				DebugLocation(196, 6);
				Match(input,PREC_RULE,Follow._PREC_RULE_in_rule493); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(196, 16);
				PushFollow(Follow._ruleBody_in_rule495);
				ruleBody();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rule", 13);
			LeaveRule("rule", 13);
			LeaveRule_rule();
		}
		DebugLocation(197, 1);
		} finally { DebugExitRule(GrammarFileName, "rule"); }
		return;

	}
	// $ANTLR end "rule"

	partial void EnterRule_ruleBody();
	partial void LeaveRule_ruleBody();
	// $ANTLR start "ruleBody"
	// Grammars\\AssignTokenTypesWalker.g3:199:1: ruleBody : id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* block ( exceptionGroup )? EOR ;
	[GrammarRule("ruleBody")]
	private void ruleBody()
	{
		EnterRule_ruleBody();
		EnterRule("ruleBody", 14);
		TraceIn("ruleBody", 14);
		GrammarAST id = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> modifier4 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> block5 = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "ruleBody");
		DebugLocation(199, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:200:2: (id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* block ( exceptionGroup )? EOR )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:200:4: id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* block ( exceptionGroup )? EOR
			{
			DebugLocation(200, 6);
			id=(GrammarAST)Match(input,ID,Follow._ID_in_ruleBody509); 
			DebugLocation(200, 10);
			currentRuleName=(id!=null?id.Text:default(string));
			DebugLocation(201, 3);
			// Grammars\\AssignTokenTypesWalker.g3:201:3: ( modifier )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==FRAGMENT||(LA20_1>=PRIVATE && LA20_1<=PUBLIC)))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:201:3: modifier
				{
				DebugLocation(201, 3);
				PushFollow(Follow._modifier_in_ruleBody515);
				modifier4=modifier();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(202, 3);
			DebugLocation(202, 5);
			Match(input,ARG,Follow._ARG_in_ruleBody521); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(202, 9);
				// Grammars\\AssignTokenTypesWalker.g3:202:9: ( ARG_ACTION )?
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==ARG_ACTION))
				{
					alt21 = 1;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:202:9: ARG_ACTION
					{
					DebugLocation(202, 9);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_ruleBody523); 

					}
					break;

				}
				} finally { DebugExitSubRule(21); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(203, 3);
			DebugLocation(203, 5);
			Match(input,RET,Follow._RET_in_ruleBody530); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(203, 9);
				// Grammars\\AssignTokenTypesWalker.g3:203:9: ( ARG_ACTION )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==ARG_ACTION))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:203:9: ARG_ACTION
					{
					DebugLocation(203, 9);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_ruleBody532); 

					}
					break;

				}
				} finally { DebugExitSubRule(22); }


				Match(input, TokenTypes.Up, null); 
			}

			DebugLocation(204, 3);
			// Grammars\\AssignTokenTypesWalker.g3:204:3: ( throwsSpec )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==THROWS))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:204:3: throwsSpec
				{
				DebugLocation(204, 3);
				PushFollow(Follow._throwsSpec_in_ruleBody538);
				throwsSpec();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(205, 3);
			// Grammars\\AssignTokenTypesWalker.g3:205:3: ( optionsSpec )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==OPTIONS))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:205:3: optionsSpec
				{
				DebugLocation(205, 3);
				PushFollow(Follow._optionsSpec_in_ruleBody543);
				optionsSpec();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(206, 3);
			// Grammars\\AssignTokenTypesWalker.g3:206:3: ( ruleScopeSpec )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==SCOPE))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:206:3: ruleScopeSpec
				{
				DebugLocation(206, 3);
				PushFollow(Follow._ruleScopeSpec_in_ruleBody548);
				ruleScopeSpec();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(207, 3);
			// Grammars\\AssignTokenTypesWalker.g3:207:3: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==AMPERSAND))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:207:5: ^( AMPERSAND ( . )* )
					{
					DebugLocation(207, 5);
					DebugLocation(207, 7);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleBody556); 

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); 
						DebugLocation(207, 17);
						// Grammars\\AssignTokenTypesWalker.g3:207:17: ( . )*
						try { DebugEnterSubRule(26);
						while (true)
						{
							int alt26=2;
							try { DebugEnterDecision(26, false);
							int LA26_1 = input.LA(1);

							if (((LA26_1>=ACTION && LA26_1<=CHARSET)))
							{
								alt26 = 1;
							}
							else if ((LA26_1==UP))
							{
								alt26 = 2;
							}


							} finally { DebugExitDecision(26); }
							switch ( alt26 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\AssignTokenTypesWalker.g3:207:17: .
								{
								DebugLocation(207, 17);
								MatchAny(input); 

								}
								break;

							default:
								goto loop26;
							}
						}

						loop26:
							;

						} finally { DebugExitSubRule(26); }


						Match(input, TokenTypes.Up, null); 
					}


					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }

			DebugLocation(208, 3);
			PushFollow(Follow._block_in_ruleBody567);
			block5=block();
			PopFollow();

			DebugLocation(209, 3);
			// Grammars\\AssignTokenTypesWalker.g3:209:3: ( exceptionGroup )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==CATCH||LA28_1==FINALLY))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:209:3: exceptionGroup
				{
				DebugLocation(209, 3);
				PushFollow(Follow._exceptionGroup_in_ruleBody571);
				exceptionGroup();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(28); }

			DebugLocation(210, 3);
			Match(input,EOR,Follow._EOR_in_ruleBody576); 
			DebugLocation(211, 3);
			TrackTokenRule(id,(modifier4!=null?((GrammarAST)modifier4.Start):default(GrammarAST)),(block5!=null?((GrammarAST)block5.Start):default(GrammarAST)));

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ruleBody", 14);
			LeaveRule("ruleBody", 14);
			LeaveRule_ruleBody();
		}
		DebugLocation(212, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleBody"); }
		return;

	}
	// $ANTLR end "ruleBody"

	partial void EnterRule_modifier();
	partial void LeaveRule_modifier();
	// $ANTLR start "modifier"
	// Grammars\\AssignTokenTypesWalker.g3:214:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
	[GrammarRule("modifier")]
	private TreeRuleReturnScope<GrammarAST> modifier()
	{
		EnterRule_modifier();
		EnterRule("modifier", 15);
		TraceIn("modifier", 15);
		TreeRuleReturnScope<GrammarAST> retval = new TreeRuleReturnScope<GrammarAST>();
		retval.Start = (GrammarAST)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "modifier");
		DebugLocation(214, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:215:2: ( 'protected' | 'public' | 'private' | 'fragment' )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:
			{
			DebugLocation(215, 2);
			if (input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("modifier", 15);
			LeaveRule("modifier", 15);
			LeaveRule_modifier();
		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "modifier"); }
		return retval;

	}
	// $ANTLR end "modifier"

	partial void EnterRule_throwsSpec();
	partial void LeaveRule_throwsSpec();
	// $ANTLR start "throwsSpec"
	// Grammars\\AssignTokenTypesWalker.g3:221:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
	[GrammarRule("throwsSpec")]
	private void throwsSpec()
	{
		EnterRule_throwsSpec();
		EnterRule("throwsSpec", 16);
		TraceIn("throwsSpec", 16);
		try { DebugEnterRule(GrammarFileName, "throwsSpec");
		DebugLocation(221, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:222:2: ( ^( 'throws' ( ID )+ ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:222:4: ^( 'throws' ( ID )+ )
			{
			DebugLocation(222, 4);
			DebugLocation(222, 6);
			Match(input,THROWS,Follow._THROWS_in_throwsSpec618); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(222, 15);
			// Grammars\\AssignTokenTypesWalker.g3:222:15: ( ID )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==ID))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:222:15: ID
					{
					DebugLocation(222, 15);
					Match(input,ID,Follow._ID_in_throwsSpec620); 

					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("throwsSpec", 16);
			LeaveRule("throwsSpec", 16);
			LeaveRule_throwsSpec();
		}
		DebugLocation(223, 1);
		} finally { DebugExitRule(GrammarFileName, "throwsSpec"); }
		return;

	}
	// $ANTLR end "throwsSpec"

	partial void EnterRule_ruleScopeSpec();
	partial void LeaveRule_ruleScopeSpec();
	// $ANTLR start "ruleScopeSpec"
	// Grammars\\AssignTokenTypesWalker.g3:225:1: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
	[GrammarRule("ruleScopeSpec")]
	private void ruleScopeSpec()
	{
		EnterRule_ruleScopeSpec();
		EnterRule("ruleScopeSpec", 17);
		TraceIn("ruleScopeSpec", 17);
		try { DebugEnterRule(GrammarFileName, "ruleScopeSpec");
		DebugLocation(225, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:226:2: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:226:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
			{
			DebugLocation(226, 4);
			DebugLocation(226, 6);
			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec634); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(226, 14);
				// Grammars\\AssignTokenTypesWalker.g3:226:14: ( ^( AMPERSAND ( . )* ) )*
				try { DebugEnterSubRule(31);
				while (true)
				{
					int alt31=2;
					try { DebugEnterDecision(31, false);
					int LA31_1 = input.LA(1);

					if ((LA31_1==AMPERSAND))
					{
						alt31 = 1;
					}


					} finally { DebugExitDecision(31); }
					switch ( alt31 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:226:16: ^( AMPERSAND ( . )* )
						{
						DebugLocation(226, 16);
						DebugLocation(226, 18);
						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec639); 

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); 
							DebugLocation(226, 28);
							// Grammars\\AssignTokenTypesWalker.g3:226:28: ( . )*
							try { DebugEnterSubRule(30);
							while (true)
							{
								int alt30=2;
								try { DebugEnterDecision(30, false);
								int LA30_1 = input.LA(1);

								if (((LA30_1>=ACTION && LA30_1<=CHARSET)))
								{
									alt30 = 1;
								}
								else if ((LA30_1==UP))
								{
									alt30 = 2;
								}


								} finally { DebugExitDecision(30); }
								switch ( alt30 )
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\AssignTokenTypesWalker.g3:226:28: .
									{
									DebugLocation(226, 28);
									MatchAny(input); 

									}
									break;

								default:
									goto loop30;
								}
							}

							loop30:
								;

							} finally { DebugExitSubRule(30); }


							Match(input, TokenTypes.Up, null); 
						}


						}
						break;

					default:
						goto loop31;
					}
				}

				loop31:
					;

				} finally { DebugExitSubRule(31); }

				DebugLocation(226, 35);
				// Grammars\\AssignTokenTypesWalker.g3:226:35: ( ACTION )?
				int alt32=2;
				try { DebugEnterSubRule(32);
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1==ACTION))
				{
					alt32 = 1;
				}
				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:226:35: ACTION
					{
					DebugLocation(226, 35);
					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec648); 

					}
					break;

				}
				} finally { DebugExitSubRule(32); }

				DebugLocation(226, 43);
				// Grammars\\AssignTokenTypesWalker.g3:226:43: ( ID )*
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=2;
					try { DebugEnterDecision(33, false);
					int LA33_1 = input.LA(1);

					if ((LA33_1==ID))
					{
						alt33 = 1;
					}


					} finally { DebugExitDecision(33); }
					switch ( alt33 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:226:43: ID
						{
						DebugLocation(226, 43);
						Match(input,ID,Follow._ID_in_ruleScopeSpec651); 

						}
						break;

					default:
						goto loop33;
					}
				}

				loop33:
					;

				} finally { DebugExitSubRule(33); }


				Match(input, TokenTypes.Up, null); 
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ruleScopeSpec", 17);
			LeaveRule("ruleScopeSpec", 17);
			LeaveRule_ruleScopeSpec();
		}
		DebugLocation(227, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleScopeSpec"); }
		return;

	}
	// $ANTLR end "ruleScopeSpec"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// Grammars\\AssignTokenTypesWalker.g3:229:1: block : ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) ;
	[GrammarRule("block")]
	private TreeRuleReturnScope<GrammarAST> block()
	{
		EnterRule_block();
		EnterRule("block", 18);
		TraceIn("block", 18);
		TreeRuleReturnScope<GrammarAST> retval = new TreeRuleReturnScope<GrammarAST>();
		retval.Start = (GrammarAST)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(229, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:230:2: ( ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:230:4: ^( BLOCK ( optionsSpec )? ( alternative rewrite )+ EOB )
			{
			DebugLocation(230, 4);
			DebugLocation(230, 7);
			Match(input,BLOCK,Follow._BLOCK_in_block666); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(231, 4);
			// Grammars\\AssignTokenTypesWalker.g3:231:4: ( optionsSpec )?
			int alt34=2;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1==OPTIONS))
			{
				alt34 = 1;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:231:4: optionsSpec
				{
				DebugLocation(231, 4);
				PushFollow(Follow._optionsSpec_in_block671);
				optionsSpec();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(34); }

			DebugLocation(232, 4);
			// Grammars\\AssignTokenTypesWalker.g3:232:4: ( alternative rewrite )+
			int cnt35=0;
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==ALT))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:232:5: alternative rewrite
					{
					DebugLocation(232, 5);
					PushFollow(Follow._alternative_in_block678);
					alternative();
					PopFollow();

					DebugLocation(232, 17);
					PushFollow(Follow._rewrite_in_block680);
					rewrite();
					PopFollow();


					}
					break;

				default:
					if (cnt35 >= 1)
						goto loop35;

					EarlyExitException eee35 = new EarlyExitException( 35, input );
					DebugRecognitionException(eee35);
					throw eee35;
				}
				cnt35++;
			}
			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(233, 4);
			Match(input,EOB,Follow._EOB_in_block687); 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("block", 18);
			LeaveRule("block", 18);
			LeaveRule_block();
		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();
	// $ANTLR start "alternative"
	// Grammars\\AssignTokenTypesWalker.g3:237:1: alternative : ^( ALT ( element )+ EOA ) ;
	[GrammarRule("alternative")]
	private void alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 19);
		TraceIn("alternative", 19);
		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(237, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:238:2: ( ^( ALT ( element )+ EOA ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:238:4: ^( ALT ( element )+ EOA )
			{
			DebugLocation(238, 4);
			DebugLocation(238, 6);
			Match(input,ALT,Follow._ALT_in_alternative703); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(238, 10);
			// Grammars\\AssignTokenTypesWalker.g3:238:10: ( element )+
			int cnt36=0;
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==ACTION||(LA36_1>=ASSIGN && LA36_1<=BLOCK)||(LA36_1>=CHAR_LITERAL && LA36_1<=CHAR_RANGE)||LA36_1==CLOSURE||LA36_1==DOT||LA36_1==EPSILON||LA36_1==FORCED_ACTION||LA36_1==GATED_SEMPRED||LA36_1==NOT||LA36_1==OPTIONAL||(LA36_1>=PLUS_ASSIGN && LA36_1<=POSITIVE_CLOSURE)||LA36_1==RANGE||LA36_1==ROOT||LA36_1==RULE_REF||LA36_1==SEMPRED||(LA36_1>=STRING_LITERAL && LA36_1<=SYN_SEMPRED)||LA36_1==TOKEN_REF||LA36_1==TREE_BEGIN||LA36_1==WILDCARD))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch (alt36)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:238:10: element
					{
					DebugLocation(238, 10);
					PushFollow(Follow._element_in_alternative705);
					element();
					PopFollow();


					}
					break;

				default:
					if (cnt36 >= 1)
						goto loop36;

					EarlyExitException eee36 = new EarlyExitException( 36, input );
					DebugRecognitionException(eee36);
					throw eee36;
				}
				cnt36++;
			}
			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(238, 19);
			Match(input,EOA,Follow._EOA_in_alternative708); 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("alternative", 19);
			LeaveRule("alternative", 19);
			LeaveRule_alternative();
		}
		DebugLocation(239, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_exceptionGroup();
	partial void LeaveRule_exceptionGroup();
	// $ANTLR start "exceptionGroup"
	// Grammars\\AssignTokenTypesWalker.g3:241:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
	[GrammarRule("exceptionGroup")]
	private void exceptionGroup()
	{
		EnterRule_exceptionGroup();
		EnterRule("exceptionGroup", 20);
		TraceIn("exceptionGroup", 20);
		try { DebugEnterRule(GrammarFileName, "exceptionGroup");
		DebugLocation(241, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:242:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
			int alt39=2;
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==CATCH))
			{
				alt39 = 1;
			}
			else if ((LA39_1==FINALLY))
			{
				alt39 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 39, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:242:4: ( exceptionHandler )+ ( finallyClause )?
				{
				DebugLocation(242, 4);
				// Grammars\\AssignTokenTypesWalker.g3:242:4: ( exceptionHandler )+
				int cnt37=0;
				try { DebugEnterSubRule(37);
				while (true)
				{
					int alt37=2;
					try { DebugEnterDecision(37, false);
					int LA37_1 = input.LA(1);

					if ((LA37_1==CATCH))
					{
						alt37 = 1;
					}


					} finally { DebugExitDecision(37); }
					switch (alt37)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:242:4: exceptionHandler
						{
						DebugLocation(242, 4);
						PushFollow(Follow._exceptionHandler_in_exceptionGroup720);
						exceptionHandler();
						PopFollow();


						}
						break;

					default:
						if (cnt37 >= 1)
							goto loop37;

						EarlyExitException eee37 = new EarlyExitException( 37, input );
						DebugRecognitionException(eee37);
						throw eee37;
					}
					cnt37++;
				}
				loop37:
					;

				} finally { DebugExitSubRule(37); }

				DebugLocation(242, 22);
				// Grammars\\AssignTokenTypesWalker.g3:242:22: ( finallyClause )?
				int alt38=2;
				try { DebugEnterSubRule(38);
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1==FINALLY))
				{
					alt38 = 1;
				}
				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:242:22: finallyClause
					{
					DebugLocation(242, 22);
					PushFollow(Follow._finallyClause_in_exceptionGroup723);
					finallyClause();
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(38); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:243:4: finallyClause
				{
				DebugLocation(243, 4);
				PushFollow(Follow._finallyClause_in_exceptionGroup729);
				finallyClause();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionGroup", 20);
			LeaveRule("exceptionGroup", 20);
			LeaveRule_exceptionGroup();
		}
		DebugLocation(244, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionGroup"); }
		return;

	}
	// $ANTLR end "exceptionGroup"

	partial void EnterRule_exceptionHandler();
	partial void LeaveRule_exceptionHandler();
	// $ANTLR start "exceptionHandler"
	// Grammars\\AssignTokenTypesWalker.g3:246:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
	[GrammarRule("exceptionHandler")]
	private void exceptionHandler()
	{
		EnterRule_exceptionHandler();
		EnterRule("exceptionHandler", 21);
		TraceIn("exceptionHandler", 21);
		try { DebugEnterRule(GrammarFileName, "exceptionHandler");
		DebugLocation(246, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:247:2: ( ^( 'catch' ARG_ACTION ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:247:4: ^( 'catch' ARG_ACTION ACTION )
			{
			DebugLocation(247, 4);
			DebugLocation(247, 6);
			Match(input,CATCH,Follow._CATCH_in_exceptionHandler741); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(247, 14);
			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler743); 
			DebugLocation(247, 25);
			Match(input,ACTION,Follow._ACTION_in_exceptionHandler745); 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionHandler", 21);
			LeaveRule("exceptionHandler", 21);
			LeaveRule_exceptionHandler();
		}
		DebugLocation(248, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionHandler"); }
		return;

	}
	// $ANTLR end "exceptionHandler"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// Grammars\\AssignTokenTypesWalker.g3:250:1: finallyClause : ^( 'finally' ACTION ) ;
	[GrammarRule("finallyClause")]
	private void finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 22);
		TraceIn("finallyClause", 22);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(250, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:251:2: ( ^( 'finally' ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:251:4: ^( 'finally' ACTION )
			{
			DebugLocation(251, 4);
			DebugLocation(251, 6);
			Match(input,FINALLY,Follow._FINALLY_in_finallyClause758); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(251, 16);
			Match(input,ACTION,Follow._ACTION_in_finallyClause760); 

			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("finallyClause", 22);
			LeaveRule("finallyClause", 22);
			LeaveRule_finallyClause();
		}
		DebugLocation(252, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_rewrite();
	partial void LeaveRule_rewrite();
	// $ANTLR start "rewrite"
	// Grammars\\AssignTokenTypesWalker.g3:254:1: rewrite : ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |);
	[GrammarRule("rewrite")]
	private void rewrite()
	{
		EnterRule_rewrite();
		EnterRule("rewrite", 23);
		TraceIn("rewrite", 23);
		try { DebugEnterRule(GrammarFileName, "rewrite");
		DebugLocation(254, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:255:2: ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |)
			int alt42=2;
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1==REWRITES))
			{
				alt42 = 1;
			}
			else if ((LA42_1==ALT||LA42_1==EOB))
			{
				alt42 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:255:4: ^( REWRITES ( ^( REWRITE ( . )* ) )* )
				{
				DebugLocation(255, 4);
				DebugLocation(255, 6);
				Match(input,REWRITES,Follow._REWRITES_in_rewrite773); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(255, 15);
					// Grammars\\AssignTokenTypesWalker.g3:255:15: ( ^( REWRITE ( . )* ) )*
					try { DebugEnterSubRule(41);
					while (true)
					{
						int alt41=2;
						try { DebugEnterDecision(41, false);
						int LA41_1 = input.LA(1);

						if ((LA41_1==REWRITE))
						{
							alt41 = 1;
						}


						} finally { DebugExitDecision(41); }
						switch ( alt41 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\AssignTokenTypesWalker.g3:255:17: ^( REWRITE ( . )* )
							{
							DebugLocation(255, 17);
							DebugLocation(255, 19);
							Match(input,REWRITE,Follow._REWRITE_in_rewrite778); 

							if (input.LA(1) == TokenTypes.Down)
							{
								Match(input, TokenTypes.Down, null); 
								DebugLocation(255, 27);
								// Grammars\\AssignTokenTypesWalker.g3:255:27: ( . )*
								try { DebugEnterSubRule(40);
								while (true)
								{
									int alt40=2;
									try { DebugEnterDecision(40, false);
									int LA40_1 = input.LA(1);

									if (((LA40_1>=ACTION && LA40_1<=CHARSET)))
									{
										alt40 = 1;
									}
									else if ((LA40_1==UP))
									{
										alt40 = 2;
									}


									} finally { DebugExitDecision(40); }
									switch ( alt40 )
									{
									case 1:
										DebugEnterAlt(1);
										// Grammars\\AssignTokenTypesWalker.g3:255:27: .
										{
										DebugLocation(255, 27);
										MatchAny(input); 

										}
										break;

									default:
										goto loop40;
									}
								}

								loop40:
									;

								} finally { DebugExitSubRule(40); }


								Match(input, TokenTypes.Up, null); 
							}


							}
							break;

						default:
							goto loop41;
						}
					}

					loop41:
						;

					} finally { DebugExitSubRule(41); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:257:2: 
				{
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite", 23);
			LeaveRule("rewrite", 23);
			LeaveRule_rewrite();
		}
		DebugLocation(257, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite"); }
		return;

	}
	// $ANTLR end "rewrite"

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// Grammars\\AssignTokenTypesWalker.g3:259:1: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
	[GrammarRule("element")]
	private void element()
	{
		EnterRule_element();
		EnterRule("element", 24);
		TraceIn("element", 24);
		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(259, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:260:2: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( CHAR_RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
			int alt44=18;
			try { DebugEnterDecision(44, false);
			switch (input.LA(1))
			{
			case ROOT:
				{
				alt44 = 1;
				}
				break;
			case BANG:
				{
				alt44 = 2;
				}
				break;
			case CHAR_LITERAL:
			case DOT:
			case RULE_REF:
			case STRING_LITERAL:
			case TOKEN_REF:
			case WILDCARD:
				{
				alt44 = 3;
				}
				break;
			case NOT:
				{
				alt44 = 4;
				}
				break;
			case RANGE:
				{
				alt44 = 5;
				}
				break;
			case CHAR_RANGE:
				{
				alt44 = 6;
				}
				break;
			case ASSIGN:
				{
				alt44 = 7;
				}
				break;
			case PLUS_ASSIGN:
				{
				alt44 = 8;
				}
				break;
			case BLOCK:
			case CLOSURE:
			case OPTIONAL:
			case POSITIVE_CLOSURE:
				{
				alt44 = 9;
				}
				break;
			case TREE_BEGIN:
				{
				alt44 = 10;
				}
				break;
			case SYNPRED:
				{
				alt44 = 11;
				}
				break;
			case FORCED_ACTION:
				{
				alt44 = 12;
				}
				break;
			case ACTION:
				{
				alt44 = 13;
				}
				break;
			case SEMPRED:
				{
				alt44 = 14;
				}
				break;
			case SYN_SEMPRED:
				{
				alt44 = 15;
				}
				break;
			case BACKTRACK_SEMPRED:
				{
				alt44 = 16;
				}
				break;
			case GATED_SEMPRED:
				{
				alt44 = 17;
				}
				break;
			case EPSILON:
				{
				alt44 = 18;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:260:4: ^( ROOT element )
				{
				DebugLocation(260, 4);
				DebugLocation(260, 6);
				Match(input,ROOT,Follow._ROOT_in_element802); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(260, 11);
				PushFollow(Follow._element_in_element804);
				element();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:261:4: ^( BANG element )
				{
				DebugLocation(261, 4);
				DebugLocation(261, 6);
				Match(input,BANG,Follow._BANG_in_element811); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(261, 11);
				PushFollow(Follow._element_in_element813);
				element();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\AssignTokenTypesWalker.g3:262:4: atom
				{
				DebugLocation(262, 4);
				PushFollow(Follow._atom_in_element819);
				atom();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\AssignTokenTypesWalker.g3:263:4: ^( NOT element )
				{
				DebugLocation(263, 4);
				DebugLocation(263, 6);
				Match(input,NOT,Follow._NOT_in_element825); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(263, 10);
				PushFollow(Follow._element_in_element827);
				element();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\AssignTokenTypesWalker.g3:264:4: ^( RANGE atom atom )
				{
				DebugLocation(264, 4);
				DebugLocation(264, 6);
				Match(input,RANGE,Follow._RANGE_in_element834); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(264, 12);
				PushFollow(Follow._atom_in_element836);
				atom();
				PopFollow();

				DebugLocation(264, 17);
				PushFollow(Follow._atom_in_element838);
				atom();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\AssignTokenTypesWalker.g3:265:4: ^( CHAR_RANGE atom atom )
				{
				DebugLocation(265, 4);
				DebugLocation(265, 6);
				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element845); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(265, 17);
				PushFollow(Follow._atom_in_element847);
				atom();
				PopFollow();

				DebugLocation(265, 22);
				PushFollow(Follow._atom_in_element849);
				atom();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\AssignTokenTypesWalker.g3:266:4: ^( ASSIGN ID element )
				{
				DebugLocation(266, 4);
				DebugLocation(266, 6);
				Match(input,ASSIGN,Follow._ASSIGN_in_element856); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(266, 13);
				Match(input,ID,Follow._ID_in_element858); 
				DebugLocation(266, 16);
				PushFollow(Follow._element_in_element860);
				element();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\AssignTokenTypesWalker.g3:267:4: ^( PLUS_ASSIGN ID element )
				{
				DebugLocation(267, 4);
				DebugLocation(267, 6);
				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element867); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(267, 18);
				Match(input,ID,Follow._ID_in_element869); 
				DebugLocation(267, 21);
				PushFollow(Follow._element_in_element871);
				element();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\AssignTokenTypesWalker.g3:268:4: ebnf
				{
				DebugLocation(268, 4);
				PushFollow(Follow._ebnf_in_element877);
				ebnf();
				PopFollow();


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\AssignTokenTypesWalker.g3:269:4: tree_
				{
				DebugLocation(269, 4);
				PushFollow(Follow._tree__in_element882);
				tree_();
				PopFollow();


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammars\\AssignTokenTypesWalker.g3:270:4: ^( SYNPRED block )
				{
				DebugLocation(270, 4);
				DebugLocation(270, 6);
				Match(input,SYNPRED,Follow._SYNPRED_in_element888); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(270, 14);
				PushFollow(Follow._block_in_element890);
				block();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammars\\AssignTokenTypesWalker.g3:271:4: FORCED_ACTION
				{
				DebugLocation(271, 4);
				Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element896); 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Grammars\\AssignTokenTypesWalker.g3:272:4: ACTION
				{
				DebugLocation(272, 4);
				Match(input,ACTION,Follow._ACTION_in_element901); 

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Grammars\\AssignTokenTypesWalker.g3:273:4: SEMPRED
				{
				DebugLocation(273, 4);
				Match(input,SEMPRED,Follow._SEMPRED_in_element906); 

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// Grammars\\AssignTokenTypesWalker.g3:274:4: SYN_SEMPRED
				{
				DebugLocation(274, 4);
				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element911); 

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// Grammars\\AssignTokenTypesWalker.g3:275:4: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(275, 4);
				DebugLocation(275, 6);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element917); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(275, 24);
					// Grammars\\AssignTokenTypesWalker.g3:275:24: ( . )*
					try { DebugEnterSubRule(43);
					while (true)
					{
						int alt43=2;
						try { DebugEnterDecision(43, false);
						int LA43_1 = input.LA(1);

						if (((LA43_1>=ACTION && LA43_1<=CHARSET)))
						{
							alt43 = 1;
						}
						else if ((LA43_1==UP))
						{
							alt43 = 2;
						}


						} finally { DebugExitDecision(43); }
						switch ( alt43 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\AssignTokenTypesWalker.g3:275:24: .
							{
							DebugLocation(275, 24);
							MatchAny(input); 

							}
							break;

						default:
							goto loop43;
						}
					}

					loop43:
						;

					} finally { DebugExitSubRule(43); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;
			case 17:
				DebugEnterAlt(17);
				// Grammars\\AssignTokenTypesWalker.g3:276:4: GATED_SEMPRED
				{
				DebugLocation(276, 4);
				Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element926); 

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// Grammars\\AssignTokenTypesWalker.g3:277:4: EPSILON
				{
				DebugLocation(277, 4);
				Match(input,EPSILON,Follow._EPSILON_in_element931); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("element", 24);
			LeaveRule("element", 24);
			LeaveRule_element();
		}
		DebugLocation(278, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return;

	}
	// $ANTLR end "element"

	partial void EnterRule_ebnf();
	partial void LeaveRule_ebnf();
	// $ANTLR start "ebnf"
	// Grammars\\AssignTokenTypesWalker.g3:280:1: ebnf : ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
	[GrammarRule("ebnf")]
	private void ebnf()
	{
		EnterRule_ebnf();
		EnterRule("ebnf", 25);
		TraceIn("ebnf", 25);
		try { DebugEnterRule(GrammarFileName, "ebnf");
		DebugLocation(280, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:281:2: ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
			int alt45=4;
			try { DebugEnterDecision(45, false);
			switch (input.LA(1))
			{
			case BLOCK:
				{
				alt45 = 1;
				}
				break;
			case OPTIONAL:
				{
				alt45 = 2;
				}
				break;
			case CLOSURE:
				{
				alt45 = 3;
				}
				break;
			case POSITIVE_CLOSURE:
				{
				alt45 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:281:4: block
				{
				DebugLocation(281, 4);
				PushFollow(Follow._block_in_ebnf942);
				block();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:282:4: ^( OPTIONAL block )
				{
				DebugLocation(282, 4);
				DebugLocation(282, 6);
				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf948); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(282, 15);
				PushFollow(Follow._block_in_ebnf950);
				block();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\AssignTokenTypesWalker.g3:283:4: ^( CLOSURE block )
				{
				DebugLocation(283, 4);
				DebugLocation(283, 6);
				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf957); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(283, 14);
				PushFollow(Follow._block_in_ebnf959);
				block();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\AssignTokenTypesWalker.g3:284:4: ^( POSITIVE_CLOSURE block )
				{
				DebugLocation(284, 4);
				DebugLocation(284, 6);
				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf966); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(284, 23);
				PushFollow(Follow._block_in_ebnf968);
				block();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ebnf", 25);
			LeaveRule("ebnf", 25);
			LeaveRule_ebnf();
		}
		DebugLocation(285, 1);
		} finally { DebugExitRule(GrammarFileName, "ebnf"); }
		return;

	}
	// $ANTLR end "ebnf"

	partial void EnterRule_tree_();
	partial void LeaveRule_tree_();
	// $ANTLR start "tree_"
	// Grammars\\AssignTokenTypesWalker.g3:287:1: tree_ : ^( TREE_BEGIN ( element )+ ) ;
	[GrammarRule("tree_")]
	private void tree_()
	{
		EnterRule_tree_();
		EnterRule("tree_", 26);
		TraceIn("tree_", 26);
		try { DebugEnterRule(GrammarFileName, "tree_");
		DebugLocation(287, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:288:2: ( ^( TREE_BEGIN ( element )+ ) )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:288:4: ^( TREE_BEGIN ( element )+ )
			{
			DebugLocation(288, 4);
			DebugLocation(288, 6);
			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_981); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(288, 17);
			// Grammars\\AssignTokenTypesWalker.g3:288:17: ( element )+
			int cnt46=0;
			try { DebugEnterSubRule(46);
			while (true)
			{
				int alt46=2;
				try { DebugEnterDecision(46, false);
				int LA46_1 = input.LA(1);

				if ((LA46_1==ACTION||(LA46_1>=ASSIGN && LA46_1<=BLOCK)||(LA46_1>=CHAR_LITERAL && LA46_1<=CHAR_RANGE)||LA46_1==CLOSURE||LA46_1==DOT||LA46_1==EPSILON||LA46_1==FORCED_ACTION||LA46_1==GATED_SEMPRED||LA46_1==NOT||LA46_1==OPTIONAL||(LA46_1>=PLUS_ASSIGN && LA46_1<=POSITIVE_CLOSURE)||LA46_1==RANGE||LA46_1==ROOT||LA46_1==RULE_REF||LA46_1==SEMPRED||(LA46_1>=STRING_LITERAL && LA46_1<=SYN_SEMPRED)||LA46_1==TOKEN_REF||LA46_1==TREE_BEGIN||LA46_1==WILDCARD))
				{
					alt46 = 1;
				}


				} finally { DebugExitDecision(46); }
				switch (alt46)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\AssignTokenTypesWalker.g3:288:17: element
					{
					DebugLocation(288, 17);
					PushFollow(Follow._element_in_tree_983);
					element();
					PopFollow();


					}
					break;

				default:
					if (cnt46 >= 1)
						goto loop46;

					EarlyExitException eee46 = new EarlyExitException( 46, input );
					DebugRecognitionException(eee46);
					throw eee46;
				}
				cnt46++;
			}
			loop46:
				;

			} finally { DebugExitSubRule(46); }


			Match(input, TokenTypes.Up, null); 


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tree_", 26);
			LeaveRule("tree_", 26);
			LeaveRule_tree_();
		}
		DebugLocation(289, 1);
		} finally { DebugExitRule(GrammarFileName, "tree_"); }
		return;

	}
	// $ANTLR end "tree_"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\AssignTokenTypesWalker.g3:291:1: atom : ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |t= CHAR_LITERAL |t= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) );
	[GrammarRule("atom")]
	private void atom()
	{
		EnterRule_atom();
		EnterRule("atom", 27);
		TraceIn("atom", 27);
		GrammarAST t = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(291, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:292:2: ( ^( RULE_REF ( ARG_ACTION )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ) |t= CHAR_LITERAL |t= STRING_LITERAL | WILDCARD | ^( DOT ID atom ) )
			int alt49=6;
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case RULE_REF:
				{
				alt49 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt49 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt49 = 3;
				}
				break;
			case STRING_LITERAL:
				{
				alt49 = 4;
				}
				break;
			case WILDCARD:
				{
				alt49 = 5;
				}
				break;
			case DOT:
				{
				alt49 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\AssignTokenTypesWalker.g3:292:4: ^( RULE_REF ( ARG_ACTION )? )
				{
				DebugLocation(292, 4);
				DebugLocation(292, 6);
				Match(input,RULE_REF,Follow._RULE_REF_in_atom997); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(292, 15);
					// Grammars\\AssignTokenTypesWalker.g3:292:15: ( ARG_ACTION )?
					int alt47=2;
					try { DebugEnterSubRule(47);
					try { DebugEnterDecision(47, false);
					int LA47_1 = input.LA(1);

					if ((LA47_1==ARG_ACTION))
					{
						alt47 = 1;
					}
					} finally { DebugExitDecision(47); }
					switch (alt47)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:292:15: ARG_ACTION
						{
						DebugLocation(292, 15);
						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom999); 

						}
						break;

					}
					} finally { DebugExitSubRule(47); }


					Match(input, TokenTypes.Up, null); 
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\AssignTokenTypesWalker.g3:293:4: ^(t= TOKEN_REF ( ARG_ACTION )? )
				{
				DebugLocation(293, 4);
				DebugLocation(293, 7);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1009); 

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); 
					DebugLocation(293, 18);
					// Grammars\\AssignTokenTypesWalker.g3:293:18: ( ARG_ACTION )?
					int alt48=2;
					try { DebugEnterSubRule(48);
					try { DebugEnterDecision(48, false);
					int LA48_1 = input.LA(1);

					if ((LA48_1==ARG_ACTION))
					{
						alt48 = 1;
					}
					} finally { DebugExitDecision(48); }
					switch (alt48)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\AssignTokenTypesWalker.g3:293:18: ARG_ACTION
						{
						DebugLocation(293, 18);
						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1011); 

						}
						break;

					}
					} finally { DebugExitSubRule(48); }


					Match(input, TokenTypes.Up, null); 
				}

				DebugLocation(293, 31);
				TrackToken(t);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\AssignTokenTypesWalker.g3:294:4: t= CHAR_LITERAL
				{
				DebugLocation(294, 5);
				t=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1022); 
				DebugLocation(294, 22);
				TrackString(t);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\AssignTokenTypesWalker.g3:295:4: t= STRING_LITERAL
				{
				DebugLocation(295, 5);
				t=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1034); 
				DebugLocation(295, 23);
				TrackString(t);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\AssignTokenTypesWalker.g3:296:4: WILDCARD
				{
				DebugLocation(296, 4);
				Match(input,WILDCARD,Follow._WILDCARD_in_atom1043); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\AssignTokenTypesWalker.g3:297:4: ^( DOT ID atom )
				{
				DebugLocation(297, 4);
				DebugLocation(297, 6);
				Match(input,DOT,Follow._DOT_in_atom1049); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(297, 10);
				Match(input,ID,Follow._ID_in_atom1051); 
				DebugLocation(297, 13);
				PushFollow(Follow._atom_in_atom1053);
				atom();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 27);
			LeaveRule("atom", 27);
			LeaveRule_atom();
		}
		DebugLocation(298, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return;

	}
	// $ANTLR end "atom"

	partial void EnterRule_ast_suffix();
	partial void LeaveRule_ast_suffix();
	// $ANTLR start "ast_suffix"
	// Grammars\\AssignTokenTypesWalker.g3:300:1: ast_suffix : ( ROOT | BANG );
	[GrammarRule("ast_suffix")]
	private void ast_suffix()
	{
		EnterRule_ast_suffix();
		EnterRule("ast_suffix", 28);
		TraceIn("ast_suffix", 28);
		try { DebugEnterRule(GrammarFileName, "ast_suffix");
		DebugLocation(300, 1);
		try
		{
			// Grammars\\AssignTokenTypesWalker.g3:301:2: ( ROOT | BANG )
			DebugEnterAlt(1);
			// Grammars\\AssignTokenTypesWalker.g3:
			{
			DebugLocation(301, 2);
			if (input.LA(1)==BANG||input.LA(1)==ROOT)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ast_suffix", 28);
			LeaveRule("ast_suffix", 28);
			LeaveRule_ast_suffix();
		}
		DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "ast_suffix"); }
		return;

	}
	// $ANTLR end "ast_suffix"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_67 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_72 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_80 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_84 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_GRAMMAR_in_grammar_92 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_98 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_106 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_108 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_grammarSpec124 = new BitSet(new ulong[]{0x400200008000200UL,0x20028002UL});
		public static readonly BitSet _DOC_COMMENT_in_grammarSpec128 = new BitSet(new ulong[]{0x400200000000200UL,0x20028002UL});
		public static readonly BitSet _optionsSpec_in_grammarSpec133 = new BitSet(new ulong[]{0x200000000200UL,0x20028002UL});
		public static readonly BitSet _delegateGrammars_in_grammarSpec138 = new BitSet(new ulong[]{0x200UL,0x20028002UL});
		public static readonly BitSet _tokensSpec_in_grammarSpec143 = new BitSet(new ulong[]{0x200UL,0x28002UL});
		public static readonly BitSet _attrScope_in_grammarSpec148 = new BitSet(new ulong[]{0x200UL,0x28002UL});
		public static readonly BitSet _AMPERSAND_in_grammarSpec156 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rules_in_grammarSpec168 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SCOPE_in_attrScope180 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_attrScope182 = new BitSet(new ulong[]{0x210UL});
		public static readonly BitSet _AMPERSAND_in_attrScope187 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_attrScope196 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _OPTIONS_in_optionsSpec213 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _option_in_optionsSpec216 = new BitSet(new ulong[]{0x2008UL});
		public static readonly BitSet _ASSIGN_in_option233 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_option235 = new BitSet(new ulong[]{0x880000040000UL,0x1000000UL});
		public static readonly BitSet _optionValue_in_option237 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_optionValue262 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_optionValue267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_optionValue272 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_optionValue277 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHARSET_in_charSet295 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _charSetElement_in_charSet297 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement309 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OR_in_charSetElement315 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement317 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement319 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RANGE_in_charSetElement326 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement328 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement330 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IMPORT_in_delegateGrammars344 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ASSIGN_in_delegateGrammars352 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_delegateGrammars354 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_delegateGrammars356 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_delegateGrammars364 = new BitSet(new ulong[]{0x80000002008UL});
		public static readonly BitSet _TOKENS_in_tokensSpec386 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _tokenSpec_in_tokensSpec388 = new BitSet(new ulong[]{0x2008UL,0x40000000UL});
		public static readonly BitSet _TOKEN_REF_in_tokenSpec403 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_tokenSpec416 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TOKEN_REF_in_tokenSpec423 = new BitSet(new ulong[]{0x40000UL,0x1000000UL});
		public static readonly BitSet _STRING_LITERAL_in_tokenSpec437 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_tokenSpec448 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _rule_in_rules471 = new BitSet(new ulong[]{0x2UL,0x8002UL});
		public static readonly BitSet _RULE_in_rule484 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleBody_in_rule486 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PREC_RULE_in_rule493 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleBody_in_rule495 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_ruleBody509 = new BitSet(new ulong[]{0x10000000400UL,0x1CUL});
		public static readonly BitSet _modifier_in_ruleBody515 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ARG_in_ruleBody521 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_ruleBody523 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RET_in_ruleBody530 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_ruleBody532 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _throwsSpec_in_ruleBody538 = new BitSet(new ulong[]{0x400000000010200UL,0x20000UL});
		public static readonly BitSet _optionsSpec_in_ruleBody543 = new BitSet(new ulong[]{0x10200UL,0x20000UL});
		public static readonly BitSet _ruleScopeSpec_in_ruleBody548 = new BitSet(new ulong[]{0x10200UL});
		public static readonly BitSet _AMPERSAND_in_ruleBody556 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ruleBody567 = new BitSet(new ulong[]{0x4400020000UL});
		public static readonly BitSet _exceptionGroup_in_ruleBody571 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _EOR_in_ruleBody576 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THROWS_in_throwsSpec618 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_throwsSpec620 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _SCOPE_in_ruleScopeSpec634 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec639 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_ruleScopeSpec648 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _ID_in_ruleScopeSpec651 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _BLOCK_in_block666 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _optionsSpec_in_block671 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _alternative_in_block678 = new BitSet(new ulong[]{0x200000100UL,0x1000UL});
		public static readonly BitSet _rewrite_in_block680 = new BitSet(new ulong[]{0x200000100UL});
		public static readonly BitSet _EOB_in_block687 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_alternative703 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_alternative705 = new BitSet(new ulong[]{0x82800289202DE010UL,0x547092041UL});
		public static readonly BitSet _EOA_in_alternative708 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _exceptionHandler_in_exceptionGroup720 = new BitSet(new ulong[]{0x4000020002UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup723 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup729 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_exceptionHandler741 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_exceptionHandler743 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_exceptionHandler745 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FINALLY_in_finallyClause758 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_finallyClause760 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _REWRITES_in_rewrite773 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _REWRITE_in_rewrite778 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ROOT_in_element802 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element804 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BANG_in_element811 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element813 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _atom_in_element819 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_element825 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element827 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RANGE_in_element834 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _atom_in_element836 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_element838 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_RANGE_in_element845 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _atom_in_element847 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_element849 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_element856 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element858 = new BitSet(new ulong[]{0x82800288202DE010UL,0x547092041UL});
		public static readonly BitSet _element_in_element860 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PLUS_ASSIGN_in_element867 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element869 = new BitSet(new ulong[]{0x82800288202DE010UL,0x547092041UL});
		public static readonly BitSet _element_in_element871 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ebnf_in_element877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tree__in_element882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYNPRED_in_element888 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_element890 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FORCED_ACTION_in_element896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_element901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMPRED_in_element906 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYN_SEMPRED_in_element911 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_element917 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _GATED_SEMPRED_in_element926 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EPSILON_in_element931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_ebnf942 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPTIONAL_in_ebnf948 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf950 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CLOSURE_in_ebnf957 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf959 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf966 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf968 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_BEGIN_in_tree_981 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_tree_983 = new BitSet(new ulong[]{0x82800288202DE018UL,0x547092041UL});
		public static readonly BitSet _RULE_REF_in_atom997 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom999 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TOKEN_REF_in_atom1009 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1011 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_atom1022 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_atom1034 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WILDCARD_in_atom1043 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_atom1049 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_atom1051 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_atom1053 = new BitSet(new ulong[]{0x8UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.Grammars
