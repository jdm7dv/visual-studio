//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\ANTLR.g3 2013-06-14 09:39:33

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using ErrorManager = Antlr3.Tool.ErrorManager;
using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
using GrammarType = Antlr3.Tool.GrammarType;
using IntSet = Antlr3.Misc.IIntSet;
using Rule = Antlr3.Tool.Rule;
using RuleType = Antlr3.Tool.RuleType;
using StringBuffer = System.Text.StringBuilder;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Antlr3.Grammars
{
/** Read in an ANTLR grammar and build an AST.  Try not to do
 *  any actions, just build the tree.
 *
 *  The phases are:
 *
 *		antlr.g (this file)
 *		assign.types.g
 *		define.g
 *		buildnfa.g
 *		antlr.print.g (optional)
 *		codegen.g
 *
 *  Terence Parr
 *  University of San Francisco
 *  2005
 */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ANTLRParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", "ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", "TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
	};
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ACTION_CHAR_LITERAL=5;
	public const int ACTION_ESC=6;
	public const int ACTION_STRING_LITERAL=7;
	public const int ALT=8;
	public const int AMPERSAND=9;
	public const int ARG=10;
	public const int ARGLIST=11;
	public const int ARG_ACTION=12;
	public const int ASSIGN=13;
	public const int BACKTRACK_SEMPRED=14;
	public const int BANG=15;
	public const int BLOCK=16;
	public const int CATCH=17;
	public const int CHAR_LITERAL=18;
	public const int CHAR_RANGE=19;
	public const int CLOSE_ELEMENT_OPTION=20;
	public const int CLOSURE=21;
	public const int COLON=22;
	public const int COMBINED_GRAMMAR=23;
	public const int COMMA=24;
	public const int COMMENT=25;
	public const int DIGIT=26;
	public const int DOC_COMMENT=27;
	public const int DOLLAR=28;
	public const int DOT=29;
	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
	public const int EOA=32;
	public const int EOB=33;
	public const int EOR=34;
	public const int EPSILON=35;
	public const int ESC=36;
	public const int ETC=37;
	public const int FINALLY=38;
	public const int FORCED_ACTION=39;
	public const int FRAGMENT=40;
	public const int GATED_SEMPRED=41;
	public const int GRAMMAR=42;
	public const int ID=43;
	public const int IMPLIES=44;
	public const int IMPORT=45;
	public const int INITACTION=46;
	public const int INT=47;
	public const int LABEL=48;
	public const int LEXER=49;
	public const int LEXER_GRAMMAR=50;
	public const int LPAREN=51;
	public const int ML_COMMENT=52;
	public const int NESTED_ACTION=53;
	public const int NESTED_ARG_ACTION=54;
	public const int NOT=55;
	public const int OPEN_ELEMENT_OPTION=56;
	public const int OPTIONAL=57;
	public const int OPTIONS=58;
	public const int OR=59;
	public const int PARSER=60;
	public const int PARSER_GRAMMAR=61;
	public const int PLUS=62;
	public const int PLUS_ASSIGN=63;
	public const int POSITIVE_CLOSURE=64;
	public const int PREC_RULE=65;
	public const int PRIVATE=66;
	public const int PROTECTED=67;
	public const int PUBLIC=68;
	public const int QUESTION=69;
	public const int RANGE=70;
	public const int RCURLY=71;
	public const int RECURSIVE_RULE_REF=72;
	public const int RET=73;
	public const int RETURNS=74;
	public const int REWRITE=75;
	public const int REWRITES=76;
	public const int ROOT=77;
	public const int RPAREN=78;
	public const int RULE=79;
	public const int RULE_REF=80;
	public const int SCOPE=81;
	public const int SEMI=82;
	public const int SEMPRED=83;
	public const int SL_COMMENT=84;
	public const int SRC=85;
	public const int STAR=86;
	public const int STRAY_BRACKET=87;
	public const int STRING_LITERAL=88;
	public const int SYNPRED=89;
	public const int SYN_SEMPRED=90;
	public const int TEMPLATE=91;
	public const int THROWS=92;
	public const int TOKENS=93;
	public const int TOKEN_REF=94;
	public const int TREE=95;
	public const int TREE_BEGIN=96;
	public const int TREE_GRAMMAR=97;
	public const int WILDCARD=98;
	public const int WS=99;
	public const int WS_LOOP=100;
	public const int WS_OPT=101;
	public const int XDIGIT=102;

	public ANTLRParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ANTLRParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return ANTLRParser.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\ANTLR.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_grammar_();
	partial void LeaveRule_grammar_();
	// $ANTLR start "grammar_"
	// Grammars\\ANTLR.g3:133:1: public grammar_[Grammar g] : ( ACTION )? ( DOC_COMMENT )? grammarType id SEMI ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? attrScopes ( actions )? rules EOF -> ^( grammarType id ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScopes )? ( actions )? rules ) ;
	[GrammarRule("grammar_")]
	public AstParserRuleReturnScope<GrammarAST, IToken> grammar_(Grammar g)
	{
		EnterRule_grammar_();
		EnterRule("grammar_", 1);
		TraceIn("grammar_", 1);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ACTION1 = default(IToken);
		IToken DOC_COMMENT2 = default(IToken);
		IToken SEMI5 = default(IToken);
		IToken EOF12 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> grammarType3 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> id4 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> optionsSpec6 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> delegateGrammars7 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> tokensSpec8 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> attrScopes9 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> actions10 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rules11 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ACTION1_tree = default(GrammarAST);
		GrammarAST DOC_COMMENT2_tree = default(GrammarAST);
		GrammarAST SEMI5_tree = default(GrammarAST);
		GrammarAST EOF12_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
		RewriteRuleITokenStream stream_DOC_COMMENT=new RewriteRuleITokenStream(adaptor,"token DOC_COMMENT");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_grammarType=new RewriteRuleSubtreeStream(adaptor,"rule grammarType");
		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
		RewriteRuleSubtreeStream stream_delegateGrammars=new RewriteRuleSubtreeStream(adaptor,"rule delegateGrammars");
		RewriteRuleSubtreeStream stream_tokensSpec=new RewriteRuleSubtreeStream(adaptor,"rule tokensSpec");
		RewriteRuleSubtreeStream stream_attrScopes=new RewriteRuleSubtreeStream(adaptor,"rule attrScopes");
		RewriteRuleSubtreeStream stream_actions=new RewriteRuleSubtreeStream(adaptor,"rule actions");
		RewriteRuleSubtreeStream stream_rules=new RewriteRuleSubtreeStream(adaptor,"rule rules");

			this.Grammar = g;
			IDictionary<string, object> opts;

		try { DebugEnterRule(GrammarFileName, "grammar_");
		DebugLocation(133, 1);
		try
		{
			// Grammars\\ANTLR.g3:143:2: ( ( ACTION )? ( DOC_COMMENT )? grammarType id SEMI ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? attrScopes ( actions )? rules EOF -> ^( grammarType id ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScopes )? ( actions )? rules ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:144:3: ( ACTION )? ( DOC_COMMENT )? grammarType id SEMI ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? attrScopes ( actions )? rules EOF
			{
			DebugLocation(144, 3);
			// Grammars\\ANTLR.g3:144:3: ( ACTION )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==ACTION))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:144:3: ACTION
				{
				DebugLocation(144, 3);
				ACTION1=(IToken)Match(input,ACTION,Follow._ACTION_in_grammar_319); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ACTION.Add(ACTION1);


				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(145, 3);
			// Grammars\\ANTLR.g3:145:3: ( DOC_COMMENT )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==DOC_COMMENT))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:145:3: DOC_COMMENT
				{
				DebugLocation(145, 3);
				DOC_COMMENT2=(IToken)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammar_324); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOC_COMMENT.Add(DOC_COMMENT2);


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(146, 3);
			PushFollow(Follow._grammarType_in_grammar_329);
			grammarType3=grammarType();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_grammarType.Add(grammarType3.Tree);
			DebugLocation(146, 15);
			PushFollow(Follow._id_in_grammar_331);
			id4=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_id.Add(id4.Tree);
			DebugLocation(146, 18);
			if (state.backtracking == 0)
			{
				Grammar.SetName((id4!=null?input.ToString(id4.Start,id4.Stop):default(string)));
			}
			DebugLocation(146, 47);
			SEMI5=(IToken)Match(input,SEMI,Follow._SEMI_in_grammar_335); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI5);

			DebugLocation(147, 3);
			// Grammars\\ANTLR.g3:147:3: ( optionsSpec )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==OPTIONS))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:147:5: optionsSpec
				{
				DebugLocation(147, 5);
				PushFollow(Follow._optionsSpec_in_grammar_341);
				optionsSpec6=optionsSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_optionsSpec.Add(optionsSpec6.Tree);
				DebugLocation(147, 17);
				if (state.backtracking == 0)
				{
					opts = (optionsSpec6!=null?((ANTLRParser.optionsSpec_return)optionsSpec6).opts:default(IDictionary<string, object>)); Grammar.SetOptions(opts, (optionsSpec6!=null?((IToken)optionsSpec6.Start):default(IToken)));
				}

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(149, 3);
			// Grammars\\ANTLR.g3:149:3: ( delegateGrammars )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==IMPORT))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:149:3: delegateGrammars
				{
				DebugLocation(149, 3);
				PushFollow(Follow._delegateGrammars_in_grammar_352);
				delegateGrammars7=delegateGrammars();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_delegateGrammars.Add(delegateGrammars7.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(150, 3);
			// Grammars\\ANTLR.g3:150:3: ( tokensSpec )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==TOKENS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:150:3: tokensSpec
				{
				DebugLocation(150, 3);
				PushFollow(Follow._tokensSpec_in_grammar_357);
				tokensSpec8=tokensSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_tokensSpec.Add(tokensSpec8.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(151, 3);
			PushFollow(Follow._attrScopes_in_grammar_362);
			attrScopes9=attrScopes();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_attrScopes.Add(attrScopes9.Tree);
			DebugLocation(152, 3);
			// Grammars\\ANTLR.g3:152:3: ( actions )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==AMPERSAND))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:152:3: actions
				{
				DebugLocation(152, 3);
				PushFollow(Follow._actions_in_grammar_366);
				actions10=actions();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_actions.Add(actions10.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(153, 3);
			PushFollow(Follow._rules_in_grammar_371);
			rules11=rules();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rules.Add(rules11.Tree);
			DebugLocation(154, 3);
			EOF12=(IToken)Match(input,EOF,Follow._EOF_in_grammar_375); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF12);



			{
			// AST REWRITE
			// elements: grammarType, id, DOC_COMMENT, optionsSpec, delegateGrammars, tokensSpec, attrScopes, actions, rules
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 155:3: -> ^( grammarType id ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScopes )? ( actions )? rules )
			{
				DebugLocation(155, 6);
				// Grammars\\ANTLR.g3:155:6: ^( grammarType id ( DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScopes )? ( actions )? rules )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(155, 8);
				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_grammarType.NextNode(), root_1);

				DebugLocation(155, 20);
				adaptor.AddChild(root_1, stream_id.NextTree());
				DebugLocation(155, 23);
				// Grammars\\ANTLR.g3:155:23: ( DOC_COMMENT )?
				if (stream_DOC_COMMENT.HasNext)
				{
					DebugLocation(155, 23);
					adaptor.AddChild(root_1, stream_DOC_COMMENT.NextNode());

				}
				stream_DOC_COMMENT.Reset();
				DebugLocation(155, 36);
				// Grammars\\ANTLR.g3:155:36: ( optionsSpec )?
				if (stream_optionsSpec.HasNext)
				{
					DebugLocation(155, 36);
					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());

				}
				stream_optionsSpec.Reset();
				DebugLocation(155, 49);
				// Grammars\\ANTLR.g3:155:49: ( delegateGrammars )?
				if (stream_delegateGrammars.HasNext)
				{
					DebugLocation(155, 49);
					adaptor.AddChild(root_1, stream_delegateGrammars.NextTree());

				}
				stream_delegateGrammars.Reset();
				DebugLocation(155, 67);
				// Grammars\\ANTLR.g3:155:67: ( tokensSpec )?
				if (stream_tokensSpec.HasNext)
				{
					DebugLocation(155, 67);
					adaptor.AddChild(root_1, stream_tokensSpec.NextTree());

				}
				stream_tokensSpec.Reset();
				DebugLocation(155, 79);
				// Grammars\\ANTLR.g3:155:79: ( attrScopes )?
				if (stream_attrScopes.HasNext)
				{
					DebugLocation(155, 79);
					adaptor.AddChild(root_1, stream_attrScopes.NextTree());

				}
				stream_attrScopes.Reset();
				DebugLocation(155, 91);
				// Grammars\\ANTLR.g3:155:91: ( actions )?
				if (stream_actions.HasNext)
				{
					DebugLocation(155, 91);
					adaptor.AddChild(root_1, stream_actions.NextTree());

				}
				stream_actions.Reset();
				DebugLocation(155, 100);
				adaptor.AddChild(root_1, stream_rules.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{

					Cleanup( retval.Tree );

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("grammar_", 1);
			LeaveRule("grammar_", 1);
			LeaveRule_grammar_();
		}
		DebugLocation(156, 1);
		} finally { DebugExitRule(GrammarFileName, "grammar_"); }
		return retval;

	}
	// $ANTLR end "grammar_"

	partial void EnterRule_grammarType();
	partial void LeaveRule_grammarType();
	// $ANTLR start "grammarType"
	// Grammars\\ANTLR.g3:158:1: grammarType : ( 'lexer' ! 'grammar' | 'parser' ! 'grammar' | 'tree' ! 'grammar' | 'grammar' );
	[GrammarRule("grammarType")]
	private AstParserRuleReturnScope<GrammarAST, IToken> grammarType()
	{
		EnterRule_grammarType();
		EnterRule("grammarType", 2);
		TraceIn("grammarType", 2);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal13 = default(IToken);
		IToken string_literal14 = default(IToken);
		IToken string_literal15 = default(IToken);
		IToken string_literal16 = default(IToken);
		IToken string_literal17 = default(IToken);
		IToken string_literal18 = default(IToken);
		IToken string_literal19 = default(IToken);

		GrammarAST string_literal13_tree = default(GrammarAST);
		GrammarAST string_literal14_tree = default(GrammarAST);
		GrammarAST string_literal15_tree = default(GrammarAST);
		GrammarAST string_literal16_tree = default(GrammarAST);
		GrammarAST string_literal17_tree = default(GrammarAST);
		GrammarAST string_literal18_tree = default(GrammarAST);
		GrammarAST string_literal19_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "grammarType");
		DebugLocation(158, 1);
		try
		{
			// Grammars\\ANTLR.g3:159:2: ( 'lexer' ! 'grammar' | 'parser' ! 'grammar' | 'tree' ! 'grammar' | 'grammar' )
			int alt7=4;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case LEXER:
				{
				alt7 = 1;
				}
				break;
			case PARSER:
				{
				alt7 = 2;
				}
				break;
			case TREE:
				{
				alt7 = 3;
				}
				break;
			case GRAMMAR:
				{
				alt7 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:159:4: 'lexer' ! 'grammar'
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(159, 11);
				string_literal13=(IToken)Match(input,LEXER,Follow._LEXER_in_grammarType416); if (state.failed) return retval;
				DebugLocation(159, 14);
				string_literal14=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType420); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal14_tree = (GrammarAST)adaptor.Create(LEXER_GRAMMAR,string_literal14);
				adaptor.AddChild(root_0, string_literal14_tree);
				}
				DebugLocation(159, 39);
				if (state.backtracking == 0)
				{
					GrammarType=GrammarType.Lexer; Grammar.type = GrammarType.Lexer;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:160:4: 'parser' ! 'grammar'
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(160, 12);
				string_literal15=(IToken)Match(input,PARSER,Follow._PARSER_in_grammarType437); if (state.failed) return retval;
				DebugLocation(160, 14);
				string_literal16=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType440); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal16_tree = (GrammarAST)adaptor.Create(PARSER_GRAMMAR,string_literal16);
				adaptor.AddChild(root_0, string_literal16_tree);
				}
				DebugLocation(160, 40);
				if (state.backtracking == 0)
				{
					GrammarType=GrammarType.Parser; Grammar.type = GrammarType.Parser;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:161:4: 'tree' ! 'grammar'
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(161, 10);
				string_literal17=(IToken)Match(input,TREE,Follow._TREE_in_grammarType455); if (state.failed) return retval;
				DebugLocation(161, 14);
				string_literal18=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType460); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal18_tree = (GrammarAST)adaptor.Create(TREE_GRAMMAR,string_literal18);
				adaptor.AddChild(root_0, string_literal18_tree);
				}
				DebugLocation(161, 38);
				if (state.backtracking == 0)
				{
					GrammarType=GrammarType.TreeParser; Grammar.type = GrammarType.TreeParser;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:162:8: 'grammar'
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(162, 8);
				string_literal19=(IToken)Match(input,GRAMMAR,Follow._GRAMMAR_in_grammarType476); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal19_tree = (GrammarAST)adaptor.Create(COMBINED_GRAMMAR,string_literal19);
				adaptor.AddChild(root_0, string_literal19_tree);
				}
				DebugLocation(162, 36);
				if (state.backtracking == 0)
				{
					GrammarType=GrammarType.Combined; Grammar.type = GrammarType.Combined;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("grammarType", 2);
			LeaveRule("grammarType", 2);
			LeaveRule_grammarType();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "grammarType"); }
		return retval;

	}
	// $ANTLR end "grammarType"

	partial void EnterRule_actions();
	partial void LeaveRule_actions();
	// $ANTLR start "actions"
	// Grammars\\ANTLR.g3:166:1: actions : ( action )+ ;
	[GrammarRule("actions")]
	private AstParserRuleReturnScope<GrammarAST, IToken> actions()
	{
		EnterRule_actions();
		EnterRule("actions", 3);
		TraceIn("actions", 3);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> action20 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "actions");
		DebugLocation(166, 1);
		try
		{
			// Grammars\\ANTLR.g3:167:2: ( ( action )+ )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:167:4: ( action )+
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(167, 4);
			// Grammars\\ANTLR.g3:167:4: ( action )+
			int cnt8=0;
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==AMPERSAND))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:167:4: action
					{
					DebugLocation(167, 4);
					PushFollow(Follow._action_in_actions494);
					action20=action();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, action20.Tree);

					}
					break;

				default:
					if (cnt8 >= 1)
						goto loop8;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee8 = new EarlyExitException( 8, input );
					DebugRecognitionException(eee8);
					throw eee8;
				}
				cnt8++;
			}
			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("actions", 3);
			LeaveRule("actions", 3);
			LeaveRule_actions();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "actions"); }
		return retval;

	}
	// $ANTLR end "actions"

	partial void EnterRule_action();
	partial void LeaveRule_action();
	// $ANTLR start "action"
	// Grammars\\ANTLR.g3:171:1: action : AMPERSAND ^ ( actionScopeName COLON ! COLON !)? id ACTION ;
	[GrammarRule("action")]
	private AstParserRuleReturnScope<GrammarAST, IToken> action()
	{
		EnterRule_action();
		EnterRule("action", 4);
		TraceIn("action", 4);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken AMPERSAND21 = default(IToken);
		IToken COLON23 = default(IToken);
		IToken COLON24 = default(IToken);
		IToken ACTION26 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> actionScopeName22 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> id25 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST AMPERSAND21_tree = default(GrammarAST);
		GrammarAST COLON23_tree = default(GrammarAST);
		GrammarAST COLON24_tree = default(GrammarAST);
		GrammarAST ACTION26_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "action");
		DebugLocation(171, 1);
		try
		{
			// Grammars\\ANTLR.g3:172:2: ( AMPERSAND ^ ( actionScopeName COLON ! COLON !)? id ACTION )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:172:4: AMPERSAND ^ ( actionScopeName COLON ! COLON !)? id ACTION
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(172, 13);
			AMPERSAND21=(IToken)Match(input,AMPERSAND,Follow._AMPERSAND_in_action508); if (state.failed) return retval;
			if (state.backtracking == 0) {
			AMPERSAND21_tree = (GrammarAST)adaptor.Create(AMPERSAND21);
			root_0 = (GrammarAST)adaptor.BecomeRoot(AMPERSAND21_tree, root_0);
			}
			DebugLocation(172, 15);
			// Grammars\\ANTLR.g3:172:15: ( actionScopeName COLON ! COLON !)?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case TOKEN_REF:
				{
				int LA9_2 = input.LA(2);

				if ((LA9_2==COLON))
				{
					alt9 = 1;
				}
				}
				break;
			case RULE_REF:
				{
				int LA9_2 = input.LA(2);

				if ((LA9_2==COLON))
				{
					alt9 = 1;
				}
				}
				break;
			case LEXER:
			case PARSER:
				{
				alt9 = 1;
				}
				break;
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:172:16: actionScopeName COLON ! COLON !
				{
				DebugLocation(172, 16);
				PushFollow(Follow._actionScopeName_in_action512);
				actionScopeName22=actionScopeName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, actionScopeName22.Tree);
				DebugLocation(172, 37);
				COLON23=(IToken)Match(input,COLON,Follow._COLON_in_action514); if (state.failed) return retval;
				DebugLocation(172, 44);
				COLON24=(IToken)Match(input,COLON,Follow._COLON_in_action517); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(172, 48);
			PushFollow(Follow._id_in_action522);
			id25=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id25.Tree);
			DebugLocation(172, 51);
			ACTION26=(IToken)Match(input,ACTION,Follow._ACTION_in_action524); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION26_tree = (GrammarAST)adaptor.Create(ACTION26);
			adaptor.AddChild(root_0, ACTION26_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("action", 4);
			LeaveRule("action", 4);
			LeaveRule_action();
		}
		DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "action"); }
		return retval;

	}
	// $ANTLR end "action"

	partial void EnterRule_actionScopeName();
	partial void LeaveRule_actionScopeName();
	// $ANTLR start "actionScopeName"
	// Grammars\\ANTLR.g3:178:1: actionScopeName : ( id | 'lexer' | 'parser' );
	[GrammarRule("actionScopeName")]
	private AstParserRuleReturnScope<GrammarAST, IToken> actionScopeName()
	{
		EnterRule_actionScopeName();
		EnterRule("actionScopeName", 5);
		TraceIn("actionScopeName", 5);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal28 = default(IToken);
		IToken string_literal29 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id27 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST string_literal28_tree = default(GrammarAST);
		GrammarAST string_literal29_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "actionScopeName");
		DebugLocation(178, 1);
		try
		{
			// Grammars\\ANTLR.g3:179:2: ( id | 'lexer' | 'parser' )
			int alt10=3;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case RULE_REF:
			case TOKEN_REF:
				{
				alt10 = 1;
				}
				break;
			case LEXER:
				{
				alt10 = 2;
				}
				break;
			case PARSER:
				{
				alt10 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:179:4: id
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(179, 4);
				PushFollow(Follow._id_in_actionScopeName537);
				id27=id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, id27.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:180:4: 'lexer'
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(180, 4);
				string_literal28=(IToken)Match(input,LEXER,Follow._LEXER_in_actionScopeName542); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal28_tree = (GrammarAST)adaptor.Create(ID,string_literal28);
				adaptor.AddChild(root_0, string_literal28_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:181:4: 'parser'
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(181, 4);
				string_literal29=(IToken)Match(input,PARSER,Follow._PARSER_in_actionScopeName550); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal29_tree = (GrammarAST)adaptor.Create(ID,string_literal29);
				adaptor.AddChild(root_0, string_literal29_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("actionScopeName", 5);
			LeaveRule("actionScopeName", 5);
			LeaveRule_actionScopeName();
		}
		DebugLocation(182, 1);
		} finally { DebugExitRule(GrammarFileName, "actionScopeName"); }
		return retval;

	}
	// $ANTLR end "actionScopeName"

	private sealed partial class optionsSpec_return : AstParserRuleReturnScope<GrammarAST, IToken>
	{
		public IDictionary<string, object> opts=new Dictionary<string, object>();
		public optionsSpec_return(ANTLRParser grammar) {OnCreated(grammar);}
		partial void OnCreated(ANTLRParser grammar);
	}

	partial void EnterRule_optionsSpec();
	partial void LeaveRule_optionsSpec();
	// $ANTLR start "optionsSpec"
	// Grammars\\ANTLR.g3:184:1: optionsSpec returns [IDictionary<string, object> opts=new Dictionary<string, object>()] : OPTIONS ^ ( option[$opts] SEMI !)* RCURLY !;
	[GrammarRule("optionsSpec")]
	private ANTLRParser.optionsSpec_return optionsSpec()
	{
		EnterRule_optionsSpec();
		EnterRule("optionsSpec", 6);
		TraceIn("optionsSpec", 6);
		ANTLRParser.optionsSpec_return retval = new ANTLRParser.optionsSpec_return(this);
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken OPTIONS30 = default(IToken);
		IToken SEMI32 = default(IToken);
		IToken RCURLY33 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> option31 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST OPTIONS30_tree = default(GrammarAST);
		GrammarAST SEMI32_tree = default(GrammarAST);
		GrammarAST RCURLY33_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "optionsSpec");
		DebugLocation(184, 1);
		try
		{
			// Grammars\\ANTLR.g3:185:2: ( OPTIONS ^ ( option[$opts] SEMI !)* RCURLY !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:185:4: OPTIONS ^ ( option[$opts] SEMI !)* RCURLY !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(185, 11);
			OPTIONS30=(IToken)Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec568); if (state.failed) return retval;
			if (state.backtracking == 0) {
			OPTIONS30_tree = (GrammarAST)adaptor.Create(OPTIONS30);
			root_0 = (GrammarAST)adaptor.BecomeRoot(OPTIONS30_tree, root_0);
			}
			DebugLocation(185, 13);
			// Grammars\\ANTLR.g3:185:13: ( option[$opts] SEMI !)*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==RULE_REF||LA11_1==TOKEN_REF))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:185:14: option[$opts] SEMI !
					{
					DebugLocation(185, 14);
					PushFollow(Follow._option_in_optionsSpec572);
					option31=option(retval.opts);
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, option31.Tree);
					DebugLocation(185, 32);
					SEMI32=(IToken)Match(input,SEMI,Follow._SEMI_in_optionsSpec575); if (state.failed) return retval;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(185, 42);
			RCURLY33=(IToken)Match(input,RCURLY,Follow._RCURLY_in_optionsSpec580); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionsSpec", 6);
			LeaveRule("optionsSpec", 6);
			LeaveRule_optionsSpec();
		}
		DebugLocation(186, 1);
		} finally { DebugExitRule(GrammarFileName, "optionsSpec"); }
		return retval;

	}
	// $ANTLR end "optionsSpec"

	partial void EnterRule_option();
	partial void LeaveRule_option();
	// $ANTLR start "option"
	// Grammars\\ANTLR.g3:188:1: option[IDictionary<string, object> opts] : id ASSIGN ^ optionValue ;
	[GrammarRule("option")]
	private AstParserRuleReturnScope<GrammarAST, IToken> option(IDictionary<string, object> opts)
	{
		EnterRule_option();
		EnterRule("option", 7);
		TraceIn("option", 7);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ASSIGN35 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id34 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> optionValue36 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ASSIGN35_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "option");
		DebugLocation(188, 1);
		try
		{
			// Grammars\\ANTLR.g3:189:2: ( id ASSIGN ^ optionValue )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:189:4: id ASSIGN ^ optionValue
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(189, 4);
			PushFollow(Follow._id_in_option593);
			id34=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id34.Tree);
			DebugLocation(189, 13);
			ASSIGN35=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option595); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ASSIGN35_tree = (GrammarAST)adaptor.Create(ASSIGN35);
			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN35_tree, root_0);
			}
			DebugLocation(189, 15);
			PushFollow(Follow._optionValue_in_option598);
			optionValue36=optionValue();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, optionValue36.Tree);
			DebugLocation(190, 3);
			if (state.backtracking == 0)
			{

							opts[(id34!=null?input.ToString(id34.Start,id34.Stop):default(string))] = (optionValue36!=null?((ANTLRParser.optionValue_return)optionValue36).value:default(object));
						
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("option", 7);
			LeaveRule("option", 7);
			LeaveRule_option();
		}
		DebugLocation(193, 1);
		} finally { DebugExitRule(GrammarFileName, "option"); }
		return retval;

	}
	// $ANTLR end "option"

	private sealed partial class optionValue_return : AstParserRuleReturnScope<GrammarAST, IToken>
	{
		public object value;
		public optionValue_return(ANTLRParser grammar) {OnCreated(grammar);}
		partial void OnCreated(ANTLRParser grammar);
	}

	partial void EnterRule_optionValue();
	partial void LeaveRule_optionValue();
	// $ANTLR start "optionValue"
	// Grammars\\ANTLR.g3:195:1: optionValue returns [object value] : ( id |t= STRING_LITERAL |t= CHAR_LITERAL |t= INT |t= STAR );
	[GrammarRule("optionValue")]
	private ANTLRParser.optionValue_return optionValue()
	{
		EnterRule_optionValue();
		EnterRule("optionValue", 8);
		TraceIn("optionValue", 8);
		ANTLRParser.optionValue_return retval = new ANTLRParser.optionValue_return(this);
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken t = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id37 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST t_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "optionValue");
		DebugLocation(195, 1);
		try
		{
			// Grammars\\ANTLR.g3:196:2: ( id |t= STRING_LITERAL |t= CHAR_LITERAL |t= INT |t= STAR )
			int alt12=5;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case RULE_REF:
			case TOKEN_REF:
				{
				alt12 = 1;
				}
				break;
			case STRING_LITERAL:
				{
				alt12 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt12 = 3;
				}
				break;
			case INT:
				{
				alt12 = 4;
				}
				break;
			case STAR:
				{
				alt12 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:196:4: id
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(196, 4);
				PushFollow(Follow._id_in_optionValue617);
				id37=id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, id37.Tree);
				DebugLocation(196, 10);
				if (state.backtracking == 0)
				{
					retval.value = (id37!=null?input.ToString(id37.Start,id37.Stop):default(string));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:197:4: t= STRING_LITERAL
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(197, 5);
				t=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_optionValue629); if (state.failed) return retval;
				if (state.backtracking == 0) {
				t_tree = (GrammarAST)adaptor.Create(t);
				adaptor.AddChild(root_0, t_tree);
				}
				DebugLocation(197, 21);
				if (state.backtracking == 0)
				{
					string vs = (t!=null?t.Text:default(string));
											  // remove the quotes:
											  retval.value =vs.Substring(1,vs.Length-2);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:200:4: t= CHAR_LITERAL
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(200, 5);
				t=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_optionValue638); if (state.failed) return retval;
				if (state.backtracking == 0) {
				t_tree = (GrammarAST)adaptor.Create(t);
				adaptor.AddChild(root_0, t_tree);
				}
				DebugLocation(200, 21);
				if (state.backtracking == 0)
				{
					string vs = (t!=null?t.Text:default(string));
											  // remove the quotes:
											  retval.value =vs.Substring(1,vs.Length-2);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:203:4: t= INT
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(203, 5);
				t=(IToken)Match(input,INT,Follow._INT_in_optionValue649); if (state.failed) return retval;
				if (state.backtracking == 0) {
				t_tree = (GrammarAST)adaptor.Create(t);
				adaptor.AddChild(root_0, t_tree);
				}
				DebugLocation(203, 21);
				if (state.backtracking == 0)
				{
					retval.value = int.Parse((t!=null?t.Text:default(string)));
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\ANTLR.g3:204:4: t= STAR
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(204, 5);
				t=(IToken)Match(input,STAR,Follow._STAR_in_optionValue669); if (state.failed) return retval;
				if (state.backtracking == 0) {
				t_tree = (GrammarAST)adaptor.Create(STRING_LITERAL,t);
				adaptor.AddChild(root_0, t_tree);
				}
				DebugLocation(204, 30);
				if (state.backtracking == 0)
				{
					retval.value = "*";
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionValue", 8);
			LeaveRule("optionValue", 8);
			LeaveRule_optionValue();
		}
		DebugLocation(206, 1);
		} finally { DebugExitRule(GrammarFileName, "optionValue"); }
		return retval;

	}
	// $ANTLR end "optionValue"

	partial void EnterRule_delegateGrammars();
	partial void LeaveRule_delegateGrammars();
	// $ANTLR start "delegateGrammars"
	// Grammars\\ANTLR.g3:208:1: delegateGrammars : 'import' ^ delegateGrammar ( COMMA ! delegateGrammar )* SEMI !;
	[GrammarRule("delegateGrammars")]
	private AstParserRuleReturnScope<GrammarAST, IToken> delegateGrammars()
	{
		EnterRule_delegateGrammars();
		EnterRule("delegateGrammars", 9);
		TraceIn("delegateGrammars", 9);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal38 = default(IToken);
		IToken COMMA40 = default(IToken);
		IToken SEMI42 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> delegateGrammar39 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> delegateGrammar41 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST string_literal38_tree = default(GrammarAST);
		GrammarAST COMMA40_tree = default(GrammarAST);
		GrammarAST SEMI42_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "delegateGrammars");
		DebugLocation(208, 1);
		try
		{
			// Grammars\\ANTLR.g3:209:2: ( 'import' ^ delegateGrammar ( COMMA ! delegateGrammar )* SEMI !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:209:4: 'import' ^ delegateGrammar ( COMMA ! delegateGrammar )* SEMI !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(209, 12);
			string_literal38=(IToken)Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars690); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal38_tree = (GrammarAST)adaptor.Create(string_literal38);
			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal38_tree, root_0);
			}
			DebugLocation(209, 14);
			PushFollow(Follow._delegateGrammar_in_delegateGrammars693);
			delegateGrammar39=delegateGrammar();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, delegateGrammar39.Tree);
			DebugLocation(209, 30);
			// Grammars\\ANTLR.g3:209:30: ( COMMA ! delegateGrammar )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==COMMA))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:209:31: COMMA ! delegateGrammar
					{
					DebugLocation(209, 36);
					COMMA40=(IToken)Match(input,COMMA,Follow._COMMA_in_delegateGrammars696); if (state.failed) return retval;
					DebugLocation(209, 38);
					PushFollow(Follow._delegateGrammar_in_delegateGrammars699);
					delegateGrammar41=delegateGrammar();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, delegateGrammar41.Tree);

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(209, 60);
			SEMI42=(IToken)Match(input,SEMI,Follow._SEMI_in_delegateGrammars703); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("delegateGrammars", 9);
			LeaveRule("delegateGrammars", 9);
			LeaveRule_delegateGrammars();
		}
		DebugLocation(210, 1);
		} finally { DebugExitRule(GrammarFileName, "delegateGrammars"); }
		return retval;

	}
	// $ANTLR end "delegateGrammars"

	partial void EnterRule_delegateGrammar();
	partial void LeaveRule_delegateGrammar();
	// $ANTLR start "delegateGrammar"
	// Grammars\\ANTLR.g3:212:1: delegateGrammar : (lab= id ASSIGN ^)? g= id ;
	[GrammarRule("delegateGrammar")]
	private AstParserRuleReturnScope<GrammarAST, IToken> delegateGrammar()
	{
		EnterRule_delegateGrammar();
		EnterRule("delegateGrammar", 10);
		TraceIn("delegateGrammar", 10);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ASSIGN43 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> lab = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> g = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ASSIGN43_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "delegateGrammar");
		DebugLocation(212, 1);
		try
		{
			// Grammars\\ANTLR.g3:213:2: ( (lab= id ASSIGN ^)? g= id )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:213:4: (lab= id ASSIGN ^)? g= id
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(213, 4);
			// Grammars\\ANTLR.g3:213:4: (lab= id ASSIGN ^)?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==TOKEN_REF))
			{
				int LA14_2 = input.LA(2);

				if ((LA14_2==ASSIGN))
				{
					alt14 = 1;
				}
			}
			else if ((LA14_1==RULE_REF))
			{
				int LA14_2 = input.LA(2);

				if ((LA14_2==ASSIGN))
				{
					alt14 = 1;
				}
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:213:5: lab= id ASSIGN ^
				{
				DebugLocation(213, 8);
				PushFollow(Follow._id_in_delegateGrammar718);
				lab=id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, lab.Tree);
				DebugLocation(213, 18);
				ASSIGN43=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammar720); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN43_tree = (GrammarAST)adaptor.Create(ASSIGN43);
				root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN43_tree, root_0);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(213, 23);
			PushFollow(Follow._id_in_delegateGrammar727);
			g=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, g.Tree);
			DebugLocation(213, 27);
			if (state.backtracking == 0)
			{
				HandleDelegateGrammar((g!=null?((IToken)g.Start):default(IToken)), (lab!=null?input.ToString(lab.Start,lab.Stop):default(string)));
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("delegateGrammar", 10);
			LeaveRule("delegateGrammar", 10);
			LeaveRule_delegateGrammar();
		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "delegateGrammar"); }
		return retval;

	}
	// $ANTLR end "delegateGrammar"

	partial void EnterRule_tokensSpec();
	partial void LeaveRule_tokensSpec();
	// $ANTLR start "tokensSpec"
	// Grammars\\ANTLR.g3:216:1: tokensSpec : TOKENS ^ ( tokenSpec )* RCURLY !;
	[GrammarRule("tokensSpec")]
	private AstParserRuleReturnScope<GrammarAST, IToken> tokensSpec()
	{
		EnterRule_tokensSpec();
		EnterRule("tokensSpec", 11);
		TraceIn("tokensSpec", 11);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TOKENS44 = default(IToken);
		IToken RCURLY46 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> tokenSpec45 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST TOKENS44_tree = default(GrammarAST);
		GrammarAST RCURLY46_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "tokensSpec");
		DebugLocation(216, 1);
		try
		{
			// Grammars\\ANTLR.g3:217:2: ( TOKENS ^ ( tokenSpec )* RCURLY !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:217:4: TOKENS ^ ( tokenSpec )* RCURLY !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(217, 10);
			TOKENS44=(IToken)Match(input,TOKENS,Follow._TOKENS_in_tokensSpec740); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TOKENS44_tree = (GrammarAST)adaptor.Create(TOKENS44);
			root_0 = (GrammarAST)adaptor.BecomeRoot(TOKENS44_tree, root_0);
			}
			DebugLocation(218, 4);
			// Grammars\\ANTLR.g3:218:4: ( tokenSpec )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==TOKEN_REF))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:218:4: tokenSpec
					{
					DebugLocation(218, 4);
					PushFollow(Follow._tokenSpec_in_tokensSpec746);
					tokenSpec45=tokenSpec();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, tokenSpec45.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(219, 9);
			RCURLY46=(IToken)Match(input,RCURLY,Follow._RCURLY_in_tokensSpec751); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tokensSpec", 11);
			LeaveRule("tokensSpec", 11);
			LeaveRule_tokensSpec();
		}
		DebugLocation(220, 1);
		} finally { DebugExitRule(GrammarFileName, "tokensSpec"); }
		return retval;

	}
	// $ANTLR end "tokensSpec"

	partial void EnterRule_tokenSpec();
	partial void LeaveRule_tokenSpec();
	// $ANTLR start "tokenSpec"
	// Grammars\\ANTLR.g3:222:1: tokenSpec : TOKEN_REF ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI !;
	[GrammarRule("tokenSpec")]
	private AstParserRuleReturnScope<GrammarAST, IToken> tokenSpec()
	{
		EnterRule_tokenSpec();
		EnterRule("tokenSpec", 12);
		TraceIn("tokenSpec", 12);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TOKEN_REF47 = default(IToken);
		IToken ASSIGN48 = default(IToken);
		IToken set49 = default(IToken);
		IToken SEMI50 = default(IToken);

		GrammarAST TOKEN_REF47_tree = default(GrammarAST);
		GrammarAST ASSIGN48_tree = default(GrammarAST);
		GrammarAST set49_tree = default(GrammarAST);
		GrammarAST SEMI50_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "tokenSpec");
		DebugLocation(222, 1);
		try
		{
			// Grammars\\ANTLR.g3:223:2: ( TOKEN_REF ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:223:4: TOKEN_REF ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )? SEMI !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(223, 4);
			TOKEN_REF47=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec763); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TOKEN_REF47_tree = (GrammarAST)adaptor.Create(TOKEN_REF47);
			adaptor.AddChild(root_0, TOKEN_REF47_tree);
			}
			DebugLocation(223, 14);
			// Grammars\\ANTLR.g3:223:14: ( ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL ) )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==ASSIGN))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:223:15: ASSIGN ^ ( STRING_LITERAL | CHAR_LITERAL )
				{
				DebugLocation(223, 21);
				ASSIGN48=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec766); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN48_tree = (GrammarAST)adaptor.Create(ASSIGN48);
				root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN48_tree, root_0);
				}
				DebugLocation(223, 23);

				set49=(IToken)input.LT(1);
				if (input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL)
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(set49));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(223, 59);
			SEMI50=(IToken)Match(input,SEMI,Follow._SEMI_in_tokenSpec777); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tokenSpec", 12);
			LeaveRule("tokenSpec", 12);
			LeaveRule_tokenSpec();
		}
		DebugLocation(224, 1);
		} finally { DebugExitRule(GrammarFileName, "tokenSpec"); }
		return retval;

	}
	// $ANTLR end "tokenSpec"

	partial void EnterRule_attrScopes();
	partial void LeaveRule_attrScopes();
	// $ANTLR start "attrScopes"
	// Grammars\\ANTLR.g3:226:1: attrScopes : ( attrScope )* ;
	[GrammarRule("attrScopes")]
	private AstParserRuleReturnScope<GrammarAST, IToken> attrScopes()
	{
		EnterRule_attrScopes();
		EnterRule("attrScopes", 13);
		TraceIn("attrScopes", 13);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> attrScope51 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "attrScopes");
		DebugLocation(226, 1);
		try
		{
			// Grammars\\ANTLR.g3:227:2: ( ( attrScope )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:227:4: ( attrScope )*
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(227, 4);
			// Grammars\\ANTLR.g3:227:4: ( attrScope )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==SCOPE))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:227:4: attrScope
					{
					DebugLocation(227, 4);
					PushFollow(Follow._attrScope_in_attrScopes789);
					attrScope51=attrScope();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, attrScope51.Tree);

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attrScopes", 13);
			LeaveRule("attrScopes", 13);
			LeaveRule_attrScopes();
		}
		DebugLocation(228, 1);
		} finally { DebugExitRule(GrammarFileName, "attrScopes"); }
		return retval;

	}
	// $ANTLR end "attrScopes"

	partial void EnterRule_attrScope();
	partial void LeaveRule_attrScope();
	// $ANTLR start "attrScope"
	// Grammars\\ANTLR.g3:230:1: attrScope : 'scope' ^ id ( ruleActions )? ACTION ;
	[GrammarRule("attrScope")]
	private AstParserRuleReturnScope<GrammarAST, IToken> attrScope()
	{
		EnterRule_attrScope();
		EnterRule("attrScope", 14);
		TraceIn("attrScope", 14);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal52 = default(IToken);
		IToken ACTION55 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id53 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleActions54 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST string_literal52_tree = default(GrammarAST);
		GrammarAST ACTION55_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "attrScope");
		DebugLocation(230, 1);
		try
		{
			// Grammars\\ANTLR.g3:231:2: ( 'scope' ^ id ( ruleActions )? ACTION )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:231:4: 'scope' ^ id ( ruleActions )? ACTION
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(231, 11);
			string_literal52=(IToken)Match(input,SCOPE,Follow._SCOPE_in_attrScope801); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal52_tree = (GrammarAST)adaptor.Create(string_literal52);
			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal52_tree, root_0);
			}
			DebugLocation(231, 13);
			PushFollow(Follow._id_in_attrScope804);
			id53=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id53.Tree);
			DebugLocation(231, 16);
			// Grammars\\ANTLR.g3:231:16: ( ruleActions )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==AMPERSAND))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:231:16: ruleActions
				{
				DebugLocation(231, 16);
				PushFollow(Follow._ruleActions_in_attrScope806);
				ruleActions54=ruleActions();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ruleActions54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(231, 29);
			ACTION55=(IToken)Match(input,ACTION,Follow._ACTION_in_attrScope809); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION55_tree = (GrammarAST)adaptor.Create(ACTION55);
			adaptor.AddChild(root_0, ACTION55_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attrScope", 14);
			LeaveRule("attrScope", 14);
			LeaveRule_attrScope();
		}
		DebugLocation(232, 1);
		} finally { DebugExitRule(GrammarFileName, "attrScope"); }
		return retval;

	}
	// $ANTLR end "attrScope"

	partial void EnterRule_rules();
	partial void LeaveRule_rules();
	// $ANTLR start "rules"
	// Grammars\\ANTLR.g3:234:1: rules : ( rule )+ ;
	[GrammarRule("rules")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rules()
	{
		EnterRule_rules();
		EnterRule("rules", 15);
		TraceIn("rules", 15);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> rule56 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "rules");
		DebugLocation(234, 1);
		try
		{
			// Grammars\\ANTLR.g3:235:2: ( ( rule )+ )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:235:4: ( rule )+
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(235, 4);
			// Grammars\\ANTLR.g3:235:4: ( rule )+
			int cnt19=0;
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==DOC_COMMENT||LA19_1==FRAGMENT||(LA19_1>=PRIVATE && LA19_1<=PUBLIC)||LA19_1==RULE_REF||LA19_1==TOKEN_REF))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:235:4: rule
					{
					DebugLocation(235, 4);
					PushFollow(Follow._rule_in_rules820);
					rule56=rule();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, rule56.Tree);

					}
					break;

				default:
					if (cnt19 >= 1)
						goto loop19;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee19 = new EarlyExitException( 19, input );
					DebugRecognitionException(eee19);
					throw eee19;
				}
				cnt19++;
			}
			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rules", 15);
			LeaveRule("rules", 15);
			LeaveRule_rules();
		}
		DebugLocation(236, 1);
		} finally { DebugExitRule(GrammarFileName, "rules"); }
		return retval;

	}
	// $ANTLR end "rules"

	partial void EnterRule_rule();
	partial void LeaveRule_rule();
	// $ANTLR start "rule"
	// Grammars\\ANTLR.g3:239:1: public rule : ( (d= DOC_COMMENT )? (mod= 'protected' |mod= 'public' |mod= 'private' |mod= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $mod)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) ;
	[GrammarRule("rule")]
	public AstParserRuleReturnScope<GrammarAST, IToken> rule()
	{
		EnterRule_rule();
		EnterRule("rule", 16);
		TraceIn("rule", 16);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken d = default(IToken);
		IToken mod = default(IToken);
		IToken aa = default(IToken);
		IToken rt = default(IToken);
		IToken BANG57 = default(IToken);
		IToken string_literal58 = default(IToken);
		IToken COLON62 = default(IToken);
		IToken SEMI64 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleName = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> scopes = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ex = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> throwsSpec59 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> optionsSpec60 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleActions61 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleAltList63 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST d_tree = default(GrammarAST);
		GrammarAST mod_tree = default(GrammarAST);
		GrammarAST aa_tree = default(GrammarAST);
		GrammarAST rt_tree = default(GrammarAST);
		GrammarAST BANG57_tree = default(GrammarAST);
		GrammarAST string_literal58_tree = default(GrammarAST);
		GrammarAST COLON62_tree = default(GrammarAST);
		GrammarAST SEMI64_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_DOC_COMMENT=new RewriteRuleITokenStream(adaptor,"token DOC_COMMENT");
		RewriteRuleITokenStream stream_PROTECTED=new RewriteRuleITokenStream(adaptor,"token PROTECTED");
		RewriteRuleITokenStream stream_PUBLIC=new RewriteRuleITokenStream(adaptor,"token PUBLIC");
		RewriteRuleITokenStream stream_PRIVATE=new RewriteRuleITokenStream(adaptor,"token PRIVATE");
		RewriteRuleITokenStream stream_FRAGMENT=new RewriteRuleITokenStream(adaptor,"token FRAGMENT");
		RewriteRuleITokenStream stream_BANG=new RewriteRuleITokenStream(adaptor,"token BANG");
		RewriteRuleITokenStream stream_ARG_ACTION=new RewriteRuleITokenStream(adaptor,"token ARG_ACTION");
		RewriteRuleITokenStream stream_RETURNS=new RewriteRuleITokenStream(adaptor,"token RETURNS");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_id=new RewriteRuleSubtreeStream(adaptor,"rule id");
		RewriteRuleSubtreeStream stream_throwsSpec=new RewriteRuleSubtreeStream(adaptor,"rule throwsSpec");
		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
		RewriteRuleSubtreeStream stream_ruleScopeSpec=new RewriteRuleSubtreeStream(adaptor,"rule ruleScopeSpec");
		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
		RewriteRuleSubtreeStream stream_ruleAltList=new RewriteRuleSubtreeStream(adaptor,"rule ruleAltList");
		RewriteRuleSubtreeStream stream_exceptionGroup=new RewriteRuleSubtreeStream(adaptor,"rule exceptionGroup");

			GrammarAST eob=null;
			CommonToken start = (CommonToken)LT(1);
			int startLine = LT(1).Line;

		try { DebugEnterRule(GrammarFileName, "rule");
		DebugLocation(239, 1);
		try
		{
			// Grammars\\ANTLR.g3:246:2: ( ( (d= DOC_COMMENT )? (mod= 'protected' |mod= 'public' |mod= 'private' |mod= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $mod)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:247:2: ( (d= DOC_COMMENT )? (mod= 'protected' |mod= 'public' |mod= 'private' |mod= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $mod)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
			{
			DebugLocation(247, 2);
			// Grammars\\ANTLR.g3:247:2: ( (d= DOC_COMMENT )? (mod= 'protected' |mod= 'public' |mod= 'private' |mod= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )? -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $mod)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:247:4: (d= DOC_COMMENT )? (mod= 'protected' |mod= 'public' |mod= 'private' |mod= 'fragment' )? ruleName= id ( BANG )? (aa= ARG_ACTION )? ( 'returns' rt= ARG_ACTION )? ( throwsSpec )? ( optionsSpec )? scopes= ruleScopeSpec ( ruleActions )? COLON ruleAltList[$optionsSpec.opts] SEMI (ex= exceptionGroup )?
			{
			DebugLocation(247, 4);
			// Grammars\\ANTLR.g3:247:4: (d= DOC_COMMENT )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==DOC_COMMENT))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:247:6: d= DOC_COMMENT
				{
				DebugLocation(247, 7);
				d=(IToken)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_rule846); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOC_COMMENT.Add(d);


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(249, 3);
			// Grammars\\ANTLR.g3:249:3: (mod= 'protected' |mod= 'public' |mod= 'private' |mod= 'fragment' )?
			int alt21=5;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case PROTECTED:
				{
				alt21 = 1;
				}
				break;
			case PUBLIC:
				{
				alt21 = 2;
				}
				break;
			case PRIVATE:
				{
				alt21 = 3;
				}
				break;
			case FRAGMENT:
				{
				alt21 = 4;
				}
				break;
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:249:5: mod= 'protected'
				{
				DebugLocation(249, 8);
				mod=(IToken)Match(input,PROTECTED,Follow._PROTECTED_in_rule859); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PROTECTED.Add(mod);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:250:5: mod= 'public'
				{
				DebugLocation(250, 8);
				mod=(IToken)Match(input,PUBLIC,Follow._PUBLIC_in_rule867); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PUBLIC.Add(mod);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:251:5: mod= 'private'
				{
				DebugLocation(251, 8);
				mod=(IToken)Match(input,PRIVATE,Follow._PRIVATE_in_rule875); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PRIVATE.Add(mod);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:252:5: mod= 'fragment'
				{
				DebugLocation(252, 8);
				mod=(IToken)Match(input,FRAGMENT,Follow._FRAGMENT_in_rule883); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FRAGMENT.Add(mod);


				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(254, 11);
			PushFollow(Follow._id_in_rule894);
			ruleName=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_id.Add(ruleName.Tree);
			DebugLocation(255, 3);
			if (state.backtracking == 0)
			{

							currentRuleName=(ruleName!=null?input.ToString(ruleName.Start,ruleName.Stop):default(string));
							if ( GrammarType==GrammarType.Lexer && (mod!=null?mod.Text:default(string))!="fragment" )
								Grammar.lexerRuleNamesInCombined.Add(currentRuleName);
						
			}
			DebugLocation(260, 3);
			// Grammars\\ANTLR.g3:260:3: ( BANG )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if ((LA22_1==BANG))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:260:3: BANG
				{
				DebugLocation(260, 3);
				BANG57=(IToken)Match(input,BANG,Follow._BANG_in_rule902); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BANG.Add(BANG57);


				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(261, 3);
			// Grammars\\ANTLR.g3:261:3: (aa= ARG_ACTION )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==ARG_ACTION))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:261:5: aa= ARG_ACTION
				{
				DebugLocation(261, 7);
				aa=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule911); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARG_ACTION.Add(aa);


				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(262, 3);
			// Grammars\\ANTLR.g3:262:3: ( 'returns' rt= ARG_ACTION )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==RETURNS))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:262:5: 'returns' rt= ARG_ACTION
				{
				DebugLocation(262, 5);
				string_literal58=(IToken)Match(input,RETURNS,Follow._RETURNS_in_rule920); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RETURNS.Add(string_literal58);

				DebugLocation(262, 17);
				rt=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule924); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ARG_ACTION.Add(rt);


				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(263, 3);
			// Grammars\\ANTLR.g3:263:3: ( throwsSpec )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==THROWS))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:263:3: throwsSpec
				{
				DebugLocation(263, 3);
				PushFollow(Follow._throwsSpec_in_rule932);
				throwsSpec59=throwsSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_throwsSpec.Add(throwsSpec59.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(264, 3);
			// Grammars\\ANTLR.g3:264:3: ( optionsSpec )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1==OPTIONS))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:264:3: optionsSpec
				{
				DebugLocation(264, 3);
				PushFollow(Follow._optionsSpec_in_rule937);
				optionsSpec60=optionsSpec();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_optionsSpec.Add(optionsSpec60.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(265, 9);
			PushFollow(Follow._ruleScopeSpec_in_rule944);
			scopes=ruleScopeSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ruleScopeSpec.Add(scopes.Tree);
			DebugLocation(266, 3);
			// Grammars\\ANTLR.g3:266:3: ( ruleActions )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_1 = input.LA(1);

			if ((LA27_1==AMPERSAND))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:266:3: ruleActions
				{
				DebugLocation(266, 3);
				PushFollow(Follow._ruleActions_in_rule948);
				ruleActions61=ruleActions();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ruleActions.Add(ruleActions61.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(267, 3);
			COLON62=(IToken)Match(input,COLON,Follow._COLON_in_rule953); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON62);

			DebugLocation(268, 3);
			PushFollow(Follow._ruleAltList_in_rule957);
			ruleAltList63=ruleAltList((optionsSpec60!=null?((ANTLRParser.optionsSpec_return)optionsSpec60).opts:default(IDictionary<string, object>)));
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ruleAltList.Add(ruleAltList63.Tree);
			DebugLocation(269, 3);
			SEMI64=(IToken)Match(input,SEMI,Follow._SEMI_in_rule962); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SEMI.Add(SEMI64);

			DebugLocation(270, 3);
			// Grammars\\ANTLR.g3:270:3: (ex= exceptionGroup )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==CATCH||LA28_1==FINALLY))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:270:5: ex= exceptionGroup
				{
				DebugLocation(270, 7);
				PushFollow(Follow._exceptionGroup_in_rule970);
				ex=exceptionGroup();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_exceptionGroup.Add(ex.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(28); }



			{
			// AST REWRITE
			// elements: ruleName, mod, aa, rt, throwsSpec, optionsSpec, scopes, ruleActions, ruleAltList, ex
			// token labels: mod, aa, rt
			// rule labels: ruleName, scopes, ex, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_mod=new RewriteRuleITokenStream(adaptor,"token mod",mod);
			RewriteRuleITokenStream stream_aa=new RewriteRuleITokenStream(adaptor,"token aa",aa);
			RewriteRuleITokenStream stream_rt=new RewriteRuleITokenStream(adaptor,"token rt",rt);
			RewriteRuleSubtreeStream stream_ruleName=new RewriteRuleSubtreeStream(adaptor,"rule ruleName",ruleName!=null?ruleName.Tree:null);
			RewriteRuleSubtreeStream stream_scopes=new RewriteRuleSubtreeStream(adaptor,"rule scopes",scopes!=null?scopes.Tree:null);
			RewriteRuleSubtreeStream stream_ex=new RewriteRuleSubtreeStream(adaptor,"rule ex",ex!=null?ex.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 271:3: -> ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $mod)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
			{
				DebugLocation(271, 6);
				// Grammars\\ANTLR.g3:271:6: ^( RULE[$ruleName.start, \"rule\"] $ruleName ( $mod)? ^( ARG[\"ARG\"] ( $aa)? ) ^( RET[\"RET\"] ( $rt)? ) ( throwsSpec )? ( optionsSpec )? $scopes ( ruleActions )? ruleAltList ( $ex)? EOR[$SEMI,\"<end-of-rule>\"] )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(271, 9);
				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(RULE, (ruleName!=null?((IToken)ruleName.Start):default(IToken)), "rule"), root_1);

				DebugLocation(272, 6);
				adaptor.AddChild(root_1, stream_ruleName.NextTree());
				DebugLocation(274, 6);
				// Grammars\\ANTLR.g3:274:6: ( $mod)?
				if (stream_mod.HasNext)
				{
					DebugLocation(274, 6);
					adaptor.AddChild(root_1, stream_mod.NextNode());

				}
				stream_mod.Reset();
				DebugLocation(275, 5);
				// Grammars\\ANTLR.g3:275:5: ^( ARG[\"ARG\"] ( $aa)? )
				{
				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
				DebugLocation(275, 7);
				root_2 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARG, "ARG"), root_2);

				DebugLocation(275, 19);
				// Grammars\\ANTLR.g3:275:19: ( $aa)?
				if (stream_aa.HasNext)
				{
					DebugLocation(275, 19);
					adaptor.AddChild(root_2, stream_aa.NextNode());

				}
				stream_aa.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(276, 5);
				// Grammars\\ANTLR.g3:276:5: ^( RET[\"RET\"] ( $rt)? )
				{
				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
				DebugLocation(276, 7);
				root_2 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(RET, "RET"), root_2);

				DebugLocation(276, 19);
				// Grammars\\ANTLR.g3:276:19: ( $rt)?
				if (stream_rt.HasNext)
				{
					DebugLocation(276, 19);
					adaptor.AddChild(root_2, stream_rt.NextNode());

				}
				stream_rt.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(277, 5);
				// Grammars\\ANTLR.g3:277:5: ( throwsSpec )?
				if (stream_throwsSpec.HasNext)
				{
					DebugLocation(277, 5);
					adaptor.AddChild(root_1, stream_throwsSpec.NextTree());

				}
				stream_throwsSpec.Reset();
				DebugLocation(278, 5);
				// Grammars\\ANTLR.g3:278:5: ( optionsSpec )?
				if (stream_optionsSpec.HasNext)
				{
					DebugLocation(278, 5);
					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());

				}
				stream_optionsSpec.Reset();
				DebugLocation(279, 6);
				adaptor.AddChild(root_1, stream_scopes.NextTree());
				DebugLocation(280, 5);
				// Grammars\\ANTLR.g3:280:5: ( ruleActions )?
				if (stream_ruleActions.HasNext)
				{
					DebugLocation(280, 5);
					adaptor.AddChild(root_1, stream_ruleActions.NextTree());

				}
				stream_ruleActions.Reset();
				DebugLocation(281, 5);
				adaptor.AddChild(root_1, stream_ruleAltList.NextTree());
				DebugLocation(282, 6);
				// Grammars\\ANTLR.g3:282:6: ( $ex)?
				if (stream_ex.HasNext)
				{
					DebugLocation(282, 6);
					adaptor.AddChild(root_1, stream_ex.NextTree());

				}
				stream_ex.Reset();
				DebugLocation(283, 5);
				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOR, SEMI64, "<end-of-rule>"));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(285, 2);
			if (state.backtracking == 0)
			{

						retval.Tree.SetTreeEnclosingRuleNameDeeply(currentRuleName);
						((GrammarAST)retval.Tree.GetChild(0)).BlockOptions = (optionsSpec60!=null?((ANTLRParser.optionsSpec_return)optionsSpec60).opts:default(IDictionary<string, object>));
					
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rule", 16);
			LeaveRule("rule", 16);
			LeaveRule_rule();
		}
		DebugLocation(289, 1);
		} finally { DebugExitRule(GrammarFileName, "rule"); }
		return retval;

	}
	// $ANTLR end "rule"

	partial void EnterRule_ruleActions();
	partial void LeaveRule_ruleActions();
	// $ANTLR start "ruleActions"
	// Grammars\\ANTLR.g3:291:1: ruleActions : ( ruleAction )+ ;
	[GrammarRule("ruleActions")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ruleActions()
	{
		EnterRule_ruleActions();
		EnterRule("ruleActions", 17);
		TraceIn("ruleActions", 17);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> ruleAction65 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "ruleActions");
		DebugLocation(291, 1);
		try
		{
			// Grammars\\ANTLR.g3:292:2: ( ( ruleAction )+ )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:292:4: ( ruleAction )+
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(292, 4);
			// Grammars\\ANTLR.g3:292:4: ( ruleAction )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==AMPERSAND))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:292:4: ruleAction
					{
					DebugLocation(292, 4);
					PushFollow(Follow._ruleAction_in_ruleActions1095);
					ruleAction65=ruleAction();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, ruleAction65.Tree);

					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ruleActions", 17);
			LeaveRule("ruleActions", 17);
			LeaveRule_ruleActions();
		}
		DebugLocation(293, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleActions"); }
		return retval;

	}
	// $ANTLR end "ruleActions"

	partial void EnterRule_ruleAction();
	partial void LeaveRule_ruleAction();
	// $ANTLR start "ruleAction"
	// Grammars\\ANTLR.g3:296:1: ruleAction : AMPERSAND ^ id ACTION ;
	[GrammarRule("ruleAction")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ruleAction()
	{
		EnterRule_ruleAction();
		EnterRule("ruleAction", 18);
		TraceIn("ruleAction", 18);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken AMPERSAND66 = default(IToken);
		IToken ACTION68 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id67 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST AMPERSAND66_tree = default(GrammarAST);
		GrammarAST ACTION68_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "ruleAction");
		DebugLocation(296, 1);
		try
		{
			// Grammars\\ANTLR.g3:297:2: ( AMPERSAND ^ id ACTION )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:297:4: AMPERSAND ^ id ACTION
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(297, 13);
			AMPERSAND66=(IToken)Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction1109); if (state.failed) return retval;
			if (state.backtracking == 0) {
			AMPERSAND66_tree = (GrammarAST)adaptor.Create(AMPERSAND66);
			root_0 = (GrammarAST)adaptor.BecomeRoot(AMPERSAND66_tree, root_0);
			}
			DebugLocation(297, 15);
			PushFollow(Follow._id_in_ruleAction1112);
			id67=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id67.Tree);
			DebugLocation(297, 18);
			ACTION68=(IToken)Match(input,ACTION,Follow._ACTION_in_ruleAction1114); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION68_tree = (GrammarAST)adaptor.Create(ACTION68);
			adaptor.AddChild(root_0, ACTION68_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ruleAction", 18);
			LeaveRule("ruleAction", 18);
			LeaveRule_ruleAction();
		}
		DebugLocation(298, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleAction"); }
		return retval;

	}
	// $ANTLR end "ruleAction"

	partial void EnterRule_throwsSpec();
	partial void LeaveRule_throwsSpec();
	// $ANTLR start "throwsSpec"
	// Grammars\\ANTLR.g3:300:1: throwsSpec : 'throws' ^ id ( COMMA ! id )* ;
	[GrammarRule("throwsSpec")]
	private AstParserRuleReturnScope<GrammarAST, IToken> throwsSpec()
	{
		EnterRule_throwsSpec();
		EnterRule("throwsSpec", 19);
		TraceIn("throwsSpec", 19);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal69 = default(IToken);
		IToken COMMA71 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id70 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> id72 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST string_literal69_tree = default(GrammarAST);
		GrammarAST COMMA71_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "throwsSpec");
		DebugLocation(300, 1);
		try
		{
			// Grammars\\ANTLR.g3:301:2: ( 'throws' ^ id ( COMMA ! id )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:301:4: 'throws' ^ id ( COMMA ! id )*
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(301, 12);
			string_literal69=(IToken)Match(input,THROWS,Follow._THROWS_in_throwsSpec1125); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal69_tree = (GrammarAST)adaptor.Create(string_literal69);
			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal69_tree, root_0);
			}
			DebugLocation(301, 14);
			PushFollow(Follow._id_in_throwsSpec1128);
			id70=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id70.Tree);
			DebugLocation(301, 17);
			// Grammars\\ANTLR.g3:301:17: ( COMMA ! id )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1==COMMA))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:301:18: COMMA ! id
					{
					DebugLocation(301, 23);
					COMMA71=(IToken)Match(input,COMMA,Follow._COMMA_in_throwsSpec1131); if (state.failed) return retval;
					DebugLocation(301, 25);
					PushFollow(Follow._id_in_throwsSpec1134);
					id72=id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, id72.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwsSpec", 19);
			LeaveRule("throwsSpec", 19);
			LeaveRule_throwsSpec();
		}
		DebugLocation(302, 1);
		} finally { DebugExitRule(GrammarFileName, "throwsSpec"); }
		return retval;

	}
	// $ANTLR end "throwsSpec"

	partial void EnterRule_ruleScopeSpec();
	partial void LeaveRule_ruleScopeSpec();
	// $ANTLR start "ruleScopeSpec"
	// Grammars\\ANTLR.g3:304:1: ruleScopeSpec : ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) ;
	[GrammarRule("ruleScopeSpec")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ruleScopeSpec()
	{
		EnterRule_ruleScopeSpec();
		EnterRule("ruleScopeSpec", 20);
		TraceIn("ruleScopeSpec", 20);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal73 = default(IToken);
		IToken ACTION75 = default(IToken);
		IToken string_literal76 = default(IToken);
		IToken SEMI78 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleActions74 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> idList77 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST string_literal73_tree = default(GrammarAST);
		GrammarAST ACTION75_tree = default(GrammarAST);
		GrammarAST string_literal76_tree = default(GrammarAST);
		GrammarAST SEMI78_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_SCOPE=new RewriteRuleITokenStream(adaptor,"token SCOPE");
		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
		RewriteRuleSubtreeStream stream_idList=new RewriteRuleSubtreeStream(adaptor,"rule idList");
		try { DebugEnterRule(GrammarFileName, "ruleScopeSpec");
		DebugLocation(304, 1);
		try
		{
			// Grammars\\ANTLR.g3:305:2: ( ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )* -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:305:4: ( 'scope' ( ruleActions )? ACTION )? ( 'scope' idList SEMI )*
			{
			DebugLocation(305, 4);
			// Grammars\\ANTLR.g3:305:4: ( 'scope' ( ruleActions )? ACTION )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1==SCOPE))
			{
				int LA32_2 = input.LA(2);

				if ((LA32_2==ACTION||LA32_2==AMPERSAND))
				{
					alt32 = 1;
				}
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:305:6: 'scope' ( ruleActions )? ACTION
				{
				DebugLocation(305, 6);
				string_literal73=(IToken)Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec1149); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SCOPE.Add(string_literal73);

				DebugLocation(305, 14);
				// Grammars\\ANTLR.g3:305:14: ( ruleActions )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==AMPERSAND))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:305:14: ruleActions
					{
					DebugLocation(305, 14);
					PushFollow(Follow._ruleActions_in_ruleScopeSpec1151);
					ruleActions74=ruleActions();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_ruleActions.Add(ruleActions74.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(31); }

				DebugLocation(305, 27);
				ACTION75=(IToken)Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec1154); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ACTION.Add(ACTION75);


				}
				break;

			}
			} finally { DebugExitSubRule(32); }

			DebugLocation(306, 3);
			// Grammars\\ANTLR.g3:306:3: ( 'scope' idList SEMI )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_1 = input.LA(1);

				if ((LA33_1==SCOPE))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:306:5: 'scope' idList SEMI
					{
					DebugLocation(306, 5);
					string_literal76=(IToken)Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec1163); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SCOPE.Add(string_literal76);

					DebugLocation(306, 13);
					PushFollow(Follow._idList_in_ruleScopeSpec1165);
					idList77=idList();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_idList.Add(idList77.Tree);
					DebugLocation(306, 20);
					SEMI78=(IToken)Match(input,SEMI,Follow._SEMI_in_ruleScopeSpec1167); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SEMI.Add(SEMI78);


					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }



			{
			// AST REWRITE
			// elements: ruleActions, ACTION, idList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 307:3: -> ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
			{
				DebugLocation(307, 6);
				// Grammars\\ANTLR.g3:307:6: ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(307, 8);
				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SCOPE, retval.Start, "scope"), root_1);

				DebugLocation(307, 30);
				// Grammars\\ANTLR.g3:307:30: ( ruleActions )?
				if (stream_ruleActions.HasNext)
				{
					DebugLocation(307, 30);
					adaptor.AddChild(root_1, stream_ruleActions.NextTree());

				}
				stream_ruleActions.Reset();
				DebugLocation(307, 43);
				// Grammars\\ANTLR.g3:307:43: ( ACTION )?
				if (stream_ACTION.HasNext)
				{
					DebugLocation(307, 43);
					adaptor.AddChild(root_1, stream_ACTION.NextNode());

				}
				stream_ACTION.Reset();
				DebugLocation(307, 51);
				// Grammars\\ANTLR.g3:307:51: ( idList )*
				while ( stream_idList.HasNext )
				{
					DebugLocation(307, 51);
					adaptor.AddChild(root_1, stream_idList.NextTree());

				}
				stream_idList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ruleScopeSpec", 20);
			LeaveRule("ruleScopeSpec", 20);
			LeaveRule_ruleScopeSpec();
		}
		DebugLocation(308, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleScopeSpec"); }
		return retval;

	}
	// $ANTLR end "ruleScopeSpec"

	partial void EnterRule_ruleAltList();
	partial void LeaveRule_ruleAltList();
	// $ANTLR start "ruleAltList"
	// Grammars\\ANTLR.g3:310:1: ruleAltList[IDictionary<string, object> opts] : ( -> BLOCK[input.LT(-1),\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |) -> ^( $ruleAltList EOB[\"<end-of-block>\"] ) ;
	[GrammarRule("ruleAltList")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ruleAltList(IDictionary<string, object> opts)
	{
		EnterRule_ruleAltList();
		EnterRule("ruleAltList", 21);
		TraceIn("ruleAltList", 21);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken OR79 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> a1 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> r1 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> a2 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> r2 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST OR79_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");

			GrammarAST blkRoot = null;
			GrammarAST save = currentBlockAST;

		try { DebugEnterRule(GrammarFileName, "ruleAltList");
		DebugLocation(310, 1);
		try
		{
			// Grammars\\ANTLR.g3:316:2: ( ( -> BLOCK[input.LT(-1),\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |) -> ^( $ruleAltList EOB[\"<end-of-block>\"] ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:316:4: ( -> BLOCK[input.LT(-1),\"BLOCK\"] ) (a1= alternative r1= rewrite -> $a1 ( $r1)? ) ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |)
			{
			DebugLocation(316, 4);
			// Grammars\\ANTLR.g3:316:4: ( -> BLOCK[input.LT(-1),\"BLOCK\"] )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:316:6: 
			{

			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 316:6: -> BLOCK[input.LT(-1),\"BLOCK\"]
			{
				DebugLocation(316, 9);
				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, input.LT(-1), "BLOCK"));

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(317, 3);
			if (state.backtracking == 0)
			{

							blkRoot = (GrammarAST)retval.Tree.GetChild(0);
							blkRoot.BlockOptions = opts;
							currentBlockAST = blkRoot;
						
			}
			DebugLocation(322, 3);
			// Grammars\\ANTLR.g3:322:3: (a1= alternative r1= rewrite -> $a1 ( $r1)? )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:322:5: a1= alternative r1= rewrite
			{
			DebugLocation(322, 7);
			PushFollow(Follow._alternative_in_ruleAltList1224);
			a1=alternative();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_alternative.Add(a1.Tree);
			DebugLocation(322, 22);
			PushFollow(Follow._rewrite_in_ruleAltList1228);
			r1=rewrite();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rewrite.Add(r1.Tree);
			DebugLocation(323, 4);
			if (state.backtracking == 0)
			{
				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a1!=null?((GrammarAST)a1.Tree):default(GrammarAST)));
			}


			{
			// AST REWRITE
			// elements: a1, r1
			// token labels: 
			// rule labels: a1, r1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_a1=new RewriteRuleSubtreeStream(adaptor,"rule a1",a1!=null?a1.Tree:null);
			RewriteRuleSubtreeStream stream_r1=new RewriteRuleSubtreeStream(adaptor,"rule r1",r1!=null?r1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 324:4: -> $a1 ( $r1)?
			{
				DebugLocation(324, 8);
				adaptor.AddChild(root_0, stream_a1.NextTree());
				DebugLocation(324, 12);
				// Grammars\\ANTLR.g3:324:12: ( $r1)?
				if (stream_r1.HasNext)
				{
					DebugLocation(324, 12);
					adaptor.AddChild(root_0, stream_r1.NextTree());

				}
				stream_r1.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(326, 3);
			// Grammars\\ANTLR.g3:326:3: ( ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+ |)
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_1 = input.LA(1);

			if ((LA35_1==OR))
			{
				alt35 = 1;
			}
			else if ((LA35_1==SEMI))
			{
				alt35 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 35, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:326:5: ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+
				{
				DebugLocation(326, 5);
				// Grammars\\ANTLR.g3:326:5: ( OR a2= alternative r2= rewrite -> $ruleAltList $a2 ( $r2)? )+
				int cnt34=0;
				try { DebugEnterSubRule(34);
				while (true)
				{
					int alt34=2;
					try { DebugEnterDecision(34, false);
					int LA34_1 = input.LA(1);

					if ((LA34_1==OR))
					{
						alt34 = 1;
					}


					} finally { DebugExitDecision(34); }
					switch (alt34)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:326:7: OR a2= alternative r2= rewrite
						{
						DebugLocation(326, 7);
						OR79=(IToken)Match(input,OR,Follow._OR_in_ruleAltList1257); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_OR.Add(OR79);

						DebugLocation(326, 12);
						PushFollow(Follow._alternative_in_ruleAltList1261);
						a2=alternative();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_alternative.Add(a2.Tree);
						DebugLocation(326, 27);
						PushFollow(Follow._rewrite_in_ruleAltList1265);
						r2=rewrite();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_rewrite.Add(r2.Tree);
						DebugLocation(327, 5);
						if (state.backtracking == 0)
						{
							if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a2!=null?((GrammarAST)a2.Tree):default(GrammarAST)));
						}


						{
						// AST REWRITE
						// elements: ruleAltList, a2, r2
						// token labels: 
						// rule labels: a2, r2, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_a2=new RewriteRuleSubtreeStream(adaptor,"rule a2",a2!=null?a2.Tree:null);
						RewriteRuleSubtreeStream stream_r2=new RewriteRuleSubtreeStream(adaptor,"rule r2",r2!=null?r2.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (GrammarAST)adaptor.Nil();
						// 328:5: -> $ruleAltList $a2 ( $r2)?
						{
							DebugLocation(328, 9);
							adaptor.AddChild(root_0, stream_retval.NextTree());
							DebugLocation(328, 22);
							adaptor.AddChild(root_0, stream_a2.NextTree());
							DebugLocation(328, 26);
							// Grammars\\ANTLR.g3:328:26: ( $r2)?
							if (stream_r2.HasNext)
							{
								DebugLocation(328, 26);
								adaptor.AddChild(root_0, stream_r2.NextTree());

							}
							stream_r2.Reset();

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					default:
						if (cnt34 >= 1)
							goto loop34;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee34 = new EarlyExitException( 34, input );
						DebugRecognitionException(eee34);
						throw eee34;
					}
					cnt34++;
				}
				loop34:
					;

				} finally { DebugExitSubRule(34); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:331:3: 
				{
				}
				break;

			}
			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: ruleAltList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 332:3: -> ^( $ruleAltList EOB[\"<end-of-block>\"] )
			{
				DebugLocation(332, 6);
				// Grammars\\ANTLR.g3:332:6: ^( $ruleAltList EOB[\"<end-of-block>\"] )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(332, 8);
				root_1 = (GrammarAST)adaptor.BecomeRoot(blkRoot, root_1);

				DebugLocation(332, 19);
				adaptor.AddChild(root_1, stream_retval.NextTree());
				DebugLocation(332, 31);
				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, "<end-of-block>"));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ruleAltList", 21);
			LeaveRule("ruleAltList", 21);
			LeaveRule_ruleAltList();
			 currentBlockAST = save; 
		}
		DebugLocation(333, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleAltList"); }
		return retval;

	}
	// $ANTLR end "ruleAltList"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// Grammars\\ANTLR.g3:337:1: block : (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<GrammarAST, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 22);
		TraceIn("block", 22);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken lp = default(IToken);
		IToken rp = default(IToken);
		IToken COLON82 = default(IToken);
		IToken ACTION83 = default(IToken);
		IToken COLON84 = default(IToken);
		IToken OR85 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> a = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> r = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> optionsSpec80 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleActions81 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST lp_tree = default(GrammarAST);
		GrammarAST rp_tree = default(GrammarAST);
		GrammarAST COLON82_tree = default(GrammarAST);
		GrammarAST ACTION83_tree = default(GrammarAST);
		GrammarAST COLON84_tree = default(GrammarAST);
		GrammarAST OR85_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ACTION=new RewriteRuleITokenStream(adaptor,"token ACTION");
		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_optionsSpec=new RewriteRuleSubtreeStream(adaptor,"rule optionsSpec");
		RewriteRuleSubtreeStream stream_ruleActions=new RewriteRuleSubtreeStream(adaptor,"rule ruleActions");
		RewriteRuleSubtreeStream stream_alternative=new RewriteRuleSubtreeStream(adaptor,"rule alternative");
		RewriteRuleSubtreeStream stream_rewrite=new RewriteRuleSubtreeStream(adaptor,"rule rewrite");

			GrammarAST save = currentBlockAST;

		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(337, 1);
		try
		{
			// Grammars\\ANTLR.g3:342:2: ( (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:342:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] ) ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )? a= alternative r= rewrite ( OR a= alternative r= rewrite )* rp= RPAREN
			{
			DebugLocation(342, 4);
			// Grammars\\ANTLR.g3:342:4: (lp= LPAREN -> BLOCK[$lp,\"BLOCK\"] )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:342:6: lp= LPAREN
			{
			DebugLocation(342, 8);
			lp=(IToken)Match(input,LPAREN,Follow._LPAREN_in_block1341); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(lp);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 343:4: -> BLOCK[$lp,\"BLOCK\"]
			{
				DebugLocation(343, 7);
				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, lp, "BLOCK"));

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(345, 3);
			if (state.backtracking == 0)
			{
				currentBlockAST = (GrammarAST)retval.Tree.GetChild(0);
			}
			DebugLocation(346, 3);
			// Grammars\\ANTLR.g3:346:3: ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )?
			int alt38=3;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==AMPERSAND||LA38_1==COLON||LA38_1==OPTIONS))
			{
				alt38 = 1;
			}
			else if ((LA38_1==ACTION))
			{
				int LA38_2 = input.LA(2);

				if ((LA38_2==COLON))
				{
					alt38 = 2;
				}
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:350:4: ( optionsSpec )? ( ruleActions )? COLON
				{
				DebugLocation(350, 4);
				// Grammars\\ANTLR.g3:350:4: ( optionsSpec )?
				int alt36=2;
				try { DebugEnterSubRule(36);
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==OPTIONS))
				{
					alt36 = 1;
				}
				} finally { DebugExitDecision(36); }
				switch (alt36)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:350:5: optionsSpec
					{
					DebugLocation(350, 5);
					PushFollow(Follow._optionsSpec_in_block1379);
					optionsSpec80=optionsSpec();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_optionsSpec.Add(optionsSpec80.Tree);
					DebugLocation(350, 17);
					if (state.backtracking == 0)
					{
						((GrammarAST)retval.Tree.GetChild(0)).SetOptions(Grammar,(optionsSpec80!=null?((ANTLRParser.optionsSpec_return)optionsSpec80).opts:default(IDictionary<string, object>)));
					}

					}
					break;

				}
				} finally { DebugExitSubRule(36); }

				DebugLocation(351, 4);
				// Grammars\\ANTLR.g3:351:4: ( ruleActions )?
				int alt37=2;
				try { DebugEnterSubRule(37);
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1==AMPERSAND))
				{
					alt37 = 1;
				}
				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:351:6: ruleActions
					{
					DebugLocation(351, 6);
					PushFollow(Follow._ruleActions_in_block1390);
					ruleActions81=ruleActions();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_ruleActions.Add(ruleActions81.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(37); }

				DebugLocation(352, 4);
				COLON82=(IToken)Match(input,COLON,Follow._COLON_in_block1398); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON82);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:353:5: ACTION COLON
				{
				DebugLocation(353, 5);
				ACTION83=(IToken)Match(input,ACTION,Follow._ACTION_in_block1404); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ACTION.Add(ACTION83);

				DebugLocation(353, 12);
				COLON84=(IToken)Match(input,COLON,Follow._COLON_in_block1406); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON84);


				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(356, 4);
			PushFollow(Follow._alternative_in_block1418);
			a=alternative();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_alternative.Add(a.Tree);
			DebugLocation(356, 18);
			PushFollow(Follow._rewrite_in_block1422);
			r=rewrite();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rewrite.Add(r.Tree);
			DebugLocation(357, 3);
			if (state.backtracking == 0)
			{

							stream_alternative.Add( (r!=null?((GrammarAST)r.Tree):default(GrammarAST)) );
							if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
								PrefixWithSynPred((a!=null?((GrammarAST)a.Tree):default(GrammarAST)));
						
			}
			DebugLocation(362, 3);
			// Grammars\\ANTLR.g3:362:3: ( OR a= alternative r= rewrite )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==OR))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:362:5: OR a= alternative r= rewrite
					{
					DebugLocation(362, 5);
					OR85=(IToken)Match(input,OR,Follow._OR_in_block1432); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_OR.Add(OR85);

					DebugLocation(362, 9);
					PushFollow(Follow._alternative_in_block1436);
					a=alternative();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_alternative.Add(a.Tree);
					DebugLocation(362, 23);
					PushFollow(Follow._rewrite_in_block1440);
					r=rewrite();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_rewrite.Add(r.Tree);
					DebugLocation(363, 4);
					if (state.backtracking == 0)
					{

										stream_alternative.Add( (r!=null?((GrammarAST)r.Tree):default(GrammarAST)) );
										if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
											PrefixWithSynPred((a!=null?((GrammarAST)a.Tree):default(GrammarAST)));
									
					}

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }

			DebugLocation(370, 5);
			rp=(IToken)Match(input,RPAREN,Follow._RPAREN_in_block1457); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(rp);



			{
			// AST REWRITE
			// elements: block, optionsSpec, ruleActions, ACTION, alternative
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 371:3: -> ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
			{
				DebugLocation(371, 6);
				// Grammars\\ANTLR.g3:371:6: ^( $block ( optionsSpec )? ( ruleActions )? ( ACTION )? ( alternative )+ EOB[$rp,\"<end-of-block>\"] )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(371, 9);
				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);

				DebugLocation(371, 15);
				// Grammars\\ANTLR.g3:371:15: ( optionsSpec )?
				if (stream_optionsSpec.HasNext)
				{
					DebugLocation(371, 15);
					adaptor.AddChild(root_1, stream_optionsSpec.NextTree());

				}
				stream_optionsSpec.Reset();
				DebugLocation(371, 28);
				// Grammars\\ANTLR.g3:371:28: ( ruleActions )?
				if (stream_ruleActions.HasNext)
				{
					DebugLocation(371, 28);
					adaptor.AddChild(root_1, stream_ruleActions.NextTree());

				}
				stream_ruleActions.Reset();
				DebugLocation(371, 41);
				// Grammars\\ANTLR.g3:371:41: ( ACTION )?
				if (stream_ACTION.HasNext)
				{
					DebugLocation(371, 41);
					adaptor.AddChild(root_1, stream_ACTION.NextNode());

				}
				stream_ACTION.Reset();
				DebugLocation(371, 49);
				if (!(stream_alternative.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_alternative.HasNext )
				{
					DebugLocation(371, 49);
					adaptor.AddChild(root_1, stream_alternative.NextTree());

				}
				stream_alternative.Reset();
				DebugLocation(371, 62);
				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOB, rp, "<end-of-block>"));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block", 22);
			LeaveRule("block", 22);
			LeaveRule_block();
			 currentBlockAST = save; 
		}
		DebugLocation(372, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();
	// $ANTLR start "alternative"
	// Grammars\\ANTLR.g3:376:1: alternative : ( ( element )+ -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] ) | -> ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] ) );
	[GrammarRule("alternative")]
	private AstParserRuleReturnScope<GrammarAST, IToken> alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 23);
		TraceIn("alternative", 23);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> element86 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(376, 1);
		try
		{
			// Grammars\\ANTLR.g3:377:2: ( ( element )+ -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] ) | -> ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] ) )
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==ACTION||LA41_1==CHAR_LITERAL||LA41_1==FORCED_ACTION||LA41_1==LPAREN||LA41_1==NOT||LA41_1==RULE_REF||LA41_1==SEMPRED||LA41_1==STRING_LITERAL||LA41_1==TOKEN_REF||LA41_1==TREE_BEGIN||LA41_1==WILDCARD))
			{
				alt41 = 1;
			}
			else if ((LA41_1==OR||LA41_1==REWRITE||LA41_1==RPAREN||LA41_1==SEMI))
			{
				alt41 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:377:4: ( element )+
				{
				DebugLocation(377, 4);
				// Grammars\\ANTLR.g3:377:4: ( element )+
				int cnt40=0;
				try { DebugEnterSubRule(40);
				while (true)
				{
					int alt40=2;
					try { DebugEnterDecision(40, false);
					int LA40_1 = input.LA(1);

					if ((LA40_1==ACTION||LA40_1==CHAR_LITERAL||LA40_1==FORCED_ACTION||LA40_1==LPAREN||LA40_1==NOT||LA40_1==RULE_REF||LA40_1==SEMPRED||LA40_1==STRING_LITERAL||LA40_1==TOKEN_REF||LA40_1==TREE_BEGIN||LA40_1==WILDCARD))
					{
						alt40 = 1;
					}


					} finally { DebugExitDecision(40); }
					switch (alt40)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:377:4: element
						{
						DebugLocation(377, 4);
						PushFollow(Follow._element_in_alternative1497);
						element86=element();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_element.Add(element86.Tree);

						}
						break;

					default:
						if (cnt40 >= 1)
							goto loop40;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee40 = new EarlyExitException( 40, input );
						DebugRecognitionException(eee40);
						throw eee40;
					}
					cnt40++;
				}
				loop40:
					;

				} finally { DebugExitSubRule(40); }



				{
				// AST REWRITE
				// elements: element
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 378:3: -> ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] )
				{
					DebugLocation(378, 6);
					// Grammars\\ANTLR.g3:378:6: ^( ALT[$start,\"ALT\"] ( element )+ EOA[input.LT(-1),\"<end-of-alt>\"] )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(378, 8);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, retval.Start, "ALT"), root_1);

					DebugLocation(378, 26);
					if (!(stream_element.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_element.HasNext )
					{
						DebugLocation(378, 26);
						adaptor.AddChild(root_1, stream_element.NextTree());

					}
					stream_element.Reset();
					DebugLocation(378, 35);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, input.LT(-1), "<end-of-alt>"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:380:3: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 380:3: -> ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] )
				{
					DebugLocation(380, 6);
					// Grammars\\ANTLR.g3:380:6: ^( ALT[$start,\"ALT\"] EPSILON[input.LT(-1),\"epsilon\"] EOA[input.LT(-1),\"<end-of-alt>\"] )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(380, 8);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, retval.Start, "ALT"), root_1);

					DebugLocation(380, 26);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, input.LT(-1), "epsilon"));
					DebugLocation(380, 58);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, input.LT(-1), "<end-of-alt>"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("alternative", 23);
			LeaveRule("alternative", 23);
			LeaveRule_alternative();
		}
		DebugLocation(381, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return retval;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_exceptionGroup();
	partial void LeaveRule_exceptionGroup();
	// $ANTLR start "exceptionGroup"
	// Grammars\\ANTLR.g3:383:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
	[GrammarRule("exceptionGroup")]
	private AstParserRuleReturnScope<GrammarAST, IToken> exceptionGroup()
	{
		EnterRule_exceptionGroup();
		EnterRule("exceptionGroup", 24);
		TraceIn("exceptionGroup", 24);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> exceptionHandler87 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> finallyClause88 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> finallyClause89 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "exceptionGroup");
		DebugLocation(383, 1);
		try
		{
			// Grammars\\ANTLR.g3:384:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
			int alt44=2;
			try { DebugEnterDecision(44, false);
			int LA44_1 = input.LA(1);

			if ((LA44_1==CATCH))
			{
				alt44 = 1;
			}
			else if ((LA44_1==FINALLY))
			{
				alt44 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:384:4: ( exceptionHandler )+ ( finallyClause )?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(384, 4);
				// Grammars\\ANTLR.g3:384:4: ( exceptionHandler )+
				int cnt42=0;
				try { DebugEnterSubRule(42);
				while (true)
				{
					int alt42=2;
					try { DebugEnterDecision(42, false);
					int LA42_1 = input.LA(1);

					if ((LA42_1==CATCH))
					{
						alt42 = 1;
					}


					} finally { DebugExitDecision(42); }
					switch (alt42)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:384:4: exceptionHandler
						{
						DebugLocation(384, 4);
						PushFollow(Follow._exceptionHandler_in_exceptionGroup1543);
						exceptionHandler87=exceptionHandler();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, exceptionHandler87.Tree);

						}
						break;

					default:
						if (cnt42 >= 1)
							goto loop42;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee42 = new EarlyExitException( 42, input );
						DebugRecognitionException(eee42);
						throw eee42;
					}
					cnt42++;
				}
				loop42:
					;

				} finally { DebugExitSubRule(42); }

				DebugLocation(384, 22);
				// Grammars\\ANTLR.g3:384:22: ( finallyClause )?
				int alt43=2;
				try { DebugEnterSubRule(43);
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==FINALLY))
				{
					alt43 = 1;
				}
				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:384:22: finallyClause
					{
					DebugLocation(384, 22);
					PushFollow(Follow._finallyClause_in_exceptionGroup1546);
					finallyClause88=finallyClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause88.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(43); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:385:4: finallyClause
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(385, 4);
				PushFollow(Follow._finallyClause_in_exceptionGroup1552);
				finallyClause89=finallyClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, finallyClause89.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exceptionGroup", 24);
			LeaveRule("exceptionGroup", 24);
			LeaveRule_exceptionGroup();
		}
		DebugLocation(386, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionGroup"); }
		return retval;

	}
	// $ANTLR end "exceptionGroup"

	partial void EnterRule_exceptionHandler();
	partial void LeaveRule_exceptionHandler();
	// $ANTLR start "exceptionHandler"
	// Grammars\\ANTLR.g3:388:1: exceptionHandler : 'catch' ^ ARG_ACTION ACTION ;
	[GrammarRule("exceptionHandler")]
	private AstParserRuleReturnScope<GrammarAST, IToken> exceptionHandler()
	{
		EnterRule_exceptionHandler();
		EnterRule("exceptionHandler", 25);
		TraceIn("exceptionHandler", 25);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal90 = default(IToken);
		IToken ARG_ACTION91 = default(IToken);
		IToken ACTION92 = default(IToken);

		GrammarAST string_literal90_tree = default(GrammarAST);
		GrammarAST ARG_ACTION91_tree = default(GrammarAST);
		GrammarAST ACTION92_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "exceptionHandler");
		DebugLocation(388, 1);
		try
		{
			// Grammars\\ANTLR.g3:389:2: ( 'catch' ^ ARG_ACTION ACTION )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:389:4: 'catch' ^ ARG_ACTION ACTION
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(389, 11);
			string_literal90=(IToken)Match(input,CATCH,Follow._CATCH_in_exceptionHandler1563); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal90_tree = (GrammarAST)adaptor.Create(string_literal90);
			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal90_tree, root_0);
			}
			DebugLocation(389, 13);
			ARG_ACTION91=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler1566); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ARG_ACTION91_tree = (GrammarAST)adaptor.Create(ARG_ACTION91);
			adaptor.AddChild(root_0, ARG_ACTION91_tree);
			}
			DebugLocation(389, 24);
			ACTION92=(IToken)Match(input,ACTION,Follow._ACTION_in_exceptionHandler1568); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION92_tree = (GrammarAST)adaptor.Create(ACTION92);
			adaptor.AddChild(root_0, ACTION92_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("exceptionHandler", 25);
			LeaveRule("exceptionHandler", 25);
			LeaveRule_exceptionHandler();
		}
		DebugLocation(390, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionHandler"); }
		return retval;

	}
	// $ANTLR end "exceptionHandler"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// Grammars\\ANTLR.g3:392:1: finallyClause : 'finally' ^ ACTION ;
	[GrammarRule("finallyClause")]
	private AstParserRuleReturnScope<GrammarAST, IToken> finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 26);
		TraceIn("finallyClause", 26);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken string_literal93 = default(IToken);
		IToken ACTION94 = default(IToken);

		GrammarAST string_literal93_tree = default(GrammarAST);
		GrammarAST ACTION94_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(392, 1);
		try
		{
			// Grammars\\ANTLR.g3:393:2: ( 'finally' ^ ACTION )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:393:4: 'finally' ^ ACTION
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(393, 13);
			string_literal93=(IToken)Match(input,FINALLY,Follow._FINALLY_in_finallyClause1579); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal93_tree = (GrammarAST)adaptor.Create(string_literal93);
			root_0 = (GrammarAST)adaptor.BecomeRoot(string_literal93_tree, root_0);
			}
			DebugLocation(393, 15);
			ACTION94=(IToken)Match(input,ACTION,Follow._ACTION_in_finallyClause1582); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION94_tree = (GrammarAST)adaptor.Create(ACTION94);
			adaptor.AddChild(root_0, ACTION94_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyClause", 26);
			LeaveRule("finallyClause", 26);
			LeaveRule_finallyClause();
		}
		DebugLocation(394, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return retval;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// Grammars\\ANTLR.g3:396:1: element : elementNoOptionSpec ;
	[GrammarRule("element")]
	private AstParserRuleReturnScope<GrammarAST, IToken> element()
	{
		EnterRule_element();
		EnterRule("element", 27);
		TraceIn("element", 27);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> elementNoOptionSpec95 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(396, 1);
		try
		{
			// Grammars\\ANTLR.g3:397:2: ( elementNoOptionSpec )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:397:4: elementNoOptionSpec
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(397, 4);
			PushFollow(Follow._elementNoOptionSpec_in_element1593);
			elementNoOptionSpec95=elementNoOptionSpec();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, elementNoOptionSpec95.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("element", 27);
			LeaveRule("element", 27);
			LeaveRule_element();
		}
		DebugLocation(398, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return retval;

	}
	// $ANTLR end "element"

	partial void EnterRule_elementNoOptionSpec();
	partial void LeaveRule_elementNoOptionSpec();
	// $ANTLR start "elementNoOptionSpec"
	// Grammars\\ANTLR.g3:400:1: elementNoOptionSpec : ( ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom ( ebnfSuffix[root_0,false] !)? | ebnf ) ) | atom ( ebnfSuffix[$atom.tree,false] !)? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES !)? |t3= tree_ );
	[GrammarRule("elementNoOptionSpec")]
	private AstParserRuleReturnScope<GrammarAST, IToken> elementNoOptionSpec()
	{
		EnterRule_elementNoOptionSpec();
		EnterRule("elementNoOptionSpec", 28);
		TraceIn("elementNoOptionSpec", 28);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken p = default(IToken);
		IToken ASSIGN97 = default(IToken);
		IToken PLUS_ASSIGN98 = default(IToken);
		IToken FORCED_ACTION105 = default(IToken);
		IToken ACTION106 = default(IToken);
		IToken IMPLIES107 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> t3 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> id96 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> atom99 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ebnfSuffix100 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ebnf101 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> atom102 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ebnfSuffix103 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ebnf104 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST p_tree = default(GrammarAST);
		GrammarAST ASSIGN97_tree = default(GrammarAST);
		GrammarAST PLUS_ASSIGN98_tree = default(GrammarAST);
		GrammarAST FORCED_ACTION105_tree = default(GrammarAST);
		GrammarAST ACTION106_tree = default(GrammarAST);
		GrammarAST IMPLIES107_tree = default(GrammarAST);

			IntSet elements=null;

		try { DebugEnterRule(GrammarFileName, "elementNoOptionSpec");
		DebugLocation(400, 1);
		try
		{
			// Grammars\\ANTLR.g3:405:2: ( ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom ( ebnfSuffix[root_0,false] !)? | ebnf ) ) | atom ( ebnfSuffix[$atom.tree,false] !)? | ebnf | FORCED_ACTION | ACTION |p= SEMPRED ( IMPLIES !)? |t3= tree_ )
			int alt50=7;
			try { DebugEnterDecision(50, false);
			switch (input.LA(1))
			{
			case TOKEN_REF:
				{
				int LA50_2 = input.LA(2);

				if ((LA50_2==ACTION||LA50_2==ARG_ACTION||LA50_2==BANG||LA50_2==CHAR_LITERAL||LA50_2==FORCED_ACTION||LA50_2==LPAREN||(LA50_2>=NOT && LA50_2<=OPEN_ELEMENT_OPTION)||LA50_2==OR||LA50_2==PLUS||(LA50_2>=QUESTION && LA50_2<=RANGE)||LA50_2==REWRITE||(LA50_2>=ROOT && LA50_2<=RPAREN)||LA50_2==RULE_REF||(LA50_2>=SEMI && LA50_2<=SEMPRED)||LA50_2==STAR||LA50_2==STRING_LITERAL||LA50_2==TOKEN_REF||LA50_2==TREE_BEGIN||LA50_2==WILDCARD))
				{
					alt50 = 2;
				}
				else if ((LA50_2==ASSIGN||LA50_2==PLUS_ASSIGN))
				{
					alt50 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RULE_REF:
				{
				int LA50_2 = input.LA(2);

				if ((LA50_2==ASSIGN||LA50_2==PLUS_ASSIGN))
				{
					alt50 = 1;
				}
				else if ((LA50_2==ACTION||LA50_2==ARG_ACTION||LA50_2==BANG||LA50_2==CHAR_LITERAL||LA50_2==FORCED_ACTION||LA50_2==LPAREN||LA50_2==NOT||LA50_2==OR||LA50_2==PLUS||LA50_2==QUESTION||LA50_2==REWRITE||(LA50_2>=ROOT && LA50_2<=RPAREN)||LA50_2==RULE_REF||(LA50_2>=SEMI && LA50_2<=SEMPRED)||LA50_2==STAR||LA50_2==STRING_LITERAL||LA50_2==TOKEN_REF||LA50_2==TREE_BEGIN||LA50_2==WILDCARD))
				{
					alt50 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CHAR_LITERAL:
			case NOT:
			case STRING_LITERAL:
			case WILDCARD:
				{
				alt50 = 2;
				}
				break;
			case LPAREN:
				{
				alt50 = 3;
				}
				break;
			case FORCED_ACTION:
				{
				alt50 = 4;
				}
				break;
			case ACTION:
				{
				alt50 = 5;
				}
				break;
			case SEMPRED:
				{
				alt50 = 6;
				}
				break;
			case TREE_BEGIN:
				{
				alt50 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:405:4: ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom ( ebnfSuffix[root_0,false] !)? | ebnf ) )
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(405, 4);
				// Grammars\\ANTLR.g3:405:4: ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom ( ebnfSuffix[root_0,false] !)? | ebnf ) )
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:405:6: id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom ( ebnfSuffix[root_0,false] !)? | ebnf )
				{
				DebugLocation(405, 6);
				PushFollow(Follow._id_in_elementNoOptionSpec1611);
				id96=id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, id96.Tree);
				DebugLocation(405, 9);
				// Grammars\\ANTLR.g3:405:9: ( ASSIGN ^| PLUS_ASSIGN ^)
				int alt45=2;
				try { DebugEnterSubRule(45);
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==ASSIGN))
				{
					alt45 = 1;
				}
				else if ((LA45_1==PLUS_ASSIGN))
				{
					alt45 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(45); }
				switch (alt45)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:405:10: ASSIGN ^
					{
					DebugLocation(405, 16);
					ASSIGN97=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_elementNoOptionSpec1614); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ASSIGN97_tree = (GrammarAST)adaptor.Create(ASSIGN97);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN97_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:405:18: PLUS_ASSIGN ^
					{
					DebugLocation(405, 29);
					PLUS_ASSIGN98=(IToken)Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_elementNoOptionSpec1617); if (state.failed) return retval;
					if (state.backtracking == 0) {
					PLUS_ASSIGN98_tree = (GrammarAST)adaptor.Create(PLUS_ASSIGN98);
					root_0 = (GrammarAST)adaptor.BecomeRoot(PLUS_ASSIGN98_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(45); }

				DebugLocation(406, 4);
				// Grammars\\ANTLR.g3:406:4: ( atom ( ebnfSuffix[root_0,false] !)? | ebnf )
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==CHAR_LITERAL||LA47_1==NOT||LA47_1==RULE_REF||LA47_1==STRING_LITERAL||LA47_1==TOKEN_REF||LA47_1==WILDCARD))
				{
					alt47 = 1;
				}
				else if ((LA47_1==LPAREN))
				{
					alt47 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:406:6: atom ( ebnfSuffix[root_0,false] !)?
					{
					DebugLocation(406, 6);
					PushFollow(Follow._atom_in_elementNoOptionSpec1626);
					atom99=atom();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, atom99.Tree);
					DebugLocation(406, 11);
					// Grammars\\ANTLR.g3:406:11: ( ebnfSuffix[root_0,false] !)?
					int alt46=2;
					try { DebugEnterSubRule(46);
					try { DebugEnterDecision(46, false);
					int LA46_1 = input.LA(1);

					if ((LA46_1==PLUS||LA46_1==QUESTION||LA46_1==STAR))
					{
						alt46 = 1;
					}
					} finally { DebugExitDecision(46); }
					switch (alt46)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:406:12: ebnfSuffix[root_0,false] !
						{
						DebugLocation(406, 36);
						PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1629);
						ebnfSuffix100=ebnfSuffix(root_0, false);
						PopFollow();
						if (state.failed) return retval;
						DebugLocation(406, 38);
						if (state.backtracking == 0)
						{
							root_0 = (ebnfSuffix100!=null?((GrammarAST)ebnfSuffix100.Tree):default(GrammarAST));
						}

						}
						break;

					}
					} finally { DebugExitSubRule(46); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:407:6: ebnf
					{
					DebugLocation(407, 6);
					PushFollow(Follow._ebnf_in_elementNoOptionSpec1642);
					ebnf101=ebnf();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, ebnf101.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(47); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:410:4: atom ( ebnfSuffix[$atom.tree,false] !)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(410, 4);
				PushFollow(Follow._atom_in_elementNoOptionSpec1656);
				atom102=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom102.Tree);
				DebugLocation(411, 3);
				// Grammars\\ANTLR.g3:411:3: ( ebnfSuffix[$atom.tree,false] !)?
				int alt48=2;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==PLUS||LA48_1==QUESTION||LA48_1==STAR))
				{
					alt48 = 1;
				}
				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:411:5: ebnfSuffix[$atom.tree,false] !
					{
					DebugLocation(411, 33);
					PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1662);
					ebnfSuffix103=ebnfSuffix((atom102!=null?((GrammarAST)atom102.Tree):default(GrammarAST)), false);
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(411, 35);
					if (state.backtracking == 0)
					{
						root_0 = (ebnfSuffix103!=null?((GrammarAST)ebnfSuffix103.Tree):default(GrammarAST));
					}

					}
					break;

				}
				} finally { DebugExitSubRule(48); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:413:4: ebnf
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(413, 4);
				PushFollow(Follow._ebnf_in_elementNoOptionSpec1676);
				ebnf104=ebnf();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ebnf104.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:414:4: FORCED_ACTION
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(414, 4);
				FORCED_ACTION105=(IToken)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_elementNoOptionSpec1681); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FORCED_ACTION105_tree = (GrammarAST)adaptor.Create(FORCED_ACTION105);
				adaptor.AddChild(root_0, FORCED_ACTION105_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\ANTLR.g3:415:4: ACTION
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(415, 4);
				ACTION106=(IToken)Match(input,ACTION,Follow._ACTION_in_elementNoOptionSpec1686); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ACTION106_tree = (GrammarAST)adaptor.Create(ACTION106);
				adaptor.AddChild(root_0, ACTION106_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\ANTLR.g3:416:4: p= SEMPRED ( IMPLIES !)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(416, 5);
				p=(IToken)Match(input,SEMPRED,Follow._SEMPRED_in_elementNoOptionSpec1693); if (state.failed) return retval;
				if (state.backtracking == 0) {
				p_tree = (GrammarAST)adaptor.Create(p);
				adaptor.AddChild(root_0, p_tree);
				}
				DebugLocation(416, 14);
				// Grammars\\ANTLR.g3:416:14: ( IMPLIES !)?
				int alt49=2;
				try { DebugEnterSubRule(49);
				try { DebugEnterDecision(49, false);
				int LA49_1 = input.LA(1);

				if ((LA49_1==IMPLIES))
				{
					alt49 = 1;
				}
				} finally { DebugExitDecision(49); }
				switch (alt49)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:416:16: IMPLIES !
					{
					DebugLocation(416, 23);
					IMPLIES107=(IToken)Match(input,IMPLIES,Follow._IMPLIES_in_elementNoOptionSpec1697); if (state.failed) return retval;
					DebugLocation(416, 25);
					if (state.backtracking == 0)
					{
						p.Type = GATED_SEMPRED;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(49); }

				DebugLocation(417, 3);
				if (state.backtracking == 0)
				{

							Grammar.blocksWithSemPreds.Add(currentBlockAST);
							
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\ANTLR.g3:420:4: t3= tree_
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(420, 6);
				PushFollow(Follow._tree__in_elementNoOptionSpec1714);
				t3=tree_();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, t3.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elementNoOptionSpec", 28);
			LeaveRule("elementNoOptionSpec", 28);
			LeaveRule_elementNoOptionSpec();
		}
		DebugLocation(421, 1);
		} finally { DebugExitRule(GrammarFileName, "elementNoOptionSpec"); }
		return retval;

	}
	// $ANTLR end "elementNoOptionSpec"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\ANTLR.g3:423:1: atom : ( range ( ROOT ^| BANG ^)? | ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT ^| BANG ^)? );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<GrammarAST, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 29);
		TraceIn("atom", 29);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ROOT109 = default(IToken);
		IToken BANG110 = default(IToken);
		IToken WILDCARD112 = default(IToken);
		IToken ROOT118 = default(IToken);
		IToken BANG119 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> range108 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> id111 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> terminal113 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleref114 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> terminal115 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ruleref116 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> notSet117 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ROOT109_tree = default(GrammarAST);
		GrammarAST BANG110_tree = default(GrammarAST);
		GrammarAST WILDCARD112_tree = default(GrammarAST);
		GrammarAST ROOT118_tree = default(GrammarAST);
		GrammarAST BANG119_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(423, 1);
		try
		{
			// Grammars\\ANTLR.g3:424:2: ( range ( ROOT ^| BANG ^)? | ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref ) | notSet ( ROOT ^| BANG ^)? )
			int alt55=3;
			try { DebugEnterDecision(55, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				int LA55_2 = input.LA(2);

				if ((LA55_2==RANGE))
				{
					alt55 = 1;
				}
				else if ((LA55_2==ACTION||LA55_2==BANG||LA55_2==CHAR_LITERAL||LA55_2==FORCED_ACTION||LA55_2==LPAREN||(LA55_2>=NOT && LA55_2<=OPEN_ELEMENT_OPTION)||LA55_2==OR||LA55_2==PLUS||LA55_2==QUESTION||LA55_2==REWRITE||(LA55_2>=ROOT && LA55_2<=RPAREN)||LA55_2==RULE_REF||(LA55_2>=SEMI && LA55_2<=SEMPRED)||LA55_2==STAR||LA55_2==STRING_LITERAL||LA55_2==TOKEN_REF||LA55_2==TREE_BEGIN||LA55_2==WILDCARD))
				{
					alt55 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case TOKEN_REF:
				{
				int LA55_2 = input.LA(2);

				if ((LA55_2==RANGE))
				{
					alt55 = 1;
				}
				else if ((LA55_2==ACTION||LA55_2==ARG_ACTION||LA55_2==BANG||LA55_2==CHAR_LITERAL||LA55_2==FORCED_ACTION||LA55_2==LPAREN||(LA55_2>=NOT && LA55_2<=OPEN_ELEMENT_OPTION)||LA55_2==OR||LA55_2==PLUS||LA55_2==QUESTION||LA55_2==REWRITE||(LA55_2>=ROOT && LA55_2<=RPAREN)||LA55_2==RULE_REF||(LA55_2>=SEMI && LA55_2<=SEMPRED)||LA55_2==STAR||LA55_2==STRING_LITERAL||LA55_2==TOKEN_REF||LA55_2==TREE_BEGIN||LA55_2==WILDCARD))
				{
					alt55 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case STRING_LITERAL:
				{
				int LA55_2 = input.LA(2);

				if ((LA55_2==RANGE))
				{
					alt55 = 1;
				}
				else if ((LA55_2==ACTION||LA55_2==BANG||LA55_2==CHAR_LITERAL||LA55_2==FORCED_ACTION||LA55_2==LPAREN||(LA55_2>=NOT && LA55_2<=OPEN_ELEMENT_OPTION)||LA55_2==OR||LA55_2==PLUS||LA55_2==QUESTION||LA55_2==REWRITE||(LA55_2>=ROOT && LA55_2<=RPAREN)||LA55_2==RULE_REF||(LA55_2>=SEMI && LA55_2<=SEMPRED)||LA55_2==STAR||LA55_2==STRING_LITERAL||LA55_2==TOKEN_REF||LA55_2==TREE_BEGIN||LA55_2==WILDCARD))
				{
					alt55 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RULE_REF:
			case WILDCARD:
				{
				alt55 = 2;
				}
				break;
			case NOT:
				{
				alt55 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:424:4: range ( ROOT ^| BANG ^)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(424, 4);
				PushFollow(Follow._range_in_atom1725);
				range108=range();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, range108.Tree);
				DebugLocation(424, 10);
				// Grammars\\ANTLR.g3:424:10: ( ROOT ^| BANG ^)?
				int alt51=3;
				try { DebugEnterSubRule(51);
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==ROOT))
				{
					alt51 = 1;
				}
				else if ((LA51_1==BANG))
				{
					alt51 = 2;
				}
				} finally { DebugExitDecision(51); }
				switch (alt51)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:424:11: ROOT ^
					{
					DebugLocation(424, 15);
					ROOT109=(IToken)Match(input,ROOT,Follow._ROOT_in_atom1728); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ROOT109_tree = (GrammarAST)adaptor.Create(ROOT109);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT109_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:424:17: BANG ^
					{
					DebugLocation(424, 21);
					BANG110=(IToken)Match(input,BANG,Follow._BANG_in_atom1731); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BANG110_tree = (GrammarAST)adaptor.Create(BANG110);
					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG110_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(51); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:425:4: ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref )
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(425, 4);
				// Grammars\\ANTLR.g3:425:4: ( ({...}? id WILDCARD ( terminal | ruleref ) )=> id WILDCARD ^ ( terminal | ruleref ) | terminal | ruleref )
				int alt53=3;
				try { DebugEnterSubRule(53);
				try { DebugEnterDecision(53, false);
				switch (input.LA(1))
				{
				case TOKEN_REF:
					{
					int LA53_2 = input.LA(2);

					if ((LA53_2==WILDCARD))
					{
						switch (input.LA(3))
						{
						case CHAR_LITERAL:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 7, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case TOKEN_REF:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 8, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case STRING_LITERAL:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 9, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case WILDCARD:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 10, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case RULE_REF:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 2;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 11, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case ACTION:
						case BANG:
						case FORCED_ACTION:
						case LPAREN:
						case NOT:
						case OR:
						case PLUS:
						case QUESTION:
						case REWRITE:
						case ROOT:
						case RPAREN:
						case SEMI:
						case SEMPRED:
						case STAR:
						case TREE_BEGIN:
							{
							alt53 = 2;
							}
							break;
						default:
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 4, input, 3);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					}
					else if ((LA53_2==ACTION||LA53_2==ARG_ACTION||LA53_2==BANG||LA53_2==CHAR_LITERAL||LA53_2==FORCED_ACTION||LA53_2==LPAREN||(LA53_2>=NOT && LA53_2<=OPEN_ELEMENT_OPTION)||LA53_2==OR||LA53_2==PLUS||LA53_2==QUESTION||LA53_2==REWRITE||(LA53_2>=ROOT && LA53_2<=RPAREN)||LA53_2==RULE_REF||(LA53_2>=SEMI && LA53_2<=SEMPRED)||LA53_2==STAR||LA53_2==STRING_LITERAL||LA53_2==TOKEN_REF||LA53_2==TREE_BEGIN))
					{
						alt53 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 53, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case RULE_REF:
					{
					int LA53_2 = input.LA(2);

					if ((LA53_2==WILDCARD))
					{
						switch (input.LA(3))
						{
						case CHAR_LITERAL:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 3;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 12, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case TOKEN_REF:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 3;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 13, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case STRING_LITERAL:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 3;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 14, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case WILDCARD:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 3;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 15, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case RULE_REF:
							{
							int LA53_4 = input.LA(4);

							if ((EvaluatePredicate(synpred1_ANTLR_fragment)))
							{
								alt53 = 1;
							}
							else if ((true))
							{
								alt53 = 3;
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 16, input, 4);
								DebugRecognitionException(nvae);
								throw nvae;
							}
							}
							break;
						case ACTION:
						case BANG:
						case FORCED_ACTION:
						case LPAREN:
						case NOT:
						case OR:
						case PLUS:
						case QUESTION:
						case REWRITE:
						case ROOT:
						case RPAREN:
						case SEMI:
						case SEMPRED:
						case STAR:
						case TREE_BEGIN:
							{
							alt53 = 3;
							}
							break;
						default:
							{
								if (state.backtracking>0) {state.failed=true; return retval;}
								NoViableAltException nvae = new NoViableAltException("", 53, 5, input, 3);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					}
					else if ((LA53_2==ACTION||LA53_2==ARG_ACTION||LA53_2==BANG||LA53_2==CHAR_LITERAL||LA53_2==FORCED_ACTION||LA53_2==LPAREN||LA53_2==NOT||LA53_2==OR||LA53_2==PLUS||LA53_2==QUESTION||LA53_2==REWRITE||(LA53_2>=ROOT && LA53_2<=RPAREN)||LA53_2==RULE_REF||(LA53_2>=SEMI && LA53_2<=SEMPRED)||LA53_2==STAR||LA53_2==STRING_LITERAL||LA53_2==TOKEN_REF||LA53_2==TREE_BEGIN))
					{
						alt53 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 53, 2, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case CHAR_LITERAL:
				case STRING_LITERAL:
				case WILDCARD:
					{
					alt53 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(53); }
				switch (alt53)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:428:4: ({...}? id WILDCARD ( terminal | ruleref ) )=> id WILDCARD ^ ( terminal | ruleref )
					{
					DebugLocation(430, 4);
					PushFollow(Follow._id_in_atom1771);
					id111=id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, id111.Tree);
					DebugLocation(430, 15);
					WILDCARD112=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_atom1773); if (state.failed) return retval;
					if (state.backtracking == 0) {
					WILDCARD112_tree = (GrammarAST)adaptor.Create(WILDCARD112);
					root_0 = (GrammarAST)adaptor.BecomeRoot(WILDCARD112_tree, root_0);
					}
					DebugLocation(430, 17);
					// Grammars\\ANTLR.g3:430:17: ( terminal | ruleref )
					int alt52=2;
					try { DebugEnterSubRule(52);
					try { DebugEnterDecision(52, false);
					int LA52_1 = input.LA(1);

					if ((LA52_1==CHAR_LITERAL||LA52_1==STRING_LITERAL||LA52_1==TOKEN_REF||LA52_1==WILDCARD))
					{
						alt52 = 1;
					}
					else if ((LA52_1==RULE_REF))
					{
						alt52 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 52, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(52); }
					switch (alt52)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:430:18: terminal
						{
						DebugLocation(430, 18);
						PushFollow(Follow._terminal_in_atom1777);
						terminal113=terminal();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, terminal113.Tree);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\ANTLR.g3:430:27: ruleref
						{
						DebugLocation(430, 27);
						PushFollow(Follow._ruleref_in_atom1779);
						ruleref114=ruleref();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, ruleref114.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(52); }

					DebugLocation(430, 36);
					if (state.backtracking == 0)
					{
						WILDCARD112.Type = DOT;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:431:5: terminal
					{
					DebugLocation(431, 5);
					PushFollow(Follow._terminal_in_atom1788);
					terminal115=terminal();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, terminal115.Tree);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\ANTLR.g3:432:5: ruleref
					{
					DebugLocation(432, 5);
					PushFollow(Follow._ruleref_in_atom1794);
					ruleref116=ruleref();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, ruleref116.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(53); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:434:4: notSet ( ROOT ^| BANG ^)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(434, 4);
				PushFollow(Follow._notSet_in_atom1803);
				notSet117=notSet();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, notSet117.Tree);
				DebugLocation(434, 11);
				// Grammars\\ANTLR.g3:434:11: ( ROOT ^| BANG ^)?
				int alt54=3;
				try { DebugEnterSubRule(54);
				try { DebugEnterDecision(54, false);
				int LA54_1 = input.LA(1);

				if ((LA54_1==ROOT))
				{
					alt54 = 1;
				}
				else if ((LA54_1==BANG))
				{
					alt54 = 2;
				}
				} finally { DebugExitDecision(54); }
				switch (alt54)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:434:12: ROOT ^
					{
					DebugLocation(434, 16);
					ROOT118=(IToken)Match(input,ROOT,Follow._ROOT_in_atom1806); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ROOT118_tree = (GrammarAST)adaptor.Create(ROOT118);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT118_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:434:18: BANG ^
					{
					DebugLocation(434, 22);
					BANG119=(IToken)Match(input,BANG,Follow._BANG_in_atom1809); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BANG119_tree = (GrammarAST)adaptor.Create(BANG119);
					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG119_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(54); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 29);
			LeaveRule("atom", 29);
			LeaveRule_atom();
		}
		DebugLocation(435, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_ruleref();
	partial void LeaveRule_ruleref();
	// $ANTLR start "ruleref"
	// Grammars\\ANTLR.g3:437:1: ruleref : RULE_REF ^ ( ARG_ACTION )? ( ROOT ^| BANG ^)? ;
	[GrammarRule("ruleref")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ruleref()
	{
		EnterRule_ruleref();
		EnterRule("ruleref", 30);
		TraceIn("ruleref", 30);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken RULE_REF120 = default(IToken);
		IToken ARG_ACTION121 = default(IToken);
		IToken ROOT122 = default(IToken);
		IToken BANG123 = default(IToken);

		GrammarAST RULE_REF120_tree = default(GrammarAST);
		GrammarAST ARG_ACTION121_tree = default(GrammarAST);
		GrammarAST ROOT122_tree = default(GrammarAST);
		GrammarAST BANG123_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "ruleref");
		DebugLocation(437, 1);
		try
		{
			// Grammars\\ANTLR.g3:438:2: ( RULE_REF ^ ( ARG_ACTION )? ( ROOT ^| BANG ^)? )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:438:4: RULE_REF ^ ( ARG_ACTION )? ( ROOT ^| BANG ^)?
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(438, 12);
			RULE_REF120=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_ruleref1823); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RULE_REF120_tree = (GrammarAST)adaptor.Create(RULE_REF120);
			root_0 = (GrammarAST)adaptor.BecomeRoot(RULE_REF120_tree, root_0);
			}
			DebugLocation(438, 14);
			// Grammars\\ANTLR.g3:438:14: ( ARG_ACTION )?
			int alt56=2;
			try { DebugEnterSubRule(56);
			try { DebugEnterDecision(56, false);
			int LA56_1 = input.LA(1);

			if ((LA56_1==ARG_ACTION))
			{
				alt56 = 1;
			}
			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:438:14: ARG_ACTION
				{
				DebugLocation(438, 14);
				ARG_ACTION121=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_ruleref1826); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ARG_ACTION121_tree = (GrammarAST)adaptor.Create(ARG_ACTION121);
				adaptor.AddChild(root_0, ARG_ACTION121_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(56); }

			DebugLocation(438, 26);
			// Grammars\\ANTLR.g3:438:26: ( ROOT ^| BANG ^)?
			int alt57=3;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			int LA57_1 = input.LA(1);

			if ((LA57_1==ROOT))
			{
				alt57 = 1;
			}
			else if ((LA57_1==BANG))
			{
				alt57 = 2;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:438:27: ROOT ^
				{
				DebugLocation(438, 31);
				ROOT122=(IToken)Match(input,ROOT,Follow._ROOT_in_ruleref1830); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ROOT122_tree = (GrammarAST)adaptor.Create(ROOT122);
				root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT122_tree, root_0);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:438:33: BANG ^
				{
				DebugLocation(438, 37);
				BANG123=(IToken)Match(input,BANG,Follow._BANG_in_ruleref1833); if (state.failed) return retval;
				if (state.backtracking == 0) {
				BANG123_tree = (GrammarAST)adaptor.Create(BANG123);
				root_0 = (GrammarAST)adaptor.BecomeRoot(BANG123_tree, root_0);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(57); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ruleref", 30);
			LeaveRule("ruleref", 30);
			LeaveRule_ruleref();
		}
		DebugLocation(439, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleref"); }
		return retval;

	}
	// $ANTLR end "ruleref"

	partial void EnterRule_notSet();
	partial void LeaveRule_notSet();
	// $ANTLR start "notSet"
	// Grammars\\ANTLR.g3:441:1: notSet : NOT ^ ( notTerminal | block ) ;
	[GrammarRule("notSet")]
	private AstParserRuleReturnScope<GrammarAST, IToken> notSet()
	{
		EnterRule_notSet();
		EnterRule("notSet", 31);
		TraceIn("notSet", 31);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken NOT124 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> notTerminal125 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> block126 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST NOT124_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "notSet");
		DebugLocation(441, 1);
		try
		{
			// Grammars\\ANTLR.g3:442:2: ( NOT ^ ( notTerminal | block ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:442:4: NOT ^ ( notTerminal | block )
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(442, 7);
			NOT124=(IToken)Match(input,NOT,Follow._NOT_in_notSet1847); if (state.failed) return retval;
			if (state.backtracking == 0) {
			NOT124_tree = (GrammarAST)adaptor.Create(NOT124);
			root_0 = (GrammarAST)adaptor.BecomeRoot(NOT124_tree, root_0);
			}
			DebugLocation(443, 3);
			// Grammars\\ANTLR.g3:443:3: ( notTerminal | block )
			int alt58=2;
			try { DebugEnterSubRule(58);
			try { DebugEnterDecision(58, false);
			int LA58_1 = input.LA(1);

			if ((LA58_1==CHAR_LITERAL||LA58_1==STRING_LITERAL||LA58_1==TOKEN_REF))
			{
				alt58 = 1;
			}
			else if ((LA58_1==LPAREN))
			{
				alt58 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:443:5: notTerminal
				{
				DebugLocation(443, 5);
				PushFollow(Follow._notTerminal_in_notSet1854);
				notTerminal125=notTerminal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, notTerminal125.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:444:5: block
				{
				DebugLocation(444, 5);
				PushFollow(Follow._block_in_notSet1860);
				block126=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block126.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(58); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("notSet", 31);
			LeaveRule("notSet", 31);
			LeaveRule_notSet();
		}
		DebugLocation(446, 1);
		} finally { DebugExitRule(GrammarFileName, "notSet"); }
		return retval;

	}
	// $ANTLR end "notSet"

	partial void EnterRule_treeRoot();
	partial void LeaveRule_treeRoot();
	// $ANTLR start "treeRoot"
	// Grammars\\ANTLR.g3:448:1: treeRoot : ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom | block ) | atom | block );
	[GrammarRule("treeRoot")]
	private AstParserRuleReturnScope<GrammarAST, IToken> treeRoot()
	{
		EnterRule_treeRoot();
		EnterRule("treeRoot", 32);
		TraceIn("treeRoot", 32);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ASSIGN128 = default(IToken);
		IToken PLUS_ASSIGN129 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id127 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> atom130 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> block131 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> atom132 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> block133 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ASSIGN128_tree = default(GrammarAST);
		GrammarAST PLUS_ASSIGN129_tree = default(GrammarAST);
		atTreeRoot=true;
		try { DebugEnterRule(GrammarFileName, "treeRoot");
		DebugLocation(448, 1);
		try
		{
			// Grammars\\ANTLR.g3:451:2: ( id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom | block ) | atom | block )
			int alt61=3;
			try { DebugEnterDecision(61, false);
			switch (input.LA(1))
			{
			case TOKEN_REF:
				{
				int LA61_2 = input.LA(2);

				if ((LA61_2==ACTION||LA61_2==ARG_ACTION||LA61_2==BANG||LA61_2==CHAR_LITERAL||LA61_2==FORCED_ACTION||LA61_2==LPAREN||(LA61_2>=NOT && LA61_2<=OPEN_ELEMENT_OPTION)||LA61_2==RANGE||LA61_2==ROOT||LA61_2==RULE_REF||LA61_2==SEMPRED||LA61_2==STRING_LITERAL||LA61_2==TOKEN_REF||LA61_2==TREE_BEGIN||LA61_2==WILDCARD))
				{
					alt61 = 2;
				}
				else if ((LA61_2==ASSIGN||LA61_2==PLUS_ASSIGN))
				{
					alt61 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 61, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RULE_REF:
				{
				int LA61_2 = input.LA(2);

				if ((LA61_2==ASSIGN||LA61_2==PLUS_ASSIGN))
				{
					alt61 = 1;
				}
				else if ((LA61_2==ACTION||LA61_2==ARG_ACTION||LA61_2==BANG||LA61_2==CHAR_LITERAL||LA61_2==FORCED_ACTION||LA61_2==LPAREN||LA61_2==NOT||LA61_2==ROOT||LA61_2==RULE_REF||LA61_2==SEMPRED||LA61_2==STRING_LITERAL||LA61_2==TOKEN_REF||LA61_2==TREE_BEGIN||LA61_2==WILDCARD))
				{
					alt61 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 61, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CHAR_LITERAL:
			case NOT:
			case STRING_LITERAL:
			case WILDCARD:
				{
				alt61 = 2;
				}
				break;
			case LPAREN:
				{
				alt61 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 61, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:451:4: id ( ASSIGN ^| PLUS_ASSIGN ^) ( atom | block )
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(451, 4);
				PushFollow(Follow._id_in_treeRoot1883);
				id127=id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, id127.Tree);
				DebugLocation(451, 7);
				// Grammars\\ANTLR.g3:451:7: ( ASSIGN ^| PLUS_ASSIGN ^)
				int alt59=2;
				try { DebugEnterSubRule(59);
				try { DebugEnterDecision(59, false);
				int LA59_1 = input.LA(1);

				if ((LA59_1==ASSIGN))
				{
					alt59 = 1;
				}
				else if ((LA59_1==PLUS_ASSIGN))
				{
					alt59 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 59, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(59); }
				switch (alt59)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:451:8: ASSIGN ^
					{
					DebugLocation(451, 14);
					ASSIGN128=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_treeRoot1886); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ASSIGN128_tree = (GrammarAST)adaptor.Create(ASSIGN128);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN128_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:451:16: PLUS_ASSIGN ^
					{
					DebugLocation(451, 27);
					PLUS_ASSIGN129=(IToken)Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_treeRoot1889); if (state.failed) return retval;
					if (state.backtracking == 0) {
					PLUS_ASSIGN129_tree = (GrammarAST)adaptor.Create(PLUS_ASSIGN129);
					root_0 = (GrammarAST)adaptor.BecomeRoot(PLUS_ASSIGN129_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(59); }

				DebugLocation(451, 30);
				// Grammars\\ANTLR.g3:451:30: ( atom | block )
				int alt60=2;
				try { DebugEnterSubRule(60);
				try { DebugEnterDecision(60, false);
				int LA60_1 = input.LA(1);

				if ((LA60_1==CHAR_LITERAL||LA60_1==NOT||LA60_1==RULE_REF||LA60_1==STRING_LITERAL||LA60_1==TOKEN_REF||LA60_1==WILDCARD))
				{
					alt60 = 1;
				}
				else if ((LA60_1==LPAREN))
				{
					alt60 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:451:31: atom
					{
					DebugLocation(451, 31);
					PushFollow(Follow._atom_in_treeRoot1894);
					atom130=atom();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, atom130.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:451:36: block
					{
					DebugLocation(451, 36);
					PushFollow(Follow._block_in_treeRoot1896);
					block131=block();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, block131.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(60); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:452:4: atom
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(452, 4);
				PushFollow(Follow._atom_in_treeRoot1902);
				atom132=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom132.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:453:4: block
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(453, 4);
				PushFollow(Follow._block_in_treeRoot1907);
				block133=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block133.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{
				atTreeRoot=false;
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("treeRoot", 32);
			LeaveRule("treeRoot", 32);
			LeaveRule_treeRoot();
		}
		DebugLocation(454, 1);
		} finally { DebugExitRule(GrammarFileName, "treeRoot"); }
		return retval;

	}
	// $ANTLR end "treeRoot"

	partial void EnterRule_tree_();
	partial void LeaveRule_tree_();
	// $ANTLR start "tree_"
	// Grammars\\ANTLR.g3:456:1: tree_ : TREE_BEGIN ^ treeRoot ( element )+ RPAREN !;
	[GrammarRule("tree_")]
	private AstParserRuleReturnScope<GrammarAST, IToken> tree_()
	{
		EnterRule_tree_();
		EnterRule("tree_", 33);
		TraceIn("tree_", 33);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TREE_BEGIN134 = default(IToken);
		IToken RPAREN137 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> treeRoot135 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> element136 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST TREE_BEGIN134_tree = default(GrammarAST);
		GrammarAST RPAREN137_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "tree_");
		DebugLocation(456, 1);
		try
		{
			// Grammars\\ANTLR.g3:457:2: ( TREE_BEGIN ^ treeRoot ( element )+ RPAREN !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:457:4: TREE_BEGIN ^ treeRoot ( element )+ RPAREN !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(457, 14);
			TREE_BEGIN134=(IToken)Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1918); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TREE_BEGIN134_tree = (GrammarAST)adaptor.Create(TREE_BEGIN134);
			root_0 = (GrammarAST)adaptor.BecomeRoot(TREE_BEGIN134_tree, root_0);
			}
			DebugLocation(458, 3);
			PushFollow(Follow._treeRoot_in_tree_1923);
			treeRoot135=treeRoot();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, treeRoot135.Tree);
			DebugLocation(458, 12);
			// Grammars\\ANTLR.g3:458:12: ( element )+
			int cnt62=0;
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_1 = input.LA(1);

				if ((LA62_1==ACTION||LA62_1==CHAR_LITERAL||LA62_1==FORCED_ACTION||LA62_1==LPAREN||LA62_1==NOT||LA62_1==RULE_REF||LA62_1==SEMPRED||LA62_1==STRING_LITERAL||LA62_1==TOKEN_REF||LA62_1==TREE_BEGIN||LA62_1==WILDCARD))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch (alt62)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:458:12: element
					{
					DebugLocation(458, 12);
					PushFollow(Follow._element_in_tree_1925);
					element136=element();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, element136.Tree);

					}
					break;

				default:
					if (cnt62 >= 1)
						goto loop62;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee62 = new EarlyExitException( 62, input );
					DebugRecognitionException(eee62);
					throw eee62;
				}
				cnt62++;
			}
			loop62:
				;

			} finally { DebugExitSubRule(62); }

			DebugLocation(459, 9);
			RPAREN137=(IToken)Match(input,RPAREN,Follow._RPAREN_in_tree_1930); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tree_", 33);
			LeaveRule("tree_", 33);
			LeaveRule_tree_();
		}
		DebugLocation(460, 1);
		} finally { DebugExitRule(GrammarFileName, "tree_"); }
		return retval;

	}
	// $ANTLR end "tree_"

	partial void EnterRule_ebnf();
	partial void LeaveRule_ebnf();
	// $ANTLR start "ebnf"
	// Grammars\\ANTLR.g3:463:1: ebnf : block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) ;
	[GrammarRule("ebnf")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ebnf()
	{
		EnterRule_ebnf();
		EnterRule("ebnf", 34);
		TraceIn("ebnf", 34);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken QUESTION139 = default(IToken);
		IToken STAR140 = default(IToken);
		IToken PLUS141 = default(IToken);
		IToken IMPLIES142 = default(IToken);
		IToken ROOT143 = default(IToken);
		IToken BANG144 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> block138 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST QUESTION139_tree = default(GrammarAST);
		GrammarAST STAR140_tree = default(GrammarAST);
		GrammarAST PLUS141_tree = default(GrammarAST);
		GrammarAST IMPLIES142_tree = default(GrammarAST);
		GrammarAST ROOT143_tree = default(GrammarAST);
		GrammarAST BANG144_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleITokenStream stream_IMPLIES=new RewriteRuleITokenStream(adaptor,"token IMPLIES");
		RewriteRuleITokenStream stream_ROOT=new RewriteRuleITokenStream(adaptor,"token ROOT");
		RewriteRuleITokenStream stream_BANG=new RewriteRuleITokenStream(adaptor,"token BANG");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		try { DebugEnterRule(GrammarFileName, "ebnf");
		DebugLocation(463, 1);
		try
		{
			// Grammars\\ANTLR.g3:464:2: ( block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:464:4: block ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
			{
			DebugLocation(464, 4);
			PushFollow(Follow._block_in_ebnf1944);
			block138=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block.Add(block138.Tree);
			DebugLocation(465, 3);
			// Grammars\\ANTLR.g3:465:3: ( QUESTION -> ^( OPTIONAL[$start,\"?\"] block ) | STAR -> ^( CLOSURE[$start,\"*\"] block ) | PLUS -> ^( POSITIVE_CLOSURE[$start,\"+\"] block ) | IMPLIES -> {GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer}? ^( SYNPRED[$start,\"=>\"] block ) ->| ROOT -> ^( ROOT block ) | BANG -> ^( BANG block ) | -> block )
			int alt63=7;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			switch (input.LA(1))
			{
			case QUESTION:
				{
				alt63 = 1;
				}
				break;
			case STAR:
				{
				alt63 = 2;
				}
				break;
			case PLUS:
				{
				alt63 = 3;
				}
				break;
			case IMPLIES:
				{
				alt63 = 4;
				}
				break;
			case ROOT:
				{
				alt63 = 5;
				}
				break;
			case BANG:
				{
				alt63 = 6;
				}
				break;
			case ACTION:
			case CHAR_LITERAL:
			case FORCED_ACTION:
			case LPAREN:
			case NOT:
			case OR:
			case REWRITE:
			case RPAREN:
			case RULE_REF:
			case SEMI:
			case SEMPRED:
			case STRING_LITERAL:
			case TOKEN_REF:
			case TREE_BEGIN:
			case WILDCARD:
				{
				alt63 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 63, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:465:5: QUESTION
				{
				DebugLocation(465, 5);
				QUESTION139=(IToken)Match(input,QUESTION,Follow._QUESTION_in_ebnf1950); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUESTION.Add(QUESTION139);



				{
				// AST REWRITE
				// elements: block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 466:4: -> ^( OPTIONAL[$start,\"?\"] block )
				{
					DebugLocation(466, 7);
					// Grammars\\ANTLR.g3:466:7: ^( OPTIONAL[$start,\"?\"] block )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(466, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, retval.Start, "?"), root_1);

					DebugLocation(466, 30);
					adaptor.AddChild(root_1, stream_block.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:467:5: STAR
				{
				DebugLocation(467, 5);
				STAR140=(IToken)Match(input,STAR,Follow._STAR_in_ebnf1968); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR140);



				{
				// AST REWRITE
				// elements: block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 468:4: -> ^( CLOSURE[$start,\"*\"] block )
				{
					DebugLocation(468, 7);
					// Grammars\\ANTLR.g3:468:7: ^( CLOSURE[$start,\"*\"] block )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(468, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, retval.Start, "*"), root_1);

					DebugLocation(468, 29);
					adaptor.AddChild(root_1, stream_block.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:469:5: PLUS
				{
				DebugLocation(469, 5);
				PLUS141=(IToken)Match(input,PLUS,Follow._PLUS_in_ebnf1986); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PLUS.Add(PLUS141);



				{
				// AST REWRITE
				// elements: block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 470:4: -> ^( POSITIVE_CLOSURE[$start,\"+\"] block )
				{
					DebugLocation(470, 7);
					// Grammars\\ANTLR.g3:470:7: ^( POSITIVE_CLOSURE[$start,\"+\"] block )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(470, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, retval.Start, "+"), root_1);

					DebugLocation(470, 38);
					adaptor.AddChild(root_1, stream_block.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:471:5: IMPLIES
				{
				DebugLocation(471, 5);
				IMPLIES142=(IToken)Match(input,IMPLIES,Follow._IMPLIES_in_ebnf2004); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IMPLIES.Add(IMPLIES142);



				{
				// AST REWRITE
				// elements: block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 473:4: -> {GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer}? ^( SYNPRED[$start,\"=>\"] block )
				if (GrammarType == GrammarType.Combined && Rule.GetRuleType(currentRuleName) == RuleType.Lexer)
				{
					DebugLocation(473, 101);
					// Grammars\\ANTLR.g3:473:101: ^( SYNPRED[$start,\"=>\"] block )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(473, 103);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SYNPRED, retval.Start, "=>"), root_1);

					DebugLocation(473, 124);
					adaptor.AddChild(root_1, stream_block.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 475:4: ->
				{
					DebugLocation(475, 7);
					adaptor.AddChild(root_0, CreateSynSemPredFromBlock((block138!=null?((GrammarAST)block138.Tree):default(GrammarAST)), SYN_SEMPRED));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\ANTLR.g3:476:5: ROOT
				{
				DebugLocation(476, 5);
				ROOT143=(IToken)Match(input,ROOT,Follow._ROOT_in_ebnf2040); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ROOT.Add(ROOT143);



				{
				// AST REWRITE
				// elements: ROOT, block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 477:4: -> ^( ROOT block )
				{
					DebugLocation(477, 7);
					// Grammars\\ANTLR.g3:477:7: ^( ROOT block )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(477, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_ROOT.NextNode(), root_1);

					DebugLocation(477, 14);
					adaptor.AddChild(root_1, stream_block.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\ANTLR.g3:478:5: BANG
				{
				DebugLocation(478, 5);
				BANG144=(IToken)Match(input,BANG,Follow._BANG_in_ebnf2057); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BANG.Add(BANG144);



				{
				// AST REWRITE
				// elements: BANG, block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 479:4: -> ^( BANG block )
				{
					DebugLocation(479, 7);
					// Grammars\\ANTLR.g3:479:7: ^( BANG block )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(479, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot(stream_BANG.NextNode(), root_1);

					DebugLocation(479, 14);
					adaptor.AddChild(root_1, stream_block.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\ANTLR.g3:481:4: 
				{

				{
				// AST REWRITE
				// elements: block
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 481:4: -> block
				{
					DebugLocation(481, 7);
					adaptor.AddChild(root_0, stream_block.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(63); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ebnf", 34);
			LeaveRule("ebnf", 34);
			LeaveRule_ebnf();
		}
		DebugLocation(483, 1);
		} finally { DebugExitRule(GrammarFileName, "ebnf"); }
		return retval;

	}
	// $ANTLR end "ebnf"

	partial void EnterRule_range();
	partial void LeaveRule_range();
	// $ANTLR start "range"
	// Grammars\\ANTLR.g3:485:1: range : ({...}? => CHAR_LITERAL RANGE ^ CHAR_LITERAL | ( TOKEN_REF r= RANGE ! TOKEN_REF !| STRING_LITERAL r= RANGE ! STRING_LITERAL !| CHAR_LITERAL r= RANGE ! CHAR_LITERAL !) );
	[GrammarRule("range")]
	private AstParserRuleReturnScope<GrammarAST, IToken> range()
	{
		EnterRule_range();
		EnterRule("range", 35);
		TraceIn("range", 35);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken r = default(IToken);
		IToken CHAR_LITERAL145 = default(IToken);
		IToken RANGE146 = default(IToken);
		IToken CHAR_LITERAL147 = default(IToken);
		IToken TOKEN_REF148 = default(IToken);
		IToken TOKEN_REF149 = default(IToken);
		IToken STRING_LITERAL150 = default(IToken);
		IToken STRING_LITERAL151 = default(IToken);
		IToken CHAR_LITERAL152 = default(IToken);
		IToken CHAR_LITERAL153 = default(IToken);

		GrammarAST r_tree = default(GrammarAST);
		GrammarAST CHAR_LITERAL145_tree = default(GrammarAST);
		GrammarAST RANGE146_tree = default(GrammarAST);
		GrammarAST CHAR_LITERAL147_tree = default(GrammarAST);
		GrammarAST TOKEN_REF148_tree = default(GrammarAST);
		GrammarAST TOKEN_REF149_tree = default(GrammarAST);
		GrammarAST STRING_LITERAL150_tree = default(GrammarAST);
		GrammarAST STRING_LITERAL151_tree = default(GrammarAST);
		GrammarAST CHAR_LITERAL152_tree = default(GrammarAST);
		GrammarAST CHAR_LITERAL153_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "range");
		DebugLocation(485, 1);
		try
		{
			// Grammars\\ANTLR.g3:486:2: ({...}? => CHAR_LITERAL RANGE ^ CHAR_LITERAL | ( TOKEN_REF r= RANGE ! TOKEN_REF !| STRING_LITERAL r= RANGE ! STRING_LITERAL !| CHAR_LITERAL r= RANGE ! CHAR_LITERAL !) )
			int alt65=2;
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==CHAR_LITERAL))
			{
				int LA65_2 = input.LA(2);

				if ((LA65_2==RANGE))
				{
					int LA65_3 = input.LA(3);

					if ((LA65_3==CHAR_LITERAL))
					{
						int LA65_4 = input.LA(4);

						if (((Rule.GetRuleType(currentRuleName) == RuleType.Lexer)))
						{
							alt65 = 1;
						}
						else if ((true))
						{
							alt65 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 65, 4, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 65, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 65, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA65_1==STRING_LITERAL||LA65_1==TOKEN_REF))
			{
				alt65 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 65, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:486:4: {...}? => CHAR_LITERAL RANGE ^ CHAR_LITERAL
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(486, 4);
				if (!((Rule.GetRuleType(currentRuleName) == RuleType.Lexer)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "range", "Rule.GetRuleType(currentRuleName) == RuleType.Lexer");
				}
				DebugLocation(487, 4);
				CHAR_LITERAL145=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2101); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHAR_LITERAL145_tree = (GrammarAST)adaptor.Create(CHAR_LITERAL145);
				adaptor.AddChild(root_0, CHAR_LITERAL145_tree);
				}
				DebugLocation(487, 49);
				RANGE146=(IToken)Match(input,RANGE,Follow._RANGE_in_range2103); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RANGE146_tree = (GrammarAST)adaptor.Create(CHAR_RANGE,RANGE146,"..");
				root_0 = (GrammarAST)adaptor.BecomeRoot(RANGE146_tree, root_0);
				}
				DebugLocation(487, 51);
				CHAR_LITERAL147=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2115); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHAR_LITERAL147_tree = (GrammarAST)adaptor.Create(CHAR_LITERAL147);
				adaptor.AddChild(root_0, CHAR_LITERAL147_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:489:3: ( TOKEN_REF r= RANGE ! TOKEN_REF !| STRING_LITERAL r= RANGE ! STRING_LITERAL !| CHAR_LITERAL r= RANGE ! CHAR_LITERAL !)
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(489, 3);
				// Grammars\\ANTLR.g3:489:3: ( TOKEN_REF r= RANGE ! TOKEN_REF !| STRING_LITERAL r= RANGE ! STRING_LITERAL !| CHAR_LITERAL r= RANGE ! CHAR_LITERAL !)
				int alt64=3;
				try { DebugEnterSubRule(64);
				try { DebugEnterDecision(64, false);
				switch (input.LA(1))
				{
				case TOKEN_REF:
					{
					alt64 = 1;
					}
					break;
				case STRING_LITERAL:
					{
					alt64 = 2;
					}
					break;
				case CHAR_LITERAL:
					{
					alt64 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 64, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(64); }
				switch (alt64)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:490:4: TOKEN_REF r= RANGE ! TOKEN_REF !
					{
					DebugLocation(490, 4);
					TOKEN_REF148=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_range2129); if (state.failed) return retval;
					if (state.backtracking == 0) {
					TOKEN_REF148_tree = (GrammarAST)adaptor.Create(TOKEN_REF148);
					adaptor.AddChild(root_0, TOKEN_REF148_tree);
					}
					DebugLocation(490, 15);
					r=(IToken)Match(input,RANGE,Follow._RANGE_in_range2133); if (state.failed) return retval;
					DebugLocation(490, 32);
					TOKEN_REF149=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_range2136); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:491:5: STRING_LITERAL r= RANGE ! STRING_LITERAL !
					{
					DebugLocation(491, 5);
					STRING_LITERAL150=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_range2143); if (state.failed) return retval;
					if (state.backtracking == 0) {
					STRING_LITERAL150_tree = (GrammarAST)adaptor.Create(STRING_LITERAL150);
					adaptor.AddChild(root_0, STRING_LITERAL150_tree);
					}
					DebugLocation(491, 21);
					r=(IToken)Match(input,RANGE,Follow._RANGE_in_range2147); if (state.failed) return retval;
					DebugLocation(491, 43);
					STRING_LITERAL151=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_range2150); if (state.failed) return retval;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\ANTLR.g3:492:5: CHAR_LITERAL r= RANGE ! CHAR_LITERAL !
					{
					DebugLocation(492, 5);
					CHAR_LITERAL152=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2157); if (state.failed) return retval;
					if (state.backtracking == 0) {
					CHAR_LITERAL152_tree = (GrammarAST)adaptor.Create(CHAR_LITERAL152);
					adaptor.AddChild(root_0, CHAR_LITERAL152_tree);
					}
					DebugLocation(492, 19);
					r=(IToken)Match(input,RANGE,Follow._RANGE_in_range2161); if (state.failed) return retval;
					DebugLocation(492, 39);
					CHAR_LITERAL153=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_range2164); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(64); }

				DebugLocation(494, 3);
				if (state.backtracking == 0)
				{

							ErrorManager.SyntaxError(
								ErrorManager.MSG_RANGE_OP_ILLEGAL,Grammar,r,null,null);
							
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("range", 35);
			LeaveRule("range", 35);
			LeaveRule_range();
		}
		DebugLocation(498, 1);
		} finally { DebugExitRule(GrammarFileName, "range"); }
		return retval;

	}
	// $ANTLR end "range"

	partial void EnterRule_terminal();
	partial void LeaveRule_terminal();
	// $ANTLR start "terminal"
	// Grammars\\ANTLR.g3:500:1: terminal : ( CHAR_LITERAL ^ ( elementOptions[$CHAR_LITERAL.tree] !)? ( ROOT ^| BANG ^)? | TOKEN_REF ^ ( elementOptions[$TOKEN_REF.tree] !)? ( ARG_ACTION )? ( ROOT ^| BANG ^)? | STRING_LITERAL ^ ( elementOptions[$STRING_LITERAL.tree] !)? ( ROOT ^| BANG ^)? | WILDCARD ( ROOT ^| BANG ^)? );
	[GrammarRule("terminal")]
	private AstParserRuleReturnScope<GrammarAST, IToken> terminal()
	{
		EnterRule_terminal();
		EnterRule("terminal", 36);
		TraceIn("terminal", 36);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken CHAR_LITERAL154 = default(IToken);
		IToken ROOT156 = default(IToken);
		IToken BANG157 = default(IToken);
		IToken TOKEN_REF158 = default(IToken);
		IToken ARG_ACTION160 = default(IToken);
		IToken ROOT161 = default(IToken);
		IToken BANG162 = default(IToken);
		IToken STRING_LITERAL163 = default(IToken);
		IToken ROOT165 = default(IToken);
		IToken BANG166 = default(IToken);
		IToken WILDCARD167 = default(IToken);
		IToken ROOT168 = default(IToken);
		IToken BANG169 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptions155 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptions159 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptions164 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST CHAR_LITERAL154_tree = default(GrammarAST);
		GrammarAST ROOT156_tree = default(GrammarAST);
		GrammarAST BANG157_tree = default(GrammarAST);
		GrammarAST TOKEN_REF158_tree = default(GrammarAST);
		GrammarAST ARG_ACTION160_tree = default(GrammarAST);
		GrammarAST ROOT161_tree = default(GrammarAST);
		GrammarAST BANG162_tree = default(GrammarAST);
		GrammarAST STRING_LITERAL163_tree = default(GrammarAST);
		GrammarAST ROOT165_tree = default(GrammarAST);
		GrammarAST BANG166_tree = default(GrammarAST);
		GrammarAST WILDCARD167_tree = default(GrammarAST);
		GrammarAST ROOT168_tree = default(GrammarAST);
		GrammarAST BANG169_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "terminal");
		DebugLocation(500, 1);
		try
		{
			// Grammars\\ANTLR.g3:501:2: ( CHAR_LITERAL ^ ( elementOptions[$CHAR_LITERAL.tree] !)? ( ROOT ^| BANG ^)? | TOKEN_REF ^ ( elementOptions[$TOKEN_REF.tree] !)? ( ARG_ACTION )? ( ROOT ^| BANG ^)? | STRING_LITERAL ^ ( elementOptions[$STRING_LITERAL.tree] !)? ( ROOT ^| BANG ^)? | WILDCARD ( ROOT ^| BANG ^)? )
			int alt74=4;
			try { DebugEnterDecision(74, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				alt74 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt74 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				alt74 = 3;
				}
				break;
			case WILDCARD:
				{
				alt74 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 74, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:501:4: CHAR_LITERAL ^ ( elementOptions[$CHAR_LITERAL.tree] !)? ( ROOT ^| BANG ^)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(501, 16);
				CHAR_LITERAL154=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_terminal2184); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHAR_LITERAL154_tree = (GrammarAST)adaptor.Create(CHAR_LITERAL154);
				root_0 = (GrammarAST)adaptor.BecomeRoot(CHAR_LITERAL154_tree, root_0);
				}
				DebugLocation(501, 18);
				// Grammars\\ANTLR.g3:501:18: ( elementOptions[$CHAR_LITERAL.tree] !)?
				int alt66=2;
				try { DebugEnterSubRule(66);
				try { DebugEnterDecision(66, false);
				int LA66_1 = input.LA(1);

				if ((LA66_1==OPEN_ELEMENT_OPTION))
				{
					alt66 = 1;
				}
				} finally { DebugExitDecision(66); }
				switch (alt66)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:501:20: elementOptions[$CHAR_LITERAL.tree] !
					{
					DebugLocation(501, 54);
					PushFollow(Follow._elementOptions_in_terminal2189);
					elementOptions155=elementOptions(CHAR_LITERAL154_tree);
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(66); }

				DebugLocation(501, 59);
				// Grammars\\ANTLR.g3:501:59: ( ROOT ^| BANG ^)?
				int alt67=3;
				try { DebugEnterSubRule(67);
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==ROOT))
				{
					alt67 = 1;
				}
				else if ((LA67_1==BANG))
				{
					alt67 = 2;
				}
				} finally { DebugExitDecision(67); }
				switch (alt67)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:501:60: ROOT ^
					{
					DebugLocation(501, 64);
					ROOT156=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2197); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ROOT156_tree = (GrammarAST)adaptor.Create(ROOT156);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT156_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:501:66: BANG ^
					{
					DebugLocation(501, 70);
					BANG157=(IToken)Match(input,BANG,Follow._BANG_in_terminal2200); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BANG157_tree = (GrammarAST)adaptor.Create(BANG157);
					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG157_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(67); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:503:4: TOKEN_REF ^ ( elementOptions[$TOKEN_REF.tree] !)? ( ARG_ACTION )? ( ROOT ^| BANG ^)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(503, 13);
				TOKEN_REF158=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_terminal2209); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TOKEN_REF158_tree = (GrammarAST)adaptor.Create(TOKEN_REF158);
				root_0 = (GrammarAST)adaptor.BecomeRoot(TOKEN_REF158_tree, root_0);
				}
				DebugLocation(504, 3);
				// Grammars\\ANTLR.g3:504:3: ( elementOptions[$TOKEN_REF.tree] !)?
				int alt68=2;
				try { DebugEnterSubRule(68);
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==OPEN_ELEMENT_OPTION))
				{
					alt68 = 1;
				}
				} finally { DebugExitDecision(68); }
				switch (alt68)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:504:5: elementOptions[$TOKEN_REF.tree] !
					{
					DebugLocation(504, 36);
					PushFollow(Follow._elementOptions_in_terminal2216);
					elementOptions159=elementOptions(TOKEN_REF158_tree);
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(68); }

				DebugLocation(505, 3);
				// Grammars\\ANTLR.g3:505:3: ( ARG_ACTION )?
				int alt69=2;
				try { DebugEnterSubRule(69);
				try { DebugEnterDecision(69, false);
				int LA69_1 = input.LA(1);

				if ((LA69_1==ARG_ACTION))
				{
					alt69 = 1;
				}
				} finally { DebugExitDecision(69); }
				switch (alt69)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:505:5: ARG_ACTION
					{
					DebugLocation(505, 5);
					ARG_ACTION160=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_terminal2227); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ARG_ACTION160_tree = (GrammarAST)adaptor.Create(ARG_ACTION160);
					adaptor.AddChild(root_0, ARG_ACTION160_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(69); }

				DebugLocation(506, 3);
				// Grammars\\ANTLR.g3:506:3: ( ROOT ^| BANG ^)?
				int alt70=3;
				try { DebugEnterSubRule(70);
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==ROOT))
				{
					alt70 = 1;
				}
				else if ((LA70_1==BANG))
				{
					alt70 = 2;
				}
				} finally { DebugExitDecision(70); }
				switch (alt70)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:506:4: ROOT ^
					{
					DebugLocation(506, 8);
					ROOT161=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2236); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ROOT161_tree = (GrammarAST)adaptor.Create(ROOT161);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT161_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:506:10: BANG ^
					{
					DebugLocation(506, 14);
					BANG162=(IToken)Match(input,BANG,Follow._BANG_in_terminal2239); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BANG162_tree = (GrammarAST)adaptor.Create(BANG162);
					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG162_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(70); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:508:4: STRING_LITERAL ^ ( elementOptions[$STRING_LITERAL.tree] !)? ( ROOT ^| BANG ^)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(508, 18);
				STRING_LITERAL163=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_terminal2248); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRING_LITERAL163_tree = (GrammarAST)adaptor.Create(STRING_LITERAL163);
				root_0 = (GrammarAST)adaptor.BecomeRoot(STRING_LITERAL163_tree, root_0);
				}
				DebugLocation(508, 20);
				// Grammars\\ANTLR.g3:508:20: ( elementOptions[$STRING_LITERAL.tree] !)?
				int alt71=2;
				try { DebugEnterSubRule(71);
				try { DebugEnterDecision(71, false);
				int LA71_1 = input.LA(1);

				if ((LA71_1==OPEN_ELEMENT_OPTION))
				{
					alt71 = 1;
				}
				} finally { DebugExitDecision(71); }
				switch (alt71)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:508:22: elementOptions[$STRING_LITERAL.tree] !
					{
					DebugLocation(508, 58);
					PushFollow(Follow._elementOptions_in_terminal2253);
					elementOptions164=elementOptions(STRING_LITERAL163_tree);
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(71); }

				DebugLocation(508, 63);
				// Grammars\\ANTLR.g3:508:63: ( ROOT ^| BANG ^)?
				int alt72=3;
				try { DebugEnterSubRule(72);
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==ROOT))
				{
					alt72 = 1;
				}
				else if ((LA72_1==BANG))
				{
					alt72 = 2;
				}
				} finally { DebugExitDecision(72); }
				switch (alt72)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:508:64: ROOT ^
					{
					DebugLocation(508, 68);
					ROOT165=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2261); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ROOT165_tree = (GrammarAST)adaptor.Create(ROOT165);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT165_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:508:70: BANG ^
					{
					DebugLocation(508, 74);
					BANG166=(IToken)Match(input,BANG,Follow._BANG_in_terminal2264); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BANG166_tree = (GrammarAST)adaptor.Create(BANG166);
					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG166_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(72); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:510:4: WILDCARD ( ROOT ^| BANG ^)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(510, 4);
				WILDCARD167=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_terminal2273); if (state.failed) return retval;
				if (state.backtracking == 0) {
				WILDCARD167_tree = (GrammarAST)adaptor.Create(WILDCARD167);
				adaptor.AddChild(root_0, WILDCARD167_tree);
				}
				DebugLocation(510, 13);
				// Grammars\\ANTLR.g3:510:13: ( ROOT ^| BANG ^)?
				int alt73=3;
				try { DebugEnterSubRule(73);
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==ROOT))
				{
					alt73 = 1;
				}
				else if ((LA73_1==BANG))
				{
					alt73 = 2;
				}
				} finally { DebugExitDecision(73); }
				switch (alt73)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:510:14: ROOT ^
					{
					DebugLocation(510, 18);
					ROOT168=(IToken)Match(input,ROOT,Follow._ROOT_in_terminal2276); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ROOT168_tree = (GrammarAST)adaptor.Create(ROOT168);
					root_0 = (GrammarAST)adaptor.BecomeRoot(ROOT168_tree, root_0);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:510:20: BANG ^
					{
					DebugLocation(510, 24);
					BANG169=(IToken)Match(input,BANG,Follow._BANG_in_terminal2279); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BANG169_tree = (GrammarAST)adaptor.Create(BANG169);
					root_0 = (GrammarAST)adaptor.BecomeRoot(BANG169_tree, root_0);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(73); }

				DebugLocation(511, 3);
				if (state.backtracking == 0)
				{

								if ( atTreeRoot )
								{
									ErrorManager.SyntaxError(
										ErrorManager.MSG_WILDCARD_AS_ROOT,Grammar,WILDCARD167,null,null);
								}
							
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("terminal", 36);
			LeaveRule("terminal", 36);
			LeaveRule_terminal();
		}
		DebugLocation(518, 1);
		} finally { DebugExitRule(GrammarFileName, "terminal"); }
		return retval;

	}
	// $ANTLR end "terminal"

	partial void EnterRule_elementOptions();
	partial void LeaveRule_elementOptions();
	// $ANTLR start "elementOptions"
	// Grammars\\ANTLR.g3:520:1: elementOptions[GrammarAST terminalAST] : ( OPEN_ELEMENT_OPTION ^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION !| OPEN_ELEMENT_OPTION ^ elementOption[terminalAST] ( SEMI ! elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION !);
	[GrammarRule("elementOptions")]
	private AstParserRuleReturnScope<GrammarAST, IToken> elementOptions(GrammarAST terminalAST)
	{
		EnterRule_elementOptions();
		EnterRule("elementOptions", 37);
		TraceIn("elementOptions", 37);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken OPEN_ELEMENT_OPTION170 = default(IToken);
		IToken CLOSE_ELEMENT_OPTION172 = default(IToken);
		IToken OPEN_ELEMENT_OPTION173 = default(IToken);
		IToken SEMI175 = default(IToken);
		IToken CLOSE_ELEMENT_OPTION177 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> defaultNodeOption171 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOption174 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOption176 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST OPEN_ELEMENT_OPTION170_tree = default(GrammarAST);
		GrammarAST CLOSE_ELEMENT_OPTION172_tree = default(GrammarAST);
		GrammarAST OPEN_ELEMENT_OPTION173_tree = default(GrammarAST);
		GrammarAST SEMI175_tree = default(GrammarAST);
		GrammarAST CLOSE_ELEMENT_OPTION177_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "elementOptions");
		DebugLocation(520, 1);
		try
		{
			// Grammars\\ANTLR.g3:521:2: ( OPEN_ELEMENT_OPTION ^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION !| OPEN_ELEMENT_OPTION ^ elementOption[terminalAST] ( SEMI ! elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION !)
			int alt76=2;
			try { DebugEnterDecision(76, false);
			int LA76_1 = input.LA(1);

			if ((LA76_1==OPEN_ELEMENT_OPTION))
			{
				int LA76_2 = input.LA(2);

				if ((LA76_2==TOKEN_REF))
				{
					int LA76_3 = input.LA(3);

					if ((LA76_3==CLOSE_ELEMENT_OPTION||LA76_3==WILDCARD))
					{
						alt76 = 1;
					}
					else if ((LA76_3==ASSIGN))
					{
						alt76 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 76, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else if ((LA76_2==RULE_REF))
				{
					int LA76_3 = input.LA(3);

					if ((LA76_3==CLOSE_ELEMENT_OPTION||LA76_3==WILDCARD))
					{
						alt76 = 1;
					}
					else if ((LA76_3==ASSIGN))
					{
						alt76 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 76, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 76, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 76, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:521:4: OPEN_ELEMENT_OPTION ^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION !
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(521, 23);
				OPEN_ELEMENT_OPTION170=(IToken)Match(input,OPEN_ELEMENT_OPTION,Follow._OPEN_ELEMENT_OPTION_in_elementOptions2298); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OPEN_ELEMENT_OPTION170_tree = (GrammarAST)adaptor.Create(OPEN_ELEMENT_OPTION170);
				root_0 = (GrammarAST)adaptor.BecomeRoot(OPEN_ELEMENT_OPTION170_tree, root_0);
				}
				DebugLocation(521, 25);
				PushFollow(Follow._defaultNodeOption_in_elementOptions2301);
				defaultNodeOption171=defaultNodeOption(terminalAST);
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, defaultNodeOption171.Tree);
				DebugLocation(521, 76);
				CLOSE_ELEMENT_OPTION172=(IToken)Match(input,CLOSE_ELEMENT_OPTION,Follow._CLOSE_ELEMENT_OPTION_in_elementOptions2304); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:522:4: OPEN_ELEMENT_OPTION ^ elementOption[terminalAST] ( SEMI ! elementOption[terminalAST] )* CLOSE_ELEMENT_OPTION !
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(522, 23);
				OPEN_ELEMENT_OPTION173=(IToken)Match(input,OPEN_ELEMENT_OPTION,Follow._OPEN_ELEMENT_OPTION_in_elementOptions2310); if (state.failed) return retval;
				if (state.backtracking == 0) {
				OPEN_ELEMENT_OPTION173_tree = (GrammarAST)adaptor.Create(OPEN_ELEMENT_OPTION173);
				root_0 = (GrammarAST)adaptor.BecomeRoot(OPEN_ELEMENT_OPTION173_tree, root_0);
				}
				DebugLocation(522, 25);
				PushFollow(Follow._elementOption_in_elementOptions2313);
				elementOption174=elementOption(terminalAST);
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, elementOption174.Tree);
				DebugLocation(522, 52);
				// Grammars\\ANTLR.g3:522:52: ( SEMI ! elementOption[terminalAST] )*
				try { DebugEnterSubRule(75);
				while (true)
				{
					int alt75=2;
					try { DebugEnterDecision(75, false);
					int LA75_1 = input.LA(1);

					if ((LA75_1==SEMI))
					{
						alt75 = 1;
					}


					} finally { DebugExitDecision(75); }
					switch ( alt75 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:522:53: SEMI ! elementOption[terminalAST]
						{
						DebugLocation(522, 57);
						SEMI175=(IToken)Match(input,SEMI,Follow._SEMI_in_elementOptions2317); if (state.failed) return retval;
						DebugLocation(522, 59);
						PushFollow(Follow._elementOption_in_elementOptions2320);
						elementOption176=elementOption(terminalAST);
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, elementOption176.Tree);

						}
						break;

					default:
						goto loop75;
					}
				}

				loop75:
					;

				} finally { DebugExitSubRule(75); }

				DebugLocation(522, 108);
				CLOSE_ELEMENT_OPTION177=(IToken)Match(input,CLOSE_ELEMENT_OPTION,Follow._CLOSE_ELEMENT_OPTION_in_elementOptions2325); if (state.failed) return retval;

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elementOptions", 37);
			LeaveRule("elementOptions", 37);
			LeaveRule_elementOptions();
		}
		DebugLocation(523, 1);
		} finally { DebugExitRule(GrammarFileName, "elementOptions"); }
		return retval;

	}
	// $ANTLR end "elementOptions"

	partial void EnterRule_defaultNodeOption();
	partial void LeaveRule_defaultNodeOption();
	// $ANTLR start "defaultNodeOption"
	// Grammars\\ANTLR.g3:525:1: defaultNodeOption[GrammarAST terminalAST] : elementOptionId ;
	[GrammarRule("defaultNodeOption")]
	private AstParserRuleReturnScope<GrammarAST, IToken> defaultNodeOption(GrammarAST terminalAST)
	{
		EnterRule_defaultNodeOption();
		EnterRule("defaultNodeOption", 38);
		TraceIn("defaultNodeOption", 38);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> elementOptionId178 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "defaultNodeOption");
		DebugLocation(525, 1);
		try
		{
			// Grammars\\ANTLR.g3:526:2: ( elementOptionId )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:526:4: elementOptionId
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(526, 4);
			PushFollow(Follow._elementOptionId_in_defaultNodeOption2338);
			elementOptionId178=elementOptionId();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, elementOptionId178.Tree);
			DebugLocation(527, 3);
			if (state.backtracking == 0)
			{
				terminalAST.SetTerminalOption(Grammar,Grammar.defaultTokenOption,(elementOptionId178!=null?((ANTLRParser.elementOptionId_return)elementOptionId178).qid:default(string)));
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultNodeOption", 38);
			LeaveRule("defaultNodeOption", 38);
			LeaveRule_defaultNodeOption();
		}
		DebugLocation(528, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultNodeOption"); }
		return retval;

	}
	// $ANTLR end "defaultNodeOption"

	partial void EnterRule_elementOption();
	partial void LeaveRule_elementOption();
	// $ANTLR start "elementOption"
	// Grammars\\ANTLR.g3:530:1: elementOption[GrammarAST terminalAST] : id ASSIGN ^ ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) ) ;
	[GrammarRule("elementOption")]
	private AstParserRuleReturnScope<GrammarAST, IToken> elementOption(GrammarAST terminalAST)
	{
		EnterRule_elementOption();
		EnterRule("elementOption", 39);
		TraceIn("elementOption", 39);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken t = default(IToken);
		IToken ASSIGN180 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id179 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptionId181 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST t_tree = default(GrammarAST);
		GrammarAST ASSIGN180_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "elementOption");
		DebugLocation(530, 1);
		try
		{
			// Grammars\\ANTLR.g3:531:2: ( id ASSIGN ^ ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:531:4: id ASSIGN ^ ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) )
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(531, 4);
			PushFollow(Follow._id_in_elementOption2354);
			id179=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id179.Tree);
			DebugLocation(531, 13);
			ASSIGN180=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_elementOption2356); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ASSIGN180_tree = (GrammarAST)adaptor.Create(ASSIGN180);
			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN180_tree, root_0);
			}
			DebugLocation(532, 3);
			// Grammars\\ANTLR.g3:532:3: ( elementOptionId | (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL ) )
			int alt78=2;
			try { DebugEnterSubRule(78);
			try { DebugEnterDecision(78, false);
			int LA78_1 = input.LA(1);

			if ((LA78_1==RULE_REF||LA78_1==TOKEN_REF))
			{
				alt78 = 1;
			}
			else if (((LA78_1>=DOUBLE_ANGLE_STRING_LITERAL && LA78_1<=DOUBLE_QUOTE_STRING_LITERAL)||LA78_1==STRING_LITERAL))
			{
				alt78 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 78, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:532:5: elementOptionId
				{
				DebugLocation(532, 5);
				PushFollow(Follow._elementOptionId_in_elementOption2363);
				elementOptionId181=elementOptionId();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, elementOptionId181.Tree);
				DebugLocation(533, 4);
				if (state.backtracking == 0)
				{
					terminalAST.SetTerminalOption(Grammar,(id179!=null?input.ToString(id179.Start,id179.Stop):default(string)),(elementOptionId181!=null?((ANTLRParser.elementOptionId_return)elementOptionId181).qid:default(string)));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:534:5: (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL )
				{
				DebugLocation(534, 5);
				// Grammars\\ANTLR.g3:534:5: (t= STRING_LITERAL |t= DOUBLE_QUOTE_STRING_LITERAL |t= DOUBLE_ANGLE_STRING_LITERAL )
				int alt77=3;
				try { DebugEnterSubRule(77);
				try { DebugEnterDecision(77, false);
				switch (input.LA(1))
				{
				case STRING_LITERAL:
					{
					alt77 = 1;
					}
					break;
				case DOUBLE_QUOTE_STRING_LITERAL:
					{
					alt77 = 2;
					}
					break;
				case DOUBLE_ANGLE_STRING_LITERAL:
					{
					alt77 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 77, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(77); }
				switch (alt77)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:534:6: t= STRING_LITERAL
					{
					DebugLocation(534, 7);
					t=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_elementOption2377); if (state.failed) return retval;
					if (state.backtracking == 0) {
					t_tree = (GrammarAST)adaptor.Create(t);
					adaptor.AddChild(root_0, t_tree);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:534:23: t= DOUBLE_QUOTE_STRING_LITERAL
					{
					DebugLocation(534, 24);
					t=(IToken)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_elementOption2381); if (state.failed) return retval;
					if (state.backtracking == 0) {
					t_tree = (GrammarAST)adaptor.Create(t);
					adaptor.AddChild(root_0, t_tree);
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\ANTLR.g3:534:53: t= DOUBLE_ANGLE_STRING_LITERAL
					{
					DebugLocation(534, 54);
					t=(IToken)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_elementOption2385); if (state.failed) return retval;
					if (state.backtracking == 0) {
					t_tree = (GrammarAST)adaptor.Create(t);
					adaptor.AddChild(root_0, t_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(77); }

				DebugLocation(535, 4);
				if (state.backtracking == 0)
				{
					terminalAST.SetTerminalOption(Grammar,(id179!=null?input.ToString(id179.Start,id179.Stop):default(string)),(t!=null?t.Text:default(string)));
				}

				}
				break;

			}
			} finally { DebugExitSubRule(78); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elementOption", 39);
			LeaveRule("elementOption", 39);
			LeaveRule_elementOption();
		}
		DebugLocation(537, 1);
		} finally { DebugExitRule(GrammarFileName, "elementOption"); }
		return retval;

	}
	// $ANTLR end "elementOption"

	private sealed partial class elementOptionId_return : AstParserRuleReturnScope<GrammarAST, IToken>
	{
		public string qid;
		public elementOptionId_return(ANTLRParser grammar) {OnCreated(grammar);}
		partial void OnCreated(ANTLRParser grammar);
	}

	partial void EnterRule_elementOptionId();
	partial void LeaveRule_elementOptionId();
	// $ANTLR start "elementOptionId"
	// Grammars\\ANTLR.g3:539:1: elementOptionId returns [string qid] : i= id ( '.' i= id )* ;
	[GrammarRule("elementOptionId")]
	private ANTLRParser.elementOptionId_return elementOptionId()
	{
		EnterRule_elementOptionId();
		EnterRule("elementOptionId", 40);
		TraceIn("elementOptionId", 40);
		ANTLRParser.elementOptionId_return retval = new ANTLRParser.elementOptionId_return(this);
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken char_literal182 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> i = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST char_literal182_tree = default(GrammarAST);
		StringBuffer buf = new StringBuffer();
		try { DebugEnterRule(GrammarFileName, "elementOptionId");
		DebugLocation(539, 1);
		try
		{
			// Grammars\\ANTLR.g3:541:2: (i= id ( '.' i= id )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:541:4: i= id ( '.' i= id )*
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(541, 5);
			PushFollow(Follow._id_in_elementOptionId2416);
			i=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, i.Tree);
			DebugLocation(541, 9);
			if (state.backtracking == 0)
			{
				buf.Append((i!=null?input.ToString(i.Start,i.Stop):default(string)));
			}
			DebugLocation(541, 32);
			// Grammars\\ANTLR.g3:541:32: ( '.' i= id )*
			try { DebugEnterSubRule(79);
			while (true)
			{
				int alt79=2;
				try { DebugEnterDecision(79, false);
				int LA79_1 = input.LA(1);

				if ((LA79_1==WILDCARD))
				{
					alt79 = 1;
				}


				} finally { DebugExitDecision(79); }
				switch ( alt79 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:541:33: '.' i= id
					{
					DebugLocation(541, 33);
					char_literal182=(IToken)Match(input,WILDCARD,Follow._WILDCARD_in_elementOptionId2421); if (state.failed) return retval;
					if (state.backtracking == 0) {
					char_literal182_tree = (GrammarAST)adaptor.Create(char_literal182);
					adaptor.AddChild(root_0, char_literal182_tree);
					}
					DebugLocation(541, 38);
					PushFollow(Follow._id_in_elementOptionId2425);
					i=id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, i.Tree);
					DebugLocation(541, 42);
					if (state.backtracking == 0)
					{
						buf.Append("." + (i!=null?input.ToString(i.Start,i.Stop):default(string)));
					}

					}
					break;

				default:
					goto loop79;
				}
			}

			loop79:
				;

			} finally { DebugExitSubRule(79); }

			DebugLocation(542, 3);
			if (state.backtracking == 0)
			{
				retval.qid = buf.ToString();
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elementOptionId", 40);
			LeaveRule("elementOptionId", 40);
			LeaveRule_elementOptionId();
		}
		DebugLocation(543, 1);
		} finally { DebugExitRule(GrammarFileName, "elementOptionId"); }
		return retval;

	}
	// $ANTLR end "elementOptionId"

	partial void EnterRule_ebnfSuffix();
	partial void LeaveRule_ebnfSuffix();
	// $ANTLR start "ebnfSuffix"
	// Grammars\\ANTLR.g3:545:1: ebnfSuffix[GrammarAST elemAST, bool inRewrite] : ( -> BLOCK[$elemAST.Token, \"BLOCK\"] ) ( -> ^( ALT[$elemAST.Token, \"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) ) ;
	[GrammarRule("ebnfSuffix")]
	private AstParserRuleReturnScope<GrammarAST, IToken> ebnfSuffix(GrammarAST elemAST, bool inRewrite)
	{
		EnterRule_ebnfSuffix();
		EnterRule("ebnfSuffix", 41);
		TraceIn("ebnfSuffix", 41);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken QUESTION183 = default(IToken);
		IToken STAR184 = default(IToken);
		IToken PLUS185 = default(IToken);

		GrammarAST QUESTION183_tree = default(GrammarAST);
		GrammarAST STAR184_tree = default(GrammarAST);
		GrammarAST PLUS185_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");

		GrammarAST blkRoot=null;
		GrammarAST alt=null;
		GrammarAST save = currentBlockAST;

		try { DebugEnterRule(GrammarFileName, "ebnfSuffix");
		DebugLocation(545, 1);
		try
		{
			// Grammars\\ANTLR.g3:556:2: ( ( -> BLOCK[$elemAST.Token, \"BLOCK\"] ) ( -> ^( ALT[$elemAST.Token, \"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] ) -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:556:4: ( -> BLOCK[$elemAST.Token, \"BLOCK\"] ) ( -> ^( ALT[$elemAST.Token, \"ALT\"] EOA[\"<end-of-alt>\"] ) ) ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
			{
			DebugLocation(556, 4);
			// Grammars\\ANTLR.g3:556:4: ( -> BLOCK[$elemAST.Token, \"BLOCK\"] )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:556:6: 
			{

			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 556:6: -> BLOCK[$elemAST.Token, \"BLOCK\"]
			{
				DebugLocation(556, 9);
				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, elemAST.Token, "BLOCK"));

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(558, 3);
			if (state.backtracking == 0)
			{
				 blkRoot = (GrammarAST)retval.Tree.GetChild(0); currentBlockAST = blkRoot; 
			}
			DebugLocation(559, 3);
			// Grammars\\ANTLR.g3:559:3: ( -> ^( ALT[$elemAST.Token, \"ALT\"] EOA[\"<end-of-alt>\"] ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:560:4: 
			{

			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 560:4: -> ^( ALT[$elemAST.Token, \"ALT\"] EOA[\"<end-of-alt>\"] )
			{
				DebugLocation(560, 7);
				// Grammars\\ANTLR.g3:560:7: ^( ALT[$elemAST.Token, \"ALT\"] EOA[\"<end-of-alt>\"] )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(560, 9);
				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, elemAST.Token, "ALT"), root_1);

				DebugLocation(560, 36);
				adaptor.AddChild(root_1, elemAST);
				DebugLocation(560, 47);
				adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(562, 3);
			if (state.backtracking == 0)
			{

							alt = (GrammarAST)retval.Tree.GetChild(0);
							if ( !inRewrite )
								PrefixWithSynPred(alt);
						
			}
			DebugLocation(567, 3);
			// Grammars\\ANTLR.g3:567:3: ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
			int alt80=3;
			try { DebugEnterSubRule(80);
			try { DebugEnterDecision(80, false);
			switch (input.LA(1))
			{
			case QUESTION:
				{
				alt80 = 1;
				}
				break;
			case STAR:
				{
				alt80 = 2;
				}
				break;
			case PLUS:
				{
				alt80 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 80, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:567:5: QUESTION
				{
				DebugLocation(567, 5);
				QUESTION183=(IToken)Match(input,QUESTION,Follow._QUESTION_in_ebnfSuffix2502); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUESTION.Add(QUESTION183);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 568:4: -> OPTIONAL[$elemAST.Token,\"?\"]
				{
					DebugLocation(568, 7);
					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(OPTIONAL, elemAST.Token, "?"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:569:5: STAR
				{
				DebugLocation(569, 5);
				STAR184=(IToken)Match(input,STAR,Follow._STAR_in_ebnfSuffix2516); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR184);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 570:4: -> CLOSURE[$elemAST.Token,\"*\"]
				{
					DebugLocation(570, 7);
					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(CLOSURE, elemAST.Token, "*"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:571:5: PLUS
				{
				DebugLocation(571, 5);
				PLUS185=(IToken)Match(input,PLUS,Follow._PLUS_in_ebnfSuffix2530); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PLUS.Add(PLUS185);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 572:4: -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"]
				{
					DebugLocation(572, 7);
					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(POSITIVE_CLOSURE, elemAST.Token, "+"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(80); }



			{
			// AST REWRITE
			// elements: ebnfSuffix
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (GrammarAST)adaptor.Nil();
			// 574:3: -> ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) )
			{
				DebugLocation(574, 6);
				// Grammars\\ANTLR.g3:574:6: ^( $ebnfSuffix ^( EOB[$elemAST.Token, \"<end-of-block>\"] ) )
				{
				GrammarAST root_1 = (GrammarAST)adaptor.Nil();
				DebugLocation(574, 9);
				root_1 = (GrammarAST)adaptor.BecomeRoot(stream_retval.NextNode(), root_1);

				DebugLocation(574, 20);
				// Grammars\\ANTLR.g3:574:20: ^( EOB[$elemAST.Token, \"<end-of-block>\"] )
				{
				GrammarAST root_2 = (GrammarAST)adaptor.Nil();
				DebugLocation(574, 22);
				root_2 = (GrammarAST)adaptor.BecomeRoot(blkRoot, root_2);

				DebugLocation(574, 32);
				adaptor.AddChild(root_2, alt);
				DebugLocation(574, 38);
				adaptor.AddChild(root_2, (GrammarAST)adaptor.Create(EOB, elemAST.Token, "<end-of-block>"));

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{

				currentBlockAST = save;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ebnfSuffix", 41);
			LeaveRule("ebnfSuffix", 41);
			LeaveRule_ebnfSuffix();
		}
		DebugLocation(575, 1);
		} finally { DebugExitRule(GrammarFileName, "ebnfSuffix"); }
		return retval;

	}
	// $ANTLR end "ebnfSuffix"

	partial void EnterRule_notTerminal();
	partial void LeaveRule_notTerminal();
	// $ANTLR start "notTerminal"
	// Grammars\\ANTLR.g3:577:1: notTerminal : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL );
	[GrammarRule("notTerminal")]
	private AstParserRuleReturnScope<GrammarAST, IToken> notTerminal()
	{
		EnterRule_notTerminal();
		EnterRule("notTerminal", 42);
		TraceIn("notTerminal", 42);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken set186 = default(IToken);

		GrammarAST set186_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "notTerminal");
		DebugLocation(577, 1);
		try
		{
			// Grammars\\ANTLR.g3:578:2: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(578, 2);

			set186=(IToken)input.LT(1);
			if (input.LA(1)==CHAR_LITERAL||input.LA(1)==STRING_LITERAL||input.LA(1)==TOKEN_REF)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(set186));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("notTerminal", 42);
			LeaveRule("notTerminal", 42);
			LeaveRule_notTerminal();
		}
		DebugLocation(581, 1);
		} finally { DebugExitRule(GrammarFileName, "notTerminal"); }
		return retval;

	}
	// $ANTLR end "notTerminal"

	partial void EnterRule_idList();
	partial void LeaveRule_idList();
	// $ANTLR start "idList"
	// Grammars\\ANTLR.g3:583:1: idList : id ( COMMA ! id )* ;
	[GrammarRule("idList")]
	private AstParserRuleReturnScope<GrammarAST, IToken> idList()
	{
		EnterRule_idList();
		EnterRule("idList", 43);
		TraceIn("idList", 43);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken COMMA188 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id187 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> id189 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST COMMA188_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "idList");
		DebugLocation(583, 1);
		try
		{
			// Grammars\\ANTLR.g3:584:2: ( id ( COMMA ! id )* )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:584:4: id ( COMMA ! id )*
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(584, 4);
			PushFollow(Follow._id_in_idList2592);
			id187=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id187.Tree);
			DebugLocation(584, 7);
			// Grammars\\ANTLR.g3:584:7: ( COMMA ! id )*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=2;
				try { DebugEnterDecision(81, false);
				int LA81_1 = input.LA(1);

				if ((LA81_1==COMMA))
				{
					alt81 = 1;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:584:8: COMMA ! id
					{
					DebugLocation(584, 13);
					COMMA188=(IToken)Match(input,COMMA,Follow._COMMA_in_idList2595); if (state.failed) return retval;
					DebugLocation(584, 15);
					PushFollow(Follow._id_in_idList2598);
					id189=id();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, id189.Tree);

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("idList", 43);
			LeaveRule("idList", 43);
			LeaveRule_idList();
		}
		DebugLocation(585, 1);
		} finally { DebugExitRule(GrammarFileName, "idList"); }
		return retval;

	}
	// $ANTLR end "idList"

	partial void EnterRule_id();
	partial void LeaveRule_id();
	// $ANTLR start "id"
	// Grammars\\ANTLR.g3:587:1: id : ( TOKEN_REF | RULE_REF );
	[GrammarRule("id")]
	private AstParserRuleReturnScope<GrammarAST, IToken> id()
	{
		EnterRule_id();
		EnterRule("id", 44);
		TraceIn("id", 44);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TOKEN_REF190 = default(IToken);
		IToken RULE_REF191 = default(IToken);

		GrammarAST TOKEN_REF190_tree = default(GrammarAST);
		GrammarAST RULE_REF191_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "id");
		DebugLocation(587, 1);
		try
		{
			// Grammars\\ANTLR.g3:588:2: ( TOKEN_REF | RULE_REF )
			int alt82=2;
			try { DebugEnterDecision(82, false);
			int LA82_1 = input.LA(1);

			if ((LA82_1==TOKEN_REF))
			{
				alt82 = 1;
			}
			else if ((LA82_1==RULE_REF))
			{
				alt82 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 82, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:588:4: TOKEN_REF
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(588, 4);
				TOKEN_REF190=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_id2611); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TOKEN_REF190_tree = (GrammarAST)adaptor.Create(ID,TOKEN_REF190);
				adaptor.AddChild(root_0, TOKEN_REF190_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:589:4: RULE_REF
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(589, 4);
				RULE_REF191=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_id2619); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RULE_REF191_tree = (GrammarAST)adaptor.Create(ID,RULE_REF191);
				adaptor.AddChild(root_0, RULE_REF191_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("id", 44);
			LeaveRule("id", 44);
			LeaveRule_id();
		}
		DebugLocation(590, 1);
		} finally { DebugExitRule(GrammarFileName, "id"); }
		return retval;

	}
	// $ANTLR end "id"

	partial void EnterRule_rewrite();
	partial void LeaveRule_rewrite();
	// $ANTLR start "rewrite"
	// Grammars\\ANTLR.g3:594:1: rewrite : ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) ) |);
	[GrammarRule("rewrite")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite()
	{
		EnterRule_rewrite();
		EnterRule("rewrite", 45);
		TraceIn("rewrite", 45);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken REWRITE193 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_with_sempred192 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_alternative194 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST REWRITE193_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_REWRITE=new RewriteRuleITokenStream(adaptor,"token REWRITE");
		RewriteRuleSubtreeStream stream_rewrite_with_sempred=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_with_sempred");
		RewriteRuleSubtreeStream stream_rewrite_alternative=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_alternative");
		try { DebugEnterRule(GrammarFileName, "rewrite");
		DebugLocation(594, 1);
		try
		{
			// Grammars\\ANTLR.g3:595:2: ( ( rewrite_with_sempred )* REWRITE rewrite_alternative -> ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) ) |)
			int alt84=2;
			try { DebugEnterDecision(84, false);
			int LA84_1 = input.LA(1);

			if ((LA84_1==REWRITE))
			{
				alt84 = 1;
			}
			else if ((LA84_1==OR||LA84_1==RPAREN||LA84_1==SEMI))
			{
				alt84 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 84, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(84); }
			switch (alt84)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:595:4: ( rewrite_with_sempred )* REWRITE rewrite_alternative
				{
				DebugLocation(595, 4);
				// Grammars\\ANTLR.g3:595:4: ( rewrite_with_sempred )*
				try { DebugEnterSubRule(83);
				while (true)
				{
					int alt83=2;
					try { DebugEnterDecision(83, false);
					int LA83_1 = input.LA(1);

					if ((LA83_1==REWRITE))
					{
						int LA83_2 = input.LA(2);

						if ((LA83_2==SEMPRED))
						{
							alt83 = 1;
						}


					}


					} finally { DebugExitDecision(83); }
					switch ( alt83 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:595:4: rewrite_with_sempred
						{
						DebugLocation(595, 4);
						PushFollow(Follow._rewrite_with_sempred_in_rewrite2635);
						rewrite_with_sempred192=rewrite_with_sempred();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_rewrite_with_sempred.Add(rewrite_with_sempred192.Tree);

						}
						break;

					default:
						goto loop83;
					}
				}

				loop83:
					;

				} finally { DebugExitSubRule(83); }

				DebugLocation(596, 3);
				REWRITE193=(IToken)Match(input,REWRITE,Follow._REWRITE_in_rewrite2640); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_REWRITE.Add(REWRITE193);

				DebugLocation(596, 11);
				PushFollow(Follow._rewrite_alternative_in_rewrite2642);
				rewrite_alternative194=rewrite_alternative();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_rewrite_alternative.Add(rewrite_alternative194.Tree);


				{
				// AST REWRITE
				// elements: rewrite_with_sempred, REWRITE, rewrite_alternative
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 597:3: -> ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) )
				{
					DebugLocation(597, 6);
					// Grammars\\ANTLR.g3:597:6: ^( REWRITES ( rewrite_with_sempred )* ^( REWRITE rewrite_alternative ) )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(597, 8);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(REWRITES, "REWRITES"), root_1);

					DebugLocation(597, 17);
					// Grammars\\ANTLR.g3:597:17: ( rewrite_with_sempred )*
					while ( stream_rewrite_with_sempred.HasNext )
					{
						DebugLocation(597, 17);
						adaptor.AddChild(root_1, stream_rewrite_with_sempred.NextTree());

					}
					stream_rewrite_with_sempred.Reset();
					DebugLocation(597, 39);
					// Grammars\\ANTLR.g3:597:39: ^( REWRITE rewrite_alternative )
					{
					GrammarAST root_2 = (GrammarAST)adaptor.Nil();
					DebugLocation(597, 41);
					root_2 = (GrammarAST)adaptor.BecomeRoot(stream_REWRITE.NextNode(), root_2);

					DebugLocation(597, 49);
					adaptor.AddChild(root_2, stream_rewrite_alternative.NextTree());

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:599:2: 
				{
				root_0 = (GrammarAST)adaptor.Nil();

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite", 45);
			LeaveRule("rewrite", 45);
			LeaveRule_rewrite();
		}
		DebugLocation(599, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite"); }
		return retval;

	}
	// $ANTLR end "rewrite"

	partial void EnterRule_rewrite_with_sempred();
	partial void LeaveRule_rewrite_with_sempred();
	// $ANTLR start "rewrite_with_sempred"
	// Grammars\\ANTLR.g3:601:1: rewrite_with_sempred : REWRITE ^ SEMPRED rewrite_alternative ;
	[GrammarRule("rewrite_with_sempred")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_with_sempred()
	{
		EnterRule_rewrite_with_sempred();
		EnterRule("rewrite_with_sempred", 46);
		TraceIn("rewrite_with_sempred", 46);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken REWRITE195 = default(IToken);
		IToken SEMPRED196 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_alternative197 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST REWRITE195_tree = default(GrammarAST);
		GrammarAST SEMPRED196_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_with_sempred");
		DebugLocation(601, 1);
		try
		{
			// Grammars\\ANTLR.g3:602:2: ( REWRITE ^ SEMPRED rewrite_alternative )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:602:4: REWRITE ^ SEMPRED rewrite_alternative
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(602, 11);
			REWRITE195=(IToken)Match(input,REWRITE,Follow._REWRITE_in_rewrite_with_sempred2673); if (state.failed) return retval;
			if (state.backtracking == 0) {
			REWRITE195_tree = (GrammarAST)adaptor.Create(REWRITE195);
			root_0 = (GrammarAST)adaptor.BecomeRoot(REWRITE195_tree, root_0);
			}
			DebugLocation(602, 13);
			SEMPRED196=(IToken)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite_with_sempred2676); if (state.failed) return retval;
			if (state.backtracking == 0) {
			SEMPRED196_tree = (GrammarAST)adaptor.Create(SEMPRED196);
			adaptor.AddChild(root_0, SEMPRED196_tree);
			}
			DebugLocation(602, 21);
			PushFollow(Follow._rewrite_alternative_in_rewrite_with_sempred2678);
			rewrite_alternative197=rewrite_alternative();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_alternative197.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_with_sempred", 46);
			LeaveRule("rewrite_with_sempred", 46);
			LeaveRule_rewrite_with_sempred();
		}
		DebugLocation(603, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_with_sempred"); }
		return retval;

	}
	// $ANTLR end "rewrite_with_sempred"

	partial void EnterRule_rewrite_block();
	partial void LeaveRule_rewrite_block();
	// $ANTLR start "rewrite_block"
	// Grammars\\ANTLR.g3:605:1: rewrite_block : LPAREN ^ rewrite_alternative RPAREN ;
	[GrammarRule("rewrite_block")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_block()
	{
		EnterRule_rewrite_block();
		EnterRule("rewrite_block", 47);
		TraceIn("rewrite_block", 47);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken LPAREN198 = default(IToken);
		IToken RPAREN200 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_alternative199 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST LPAREN198_tree = default(GrammarAST);
		GrammarAST RPAREN200_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_block");
		DebugLocation(605, 1);
		try
		{
			// Grammars\\ANTLR.g3:606:2: ( LPAREN ^ rewrite_alternative RPAREN )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:606:4: LPAREN ^ rewrite_alternative RPAREN
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(606, 35);
			LPAREN198=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_block2689); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN198_tree = (GrammarAST)adaptor.Create(BLOCK,LPAREN198,"BLOCK");
			root_0 = (GrammarAST)adaptor.BecomeRoot(LPAREN198_tree, root_0);
			}
			DebugLocation(607, 3);
			PushFollow(Follow._rewrite_alternative_in_rewrite_block2703);
			rewrite_alternative199=rewrite_alternative();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_alternative199.Tree);
			DebugLocation(608, 3);
			RPAREN200=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_block2707); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RPAREN200_tree = (GrammarAST)adaptor.Create(EOB,RPAREN200,"<end-of-block>");
			adaptor.AddChild(root_0, RPAREN200_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_block", 47);
			LeaveRule("rewrite_block", 47);
			LeaveRule_rewrite_block();
		}
		DebugLocation(609, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_block"); }
		return retval;

	}
	// $ANTLR end "rewrite_block"

	partial void EnterRule_rewrite_alternative();
	partial void LeaveRule_rewrite_alternative();
	// $ANTLR start "rewrite_alternative"
	// Grammars\\ANTLR.g3:611:1: rewrite_alternative options {k=1; } : ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC );
	[GrammarRule("rewrite_alternative")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_alternative()
	{
		EnterRule_rewrite_alternative();
		EnterRule("rewrite_alternative", 48);
		TraceIn("rewrite_alternative", 48);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ETC203 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template201 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_element202 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ETC203_tree = default(GrammarAST);
		RewriteRuleSubtreeStream stream_rewrite_element=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_element");
		try { DebugEnterRule(GrammarFileName, "rewrite_alternative");
		DebugLocation(611, 1);
		try
		{
			// Grammars\\ANTLR.g3:613:2: ({...}? => rewrite_template |{...}? => ( rewrite_element )+ -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] ) | -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] ) |{...}? ETC )
			int alt86=4;
			try { DebugEnterDecision(86, false);
			int LA86_1 = input.LA(1);

			if ((LA86_1==TOKEN_REF) && (((Grammar.BuildTemplate)||(Grammar.BuildAST)||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template"))))))
			{
				int LA86_2 = input.LA(2);

				if (((Grammar.BuildTemplate)))
				{
					alt86 = 1;
				}
				else if (((Grammar.BuildAST)))
				{
					alt86 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA86_1==RULE_REF) && (((Grammar.BuildTemplate)||(Grammar.BuildAST)||((Grammar.BuildTemplate)&&(LT(1).Text.Equals("template"))))))
			{
				int LA86_2 = input.LA(2);

				if (((Grammar.BuildTemplate)))
				{
					alt86 = 1;
				}
				else if (((Grammar.BuildAST)))
				{
					alt86 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA86_1==LPAREN) && (((Grammar.BuildTemplate)||(Grammar.BuildAST))))
			{
				int LA86_2 = input.LA(2);

				if (((Grammar.BuildTemplate)))
				{
					alt86 = 1;
				}
				else if (((Grammar.BuildAST)))
				{
					alt86 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA86_1==ACTION) && (((Grammar.BuildTemplate)||(Grammar.BuildAST))))
			{
				int LA86_2 = input.LA(2);

				if (((Grammar.BuildTemplate)))
				{
					alt86 = 1;
				}
				else if (((Grammar.BuildAST)))
				{
					alt86 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA86_1==CHAR_LITERAL||LA86_1==DOLLAR||LA86_1==STRING_LITERAL||LA86_1==TREE_BEGIN) && ((Grammar.BuildAST)))
			{
				alt86 = 2;
			}
			else if ((LA86_1==OR||LA86_1==REWRITE||LA86_1==RPAREN||LA86_1==SEMI))
			{
				alt86 = 3;
			}
			else if ((LA86_1==ETC))
			{
				alt86 = 4;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 86, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(86); }
			switch (alt86)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:613:4: {...}? => rewrite_template
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(613, 4);
				if (!((Grammar.BuildTemplate)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildTemplate");
				}
				DebugLocation(613, 32);
				PushFollow(Follow._rewrite_template_in_rewrite_alternative2738);
				rewrite_template201=rewrite_template();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_template201.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:615:4: {...}? => ( rewrite_element )+
				{
				DebugLocation(615, 4);
				if (!((Grammar.BuildAST)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildAST");
				}
				DebugLocation(615, 27);
				// Grammars\\ANTLR.g3:615:27: ( rewrite_element )+
				int cnt85=0;
				try { DebugEnterSubRule(85);
				while (true)
				{
					int alt85=2;
					try { DebugEnterDecision(85, false);
					int LA85_1 = input.LA(1);

					if ((LA85_1==ACTION||LA85_1==CHAR_LITERAL||LA85_1==DOLLAR||LA85_1==LPAREN||LA85_1==RULE_REF||LA85_1==STRING_LITERAL||LA85_1==TOKEN_REF||LA85_1==TREE_BEGIN))
					{
						alt85 = 1;
					}


					} finally { DebugExitDecision(85); }
					switch (alt85)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:615:29: rewrite_element
						{
						DebugLocation(615, 29);
						PushFollow(Follow._rewrite_element_in_rewrite_alternative2750);
						rewrite_element202=rewrite_element();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_rewrite_element.Add(rewrite_element202.Tree);

						}
						break;

					default:
						if (cnt85 >= 1)
							goto loop85;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee85 = new EarlyExitException( 85, input );
						DebugRecognitionException(eee85);
						throw eee85;
					}
					cnt85++;
				}
				loop85:
					;

				} finally { DebugExitSubRule(85); }



				{
				// AST REWRITE
				// elements: rewrite_element
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 616:3: -> {!stream_rewrite_element.HasNext}? ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
				if (!stream_rewrite_element.HasNext)
				{
					DebugLocation(616, 41);
					// Grammars\\ANTLR.g3:616:41: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(616, 43);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);

					DebugLocation(616, 60);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, "epsilon"));
					DebugLocation(616, 79);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 617:3: -> ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
				{
					DebugLocation(617, 6);
					// Grammars\\ANTLR.g3:617:6: ^( ALT[LT(1),\"ALT\"] ( rewrite_element )+ EOA[\"<end-of-alt>\"] )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(617, 8);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);

					DebugLocation(617, 25);
					if (!(stream_rewrite_element.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_rewrite_element.HasNext )
					{
						DebugLocation(617, 25);
						adaptor.AddChild(root_1, stream_rewrite_element.NextTree());

					}
					stream_rewrite_element.Reset();
					DebugLocation(617, 42);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:620:3: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 620:3: -> ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
				{
					DebugLocation(620, 6);
					// Grammars\\ANTLR.g3:620:6: ^( ALT[LT(1),\"ALT\"] EPSILON[\"epsilon\"] EOA[\"<end-of-alt>\"] )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(620, 8);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, LT(1), "ALT"), root_1);

					DebugLocation(620, 25);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, "epsilon"));
					DebugLocation(620, 44);
					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:621:4: {...}? ETC
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(621, 4);
				if (!((Grammar.BuildAST)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "rewrite_alternative", "Grammar.BuildAST");
				}
				DebugLocation(621, 24);
				ETC203=(IToken)Match(input,ETC,Follow._ETC_in_rewrite_alternative2811); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ETC203_tree = (GrammarAST)adaptor.Create(ETC203);
				adaptor.AddChild(root_0, ETC203_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_alternative", 48);
			LeaveRule("rewrite_alternative", 48);
			LeaveRule_rewrite_alternative();
		}
		DebugLocation(622, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_alternative"); }
		return retval;

	}
	// $ANTLR end "rewrite_alternative"

	partial void EnterRule_rewrite_element();
	partial void LeaveRule_rewrite_element();
	// $ANTLR start "rewrite_element"
	// Grammars\\ANTLR.g3:624:1: rewrite_element : ( ( rewrite_atom -> rewrite_atom ) ( ebnfSuffix[$rewrite_atom.tree,true] -> ebnfSuffix )? | rewrite_ebnf | ( rewrite_tree -> rewrite_tree ) ( ebnfSuffix[$rewrite_tree.tree,true] -> ebnfSuffix )? );
	[GrammarRule("rewrite_element")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_element()
	{
		EnterRule_rewrite_element();
		EnterRule("rewrite_element", 49);
		TraceIn("rewrite_element", 49);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_atom204 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ebnfSuffix205 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_ebnf206 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_tree207 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> ebnfSuffix208 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		RewriteRuleSubtreeStream stream_rewrite_atom=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_atom");
		RewriteRuleSubtreeStream stream_ebnfSuffix=new RewriteRuleSubtreeStream(adaptor,"rule ebnfSuffix");
		RewriteRuleSubtreeStream stream_rewrite_tree=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_tree");
		try { DebugEnterRule(GrammarFileName, "rewrite_element");
		DebugLocation(624, 1);
		try
		{
			// Grammars\\ANTLR.g3:625:2: ( ( rewrite_atom -> rewrite_atom ) ( ebnfSuffix[$rewrite_atom.tree,true] -> ebnfSuffix )? | rewrite_ebnf | ( rewrite_tree -> rewrite_tree ) ( ebnfSuffix[$rewrite_tree.tree,true] -> ebnfSuffix )? )
			int alt89=3;
			try { DebugEnterDecision(89, false);
			switch (input.LA(1))
			{
			case ACTION:
			case CHAR_LITERAL:
			case DOLLAR:
			case RULE_REF:
			case STRING_LITERAL:
			case TOKEN_REF:
				{
				alt89 = 1;
				}
				break;
			case LPAREN:
				{
				alt89 = 2;
				}
				break;
			case TREE_BEGIN:
				{
				alt89 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 89, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:625:4: ( rewrite_atom -> rewrite_atom ) ( ebnfSuffix[$rewrite_atom.tree,true] -> ebnfSuffix )?
				{
				DebugLocation(625, 4);
				// Grammars\\ANTLR.g3:625:4: ( rewrite_atom -> rewrite_atom )
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:625:6: rewrite_atom
				{
				DebugLocation(625, 6);
				PushFollow(Follow._rewrite_atom_in_rewrite_element2824);
				rewrite_atom204=rewrite_atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_rewrite_atom.Add(rewrite_atom204.Tree);


				{
				// AST REWRITE
				// elements: rewrite_atom
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 626:4: -> rewrite_atom
				{
					DebugLocation(626, 7);
					adaptor.AddChild(root_0, stream_rewrite_atom.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}

				DebugLocation(628, 3);
				// Grammars\\ANTLR.g3:628:3: ( ebnfSuffix[$rewrite_atom.tree,true] -> ebnfSuffix )?
				int alt87=2;
				try { DebugEnterSubRule(87);
				try { DebugEnterDecision(87, false);
				int LA87_1 = input.LA(1);

				if ((LA87_1==PLUS||LA87_1==QUESTION||LA87_1==STAR))
				{
					alt87 = 1;
				}
				} finally { DebugExitDecision(87); }
				switch (alt87)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:628:5: ebnfSuffix[$rewrite_atom.tree,true]
					{
					DebugLocation(628, 5);
					PushFollow(Follow._ebnfSuffix_in_rewrite_element2841);
					ebnfSuffix205=ebnfSuffix((rewrite_atom204!=null?((GrammarAST)rewrite_atom204.Tree):default(GrammarAST)), true);
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_ebnfSuffix.Add(ebnfSuffix205.Tree);


					{
					// AST REWRITE
					// elements: ebnfSuffix
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (GrammarAST)adaptor.Nil();
					// 629:4: -> ebnfSuffix
					{
						DebugLocation(629, 7);
						adaptor.AddChild(root_0, stream_ebnfSuffix.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(87); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:631:4: rewrite_ebnf
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(631, 4);
				PushFollow(Follow._rewrite_ebnf_in_rewrite_element2859);
				rewrite_ebnf206=rewrite_ebnf();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_ebnf206.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:632:4: ( rewrite_tree -> rewrite_tree ) ( ebnfSuffix[$rewrite_tree.tree,true] -> ebnfSuffix )?
				{
				DebugLocation(632, 4);
				// Grammars\\ANTLR.g3:632:4: ( rewrite_tree -> rewrite_tree )
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:632:6: rewrite_tree
				{
				DebugLocation(632, 6);
				PushFollow(Follow._rewrite_tree_in_rewrite_element2866);
				rewrite_tree207=rewrite_tree();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_rewrite_tree.Add(rewrite_tree207.Tree);


				{
				// AST REWRITE
				// elements: rewrite_tree
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 633:4: -> rewrite_tree
				{
					DebugLocation(633, 7);
					adaptor.AddChild(root_0, stream_rewrite_tree.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}

				DebugLocation(635, 3);
				// Grammars\\ANTLR.g3:635:3: ( ebnfSuffix[$rewrite_tree.tree,true] -> ebnfSuffix )?
				int alt88=2;
				try { DebugEnterSubRule(88);
				try { DebugEnterDecision(88, false);
				int LA88_1 = input.LA(1);

				if ((LA88_1==PLUS||LA88_1==QUESTION||LA88_1==STAR))
				{
					alt88 = 1;
				}
				} finally { DebugExitDecision(88); }
				switch (alt88)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:635:5: ebnfSuffix[$rewrite_tree.tree,true]
					{
					DebugLocation(635, 5);
					PushFollow(Follow._ebnfSuffix_in_rewrite_element2883);
					ebnfSuffix208=ebnfSuffix((rewrite_tree207!=null?((GrammarAST)rewrite_tree207.Tree):default(GrammarAST)), true);
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_ebnfSuffix.Add(ebnfSuffix208.Tree);


					{
					// AST REWRITE
					// elements: ebnfSuffix
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (GrammarAST)adaptor.Nil();
					// 636:4: -> ebnfSuffix
					{
						DebugLocation(636, 7);
						adaptor.AddChild(root_0, stream_ebnfSuffix.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(88); }


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_element", 49);
			LeaveRule("rewrite_element", 49);
			LeaveRule_rewrite_element();
		}
		DebugLocation(638, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_element"); }
		return retval;

	}
	// $ANTLR end "rewrite_element"

	partial void EnterRule_rewrite_atom();
	partial void LeaveRule_rewrite_atom();
	// $ANTLR start "rewrite_atom"
	// Grammars\\ANTLR.g3:640:1: rewrite_atom : ( TOKEN_REF ^ ( elementOptions[$TOKEN_REF.tree] !)? ( ARG_ACTION )? | RULE_REF | CHAR_LITERAL ( elementOptions[$CHAR_LITERAL.tree] !)? | STRING_LITERAL ( elementOptions[$STRING_LITERAL.tree] !)? | DOLLAR ! label | ACTION );
	[GrammarRule("rewrite_atom")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_atom()
	{
		EnterRule_rewrite_atom();
		EnterRule("rewrite_atom", 50);
		TraceIn("rewrite_atom", 50);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TOKEN_REF209 = default(IToken);
		IToken ARG_ACTION211 = default(IToken);
		IToken RULE_REF212 = default(IToken);
		IToken CHAR_LITERAL213 = default(IToken);
		IToken STRING_LITERAL215 = default(IToken);
		IToken DOLLAR217 = default(IToken);
		IToken ACTION219 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptions210 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptions214 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> elementOptions216 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> label218 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST TOKEN_REF209_tree = default(GrammarAST);
		GrammarAST ARG_ACTION211_tree = default(GrammarAST);
		GrammarAST RULE_REF212_tree = default(GrammarAST);
		GrammarAST CHAR_LITERAL213_tree = default(GrammarAST);
		GrammarAST STRING_LITERAL215_tree = default(GrammarAST);
		GrammarAST DOLLAR217_tree = default(GrammarAST);
		GrammarAST ACTION219_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_atom");
		DebugLocation(640, 1);
		try
		{
			// Grammars\\ANTLR.g3:641:2: ( TOKEN_REF ^ ( elementOptions[$TOKEN_REF.tree] !)? ( ARG_ACTION )? | RULE_REF | CHAR_LITERAL ( elementOptions[$CHAR_LITERAL.tree] !)? | STRING_LITERAL ( elementOptions[$STRING_LITERAL.tree] !)? | DOLLAR ! label | ACTION )
			int alt94=6;
			try { DebugEnterDecision(94, false);
			switch (input.LA(1))
			{
			case TOKEN_REF:
				{
				alt94 = 1;
				}
				break;
			case RULE_REF:
				{
				alt94 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt94 = 3;
				}
				break;
			case STRING_LITERAL:
				{
				alt94 = 4;
				}
				break;
			case DOLLAR:
				{
				alt94 = 5;
				}
				break;
			case ACTION:
				{
				alt94 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 94, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(94); }
			switch (alt94)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:641:4: TOKEN_REF ^ ( elementOptions[$TOKEN_REF.tree] !)? ( ARG_ACTION )?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(641, 13);
				TOKEN_REF209=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom2907); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TOKEN_REF209_tree = (GrammarAST)adaptor.Create(TOKEN_REF209);
				root_0 = (GrammarAST)adaptor.BecomeRoot(TOKEN_REF209_tree, root_0);
				}
				DebugLocation(641, 46);
				// Grammars\\ANTLR.g3:641:46: ( elementOptions[$TOKEN_REF.tree] !)?
				int alt90=2;
				try { DebugEnterSubRule(90);
				try { DebugEnterDecision(90, false);
				int LA90_1 = input.LA(1);

				if ((LA90_1==OPEN_ELEMENT_OPTION))
				{
					alt90 = 1;
				}
				} finally { DebugExitDecision(90); }
				switch (alt90)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:641:46: elementOptions[$TOKEN_REF.tree] !
					{
					DebugLocation(641, 46);
					PushFollow(Follow._elementOptions_in_rewrite_atom2910);
					elementOptions210=elementOptions(TOKEN_REF209_tree);
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(90); }

				DebugLocation(641, 49);
				// Grammars\\ANTLR.g3:641:49: ( ARG_ACTION )?
				int alt91=2;
				try { DebugEnterSubRule(91);
				try { DebugEnterDecision(91, false);
				int LA91_1 = input.LA(1);

				if ((LA91_1==ARG_ACTION))
				{
					alt91 = 1;
				}
				} finally { DebugExitDecision(91); }
				switch (alt91)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:641:49: ARG_ACTION
					{
					DebugLocation(641, 49);
					ARG_ACTION211=(IToken)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom2915); if (state.failed) return retval;
					if (state.backtracking == 0) {
					ARG_ACTION211_tree = (GrammarAST)adaptor.Create(ARG_ACTION211);
					adaptor.AddChild(root_0, ARG_ACTION211_tree);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(91); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:642:4: RULE_REF
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(642, 4);
				RULE_REF212=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom2922); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RULE_REF212_tree = (GrammarAST)adaptor.Create(RULE_REF212);
				adaptor.AddChild(root_0, RULE_REF212_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:643:4: CHAR_LITERAL ( elementOptions[$CHAR_LITERAL.tree] !)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(643, 4);
				CHAR_LITERAL213=(IToken)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom2927); if (state.failed) return retval;
				if (state.backtracking == 0) {
				CHAR_LITERAL213_tree = (GrammarAST)adaptor.Create(CHAR_LITERAL213);
				adaptor.AddChild(root_0, CHAR_LITERAL213_tree);
				}
				DebugLocation(643, 51);
				// Grammars\\ANTLR.g3:643:51: ( elementOptions[$CHAR_LITERAL.tree] !)?
				int alt92=2;
				try { DebugEnterSubRule(92);
				try { DebugEnterDecision(92, false);
				int LA92_1 = input.LA(1);

				if ((LA92_1==OPEN_ELEMENT_OPTION))
				{
					alt92 = 1;
				}
				} finally { DebugExitDecision(92); }
				switch (alt92)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:643:51: elementOptions[$CHAR_LITERAL.tree] !
					{
					DebugLocation(643, 51);
					PushFollow(Follow._elementOptions_in_rewrite_atom2929);
					elementOptions214=elementOptions(CHAR_LITERAL213_tree);
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(92); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:644:4: STRING_LITERAL ( elementOptions[$STRING_LITERAL.tree] !)?
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(644, 4);
				STRING_LITERAL215=(IToken)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom2937); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STRING_LITERAL215_tree = (GrammarAST)adaptor.Create(STRING_LITERAL215);
				adaptor.AddChild(root_0, STRING_LITERAL215_tree);
				}
				DebugLocation(644, 55);
				// Grammars\\ANTLR.g3:644:55: ( elementOptions[$STRING_LITERAL.tree] !)?
				int alt93=2;
				try { DebugEnterSubRule(93);
				try { DebugEnterDecision(93, false);
				int LA93_1 = input.LA(1);

				if ((LA93_1==OPEN_ELEMENT_OPTION))
				{
					alt93 = 1;
				}
				} finally { DebugExitDecision(93); }
				switch (alt93)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:644:55: elementOptions[$STRING_LITERAL.tree] !
					{
					DebugLocation(644, 55);
					PushFollow(Follow._elementOptions_in_rewrite_atom2939);
					elementOptions216=elementOptions(STRING_LITERAL215_tree);
					PopFollow();
					if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(93); }


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\ANTLR.g3:645:4: DOLLAR ! label
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(645, 10);
				DOLLAR217=(IToken)Match(input,DOLLAR,Follow._DOLLAR_in_rewrite_atom2947); if (state.failed) return retval;
				DebugLocation(645, 12);
				PushFollow(Follow._label_in_rewrite_atom2950);
				label218=label();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, label218.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\ANTLR.g3:646:4: ACTION
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(646, 4);
				ACTION219=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_atom2956); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ACTION219_tree = (GrammarAST)adaptor.Create(ACTION219);
				adaptor.AddChild(root_0, ACTION219_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_atom", 50);
			LeaveRule("rewrite_atom", 50);
			LeaveRule_rewrite_atom();
		}
		DebugLocation(647, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_atom"); }
		return retval;

	}
	// $ANTLR end "rewrite_atom"

	partial void EnterRule_label();
	partial void LeaveRule_label();
	// $ANTLR start "label"
	// Grammars\\ANTLR.g3:649:1: label : ( TOKEN_REF | RULE_REF );
	[GrammarRule("label")]
	private AstParserRuleReturnScope<GrammarAST, IToken> label()
	{
		EnterRule_label();
		EnterRule("label", 51);
		TraceIn("label", 51);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TOKEN_REF220 = default(IToken);
		IToken RULE_REF221 = default(IToken);

		GrammarAST TOKEN_REF220_tree = default(GrammarAST);
		GrammarAST RULE_REF221_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "label");
		DebugLocation(649, 1);
		try
		{
			// Grammars\\ANTLR.g3:650:2: ( TOKEN_REF | RULE_REF )
			int alt95=2;
			try { DebugEnterDecision(95, false);
			int LA95_1 = input.LA(1);

			if ((LA95_1==TOKEN_REF))
			{
				alt95 = 1;
			}
			else if ((LA95_1==RULE_REF))
			{
				alt95 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 95, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(95); }
			switch (alt95)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:650:4: TOKEN_REF
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(650, 4);
				TOKEN_REF220=(IToken)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_label2967); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TOKEN_REF220_tree = (GrammarAST)adaptor.Create(LABEL,TOKEN_REF220);
				adaptor.AddChild(root_0, TOKEN_REF220_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:651:4: RULE_REF
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(651, 4);
				RULE_REF221=(IToken)Match(input,RULE_REF,Follow._RULE_REF_in_label2975); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RULE_REF221_tree = (GrammarAST)adaptor.Create(LABEL,RULE_REF221);
				adaptor.AddChild(root_0, RULE_REF221_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("label", 51);
			LeaveRule("label", 51);
			LeaveRule_label();
		}
		DebugLocation(652, 1);
		} finally { DebugExitRule(GrammarFileName, "label"); }
		return retval;

	}
	// $ANTLR end "label"

	partial void EnterRule_rewrite_ebnf();
	partial void LeaveRule_rewrite_ebnf();
	// $ANTLR start "rewrite_ebnf"
	// Grammars\\ANTLR.g3:654:1: rewrite_ebnf : b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) ;
	[GrammarRule("rewrite_ebnf")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_ebnf()
	{
		EnterRule_rewrite_ebnf();
		EnterRule("rewrite_ebnf", 52);
		TraceIn("rewrite_ebnf", 52);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken QUESTION222 = default(IToken);
		IToken STAR223 = default(IToken);
		IToken PLUS224 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> b = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST QUESTION222_tree = default(GrammarAST);
		GrammarAST STAR223_tree = default(GrammarAST);
		GrammarAST PLUS224_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleSubtreeStream stream_rewrite_block=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_block");
		try { DebugEnterRule(GrammarFileName, "rewrite_ebnf");
		DebugLocation(654, 1);
		try
		{
			// Grammars\\ANTLR.g3:655:2: (b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:655:4: b= rewrite_block ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
			{
			DebugLocation(655, 5);
			PushFollow(Follow._rewrite_block_in_rewrite_ebnf2991);
			b=rewrite_block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rewrite_block.Add(b.Tree);
			DebugLocation(656, 3);
			// Grammars\\ANTLR.g3:656:3: ( QUESTION -> ^( OPTIONAL[$b.start,\"?\"] $b) | STAR -> ^( CLOSURE[$b.start,\"*\"] $b) | PLUS -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b) )
			int alt96=3;
			try { DebugEnterSubRule(96);
			try { DebugEnterDecision(96, false);
			switch (input.LA(1))
			{
			case QUESTION:
				{
				alt96 = 1;
				}
				break;
			case STAR:
				{
				alt96 = 2;
				}
				break;
			case PLUS:
				{
				alt96 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 96, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:656:5: QUESTION
				{
				DebugLocation(656, 5);
				QUESTION222=(IToken)Match(input,QUESTION,Follow._QUESTION_in_rewrite_ebnf2997); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUESTION.Add(QUESTION222);



				{
				// AST REWRITE
				// elements: b
				// token labels: 
				// rule labels: b, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 657:4: -> ^( OPTIONAL[$b.start,\"?\"] $b)
				{
					DebugLocation(657, 7);
					// Grammars\\ANTLR.g3:657:7: ^( OPTIONAL[$b.start,\"?\"] $b)
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(657, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, (b!=null?((IToken)b.Start):default(IToken)), "?"), root_1);

					DebugLocation(657, 33);
					adaptor.AddChild(root_1, stream_b.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:658:5: STAR
				{
				DebugLocation(658, 5);
				STAR223=(IToken)Match(input,STAR,Follow._STAR_in_rewrite_ebnf3016); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR223);



				{
				// AST REWRITE
				// elements: b
				// token labels: 
				// rule labels: b, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 659:4: -> ^( CLOSURE[$b.start,\"*\"] $b)
				{
					DebugLocation(659, 7);
					// Grammars\\ANTLR.g3:659:7: ^( CLOSURE[$b.start,\"*\"] $b)
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(659, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, (b!=null?((IToken)b.Start):default(IToken)), "*"), root_1);

					DebugLocation(659, 32);
					adaptor.AddChild(root_1, stream_b.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:660:5: PLUS
				{
				DebugLocation(660, 5);
				PLUS224=(IToken)Match(input,PLUS,Follow._PLUS_in_rewrite_ebnf3035); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PLUS.Add(PLUS224);



				{
				// AST REWRITE
				// elements: b
				// token labels: 
				// rule labels: b, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_b=new RewriteRuleSubtreeStream(adaptor,"rule b",b!=null?b.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 661:4: -> ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
				{
					DebugLocation(661, 7);
					// Grammars\\ANTLR.g3:661:7: ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(661, 9);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, (b!=null?((IToken)b.Start):default(IToken)), "+"), root_1);

					DebugLocation(661, 41);
					adaptor.AddChild(root_1, stream_b.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(96); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_ebnf", 52);
			LeaveRule("rewrite_ebnf", 52);
			LeaveRule_rewrite_ebnf();
		}
		DebugLocation(663, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_ebnf"); }
		return retval;

	}
	// $ANTLR end "rewrite_ebnf"

	partial void EnterRule_rewrite_tree();
	partial void LeaveRule_rewrite_tree();
	// $ANTLR start "rewrite_tree"
	// Grammars\\ANTLR.g3:665:1: rewrite_tree : TREE_BEGIN ^ rewrite_atom ( rewrite_element )* RPAREN !;
	[GrammarRule("rewrite_tree")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_tree()
	{
		EnterRule_rewrite_tree();
		EnterRule("rewrite_tree", 53);
		TraceIn("rewrite_tree", 53);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken TREE_BEGIN225 = default(IToken);
		IToken RPAREN228 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_atom226 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_element227 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST TREE_BEGIN225_tree = default(GrammarAST);
		GrammarAST RPAREN228_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_tree");
		DebugLocation(665, 1);
		try
		{
			// Grammars\\ANTLR.g3:666:2: ( TREE_BEGIN ^ rewrite_atom ( rewrite_element )* RPAREN !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:666:4: TREE_BEGIN ^ rewrite_atom ( rewrite_element )* RPAREN !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(666, 14);
			TREE_BEGIN225=(IToken)Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree3063); if (state.failed) return retval;
			if (state.backtracking == 0) {
			TREE_BEGIN225_tree = (GrammarAST)adaptor.Create(TREE_BEGIN225);
			root_0 = (GrammarAST)adaptor.BecomeRoot(TREE_BEGIN225_tree, root_0);
			}
			DebugLocation(667, 4);
			PushFollow(Follow._rewrite_atom_in_rewrite_tree3069);
			rewrite_atom226=rewrite_atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_atom226.Tree);
			DebugLocation(667, 17);
			// Grammars\\ANTLR.g3:667:17: ( rewrite_element )*
			try { DebugEnterSubRule(97);
			while (true)
			{
				int alt97=2;
				try { DebugEnterDecision(97, false);
				int LA97_1 = input.LA(1);

				if ((LA97_1==ACTION||LA97_1==CHAR_LITERAL||LA97_1==DOLLAR||LA97_1==LPAREN||LA97_1==RULE_REF||LA97_1==STRING_LITERAL||LA97_1==TOKEN_REF||LA97_1==TREE_BEGIN))
				{
					alt97 = 1;
				}


				} finally { DebugExitDecision(97); }
				switch ( alt97 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:667:17: rewrite_element
					{
					DebugLocation(667, 17);
					PushFollow(Follow._rewrite_element_in_rewrite_tree3071);
					rewrite_element227=rewrite_element();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_element227.Tree);

					}
					break;

				default:
					goto loop97;
				}
			}

			loop97:
				;

			} finally { DebugExitSubRule(97); }

			DebugLocation(668, 9);
			RPAREN228=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_tree3076); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_tree", 53);
			LeaveRule("rewrite_tree", 53);
			LeaveRule_rewrite_tree();
		}
		DebugLocation(669, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_tree"); }
		return retval;

	}
	// $ANTLR end "rewrite_tree"

	partial void EnterRule_rewrite_template();
	partial void LeaveRule_rewrite_template();
	// $ANTLR start "rewrite_template"
	// Grammars\\ANTLR.g3:683:1: public rewrite_template options {k=1; } : ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION );
	[GrammarRule("rewrite_template")]
	public AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template()
	{
		EnterRule_rewrite_template();
		EnterRule("rewrite_template", 54);
		TraceIn("rewrite_template", 54);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken st = default(IToken);
		IToken ACTION232 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_head229 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_head230 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_indirect_template_head231 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST st_tree = default(GrammarAST);
		GrammarAST ACTION232_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_DOUBLE_QUOTE_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token DOUBLE_QUOTE_STRING_LITERAL");
		RewriteRuleITokenStream stream_DOUBLE_ANGLE_STRING_LITERAL=new RewriteRuleITokenStream(adaptor,"token DOUBLE_ANGLE_STRING_LITERAL");
		RewriteRuleSubtreeStream stream_rewrite_template_head=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_head");
		try { DebugEnterRule(GrammarFileName, "rewrite_template");
		DebugLocation(683, 1);
		try
		{
			// Grammars\\ANTLR.g3:685:2: ({...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL ) | rewrite_template_head | rewrite_indirect_template_head | ACTION )
			int alt99=4;
			try { DebugEnterDecision(99, false);
			switch (input.LA(1))
			{
			case TOKEN_REF:
				{
				int LA99_2 = input.LA(2);

				if (((LT(1).Text.Equals("template"))))
				{
					alt99 = 1;
				}
				else if ((true))
				{
					alt99 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 99, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RULE_REF:
				{
				int LA99_2 = input.LA(2);

				if (((LT(1).Text.Equals("template"))))
				{
					alt99 = 1;
				}
				else if ((true))
				{
					alt99 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 99, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case LPAREN:
				{
				alt99 = 3;
				}
				break;
			case ACTION:
				{
				alt99 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 99, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:686:3: {...}? => ( rewrite_template_head -> rewrite_template_head ) (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
				{
				DebugLocation(686, 3);
				if (!((LT(1).Text.Equals("template"))))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "rewrite_template", "LT(1).Text.Equals(\"template\")");
				}
				DebugLocation(687, 3);
				// Grammars\\ANTLR.g3:687:3: ( rewrite_template_head -> rewrite_template_head )
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:687:5: rewrite_template_head
				{
				DebugLocation(687, 5);
				PushFollow(Follow._rewrite_template_head_in_rewrite_template3111);
				rewrite_template_head229=rewrite_template_head();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_rewrite_template_head.Add(rewrite_template_head229.Tree);


				{
				// AST REWRITE
				// elements: rewrite_template_head
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 688:4: -> rewrite_template_head
				{
					DebugLocation(688, 7);
					adaptor.AddChild(root_0, stream_rewrite_template_head.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}

				DebugLocation(690, 3);
				// Grammars\\ANTLR.g3:690:3: (st= DOUBLE_QUOTE_STRING_LITERAL |st= DOUBLE_ANGLE_STRING_LITERAL )
				int alt98=2;
				try { DebugEnterSubRule(98);
				try { DebugEnterDecision(98, false);
				int LA98_1 = input.LA(1);

				if ((LA98_1==DOUBLE_QUOTE_STRING_LITERAL))
				{
					alt98 = 1;
				}
				else if ((LA98_1==DOUBLE_ANGLE_STRING_LITERAL))
				{
					alt98 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 98, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(98); }
				switch (alt98)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ANTLR.g3:690:5: st= DOUBLE_QUOTE_STRING_LITERAL
					{
					DebugLocation(690, 7);
					st=(IToken)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3130); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOUBLE_QUOTE_STRING_LITERAL.Add(st);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\ANTLR.g3:690:38: st= DOUBLE_ANGLE_STRING_LITERAL
					{
					DebugLocation(690, 40);
					st=(IToken)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3136); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOUBLE_ANGLE_STRING_LITERAL.Add(st);


					}
					break;

				}
				} finally { DebugExitSubRule(98); }

				DebugLocation(691, 3);
				if (state.backtracking == 0)
				{
					 adaptor.AddChild( retval.Tree.GetChild(0), adaptor.Create(st) ); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:694:3: rewrite_template_head
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(694, 3);
				PushFollow(Follow._rewrite_template_head_in_rewrite_template3151);
				rewrite_template_head230=rewrite_template_head();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_template_head230.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\ANTLR.g3:697:3: rewrite_indirect_template_head
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(697, 3);
				PushFollow(Follow._rewrite_indirect_template_head_in_rewrite_template3160);
				rewrite_indirect_template_head231=rewrite_indirect_template_head();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_indirect_template_head231.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\ANTLR.g3:700:3: ACTION
				{
				root_0 = (GrammarAST)adaptor.Nil();

				DebugLocation(700, 3);
				ACTION232=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_template3169); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ACTION232_tree = (GrammarAST)adaptor.Create(ACTION232);
				adaptor.AddChild(root_0, ACTION232_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_template", 54);
			LeaveRule("rewrite_template", 54);
			LeaveRule_rewrite_template();
		}
		DebugLocation(701, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_template"); }
		return retval;

	}
	// $ANTLR end "rewrite_template"

	partial void EnterRule_rewrite_template_head();
	partial void LeaveRule_rewrite_template_head();
	// $ANTLR start "rewrite_template_head"
	// Grammars\\ANTLR.g3:704:1: rewrite_template_head : id LPAREN ^ rewrite_template_args RPAREN !;
	[GrammarRule("rewrite_template_head")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_head()
	{
		EnterRule_rewrite_template_head();
		EnterRule("rewrite_template_head", 55);
		TraceIn("rewrite_template_head", 55);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken LPAREN234 = default(IToken);
		IToken RPAREN236 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id233 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_args235 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST LPAREN234_tree = default(GrammarAST);
		GrammarAST RPAREN236_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_template_head");
		DebugLocation(704, 1);
		try
		{
			// Grammars\\ANTLR.g3:705:2: ( id LPAREN ^ rewrite_template_args RPAREN !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:705:4: id LPAREN ^ rewrite_template_args RPAREN !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(705, 4);
			PushFollow(Follow._id_in_rewrite_template_head3182);
			id233=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id233.Tree);
			DebugLocation(705, 44);
			LPAREN234=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_template_head3184); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN234_tree = (GrammarAST)adaptor.Create(TEMPLATE,LPAREN234,"TEMPLATE");
			root_0 = (GrammarAST)adaptor.BecomeRoot(LPAREN234_tree, root_0);
			}
			DebugLocation(706, 3);
			PushFollow(Follow._rewrite_template_args_in_rewrite_template_head3198);
			rewrite_template_args235=rewrite_template_args();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_template_args235.Tree);
			DebugLocation(707, 9);
			RPAREN236=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_template_head3202); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_template_head", 55);
			LeaveRule("rewrite_template_head", 55);
			LeaveRule_rewrite_template_head();
		}
		DebugLocation(708, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_template_head"); }
		return retval;

	}
	// $ANTLR end "rewrite_template_head"

	partial void EnterRule_rewrite_indirect_template_head();
	partial void LeaveRule_rewrite_indirect_template_head();
	// $ANTLR start "rewrite_indirect_template_head"
	// Grammars\\ANTLR.g3:711:1: rewrite_indirect_template_head : LPAREN ^ ACTION RPAREN ! LPAREN ! rewrite_template_args RPAREN !;
	[GrammarRule("rewrite_indirect_template_head")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_indirect_template_head()
	{
		EnterRule_rewrite_indirect_template_head();
		EnterRule("rewrite_indirect_template_head", 56);
		TraceIn("rewrite_indirect_template_head", 56);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken LPAREN237 = default(IToken);
		IToken ACTION238 = default(IToken);
		IToken RPAREN239 = default(IToken);
		IToken LPAREN240 = default(IToken);
		IToken RPAREN242 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_args241 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST LPAREN237_tree = default(GrammarAST);
		GrammarAST ACTION238_tree = default(GrammarAST);
		GrammarAST RPAREN239_tree = default(GrammarAST);
		GrammarAST LPAREN240_tree = default(GrammarAST);
		GrammarAST RPAREN242_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_indirect_template_head");
		DebugLocation(711, 1);
		try
		{
			// Grammars\\ANTLR.g3:712:2: ( LPAREN ^ ACTION RPAREN ! LPAREN ! rewrite_template_args RPAREN !)
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:712:4: LPAREN ^ ACTION RPAREN ! LPAREN ! rewrite_template_args RPAREN !
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(712, 41);
			LPAREN237=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_indirect_template_head3216); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN237_tree = (GrammarAST)adaptor.Create(TEMPLATE,LPAREN237,"TEMPLATE");
			root_0 = (GrammarAST)adaptor.BecomeRoot(LPAREN237_tree, root_0);
			}
			DebugLocation(713, 3);
			ACTION238=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_indirect_template_head3230); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION238_tree = (GrammarAST)adaptor.Create(ACTION238);
			adaptor.AddChild(root_0, ACTION238_tree);
			}
			DebugLocation(714, 9);
			RPAREN239=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_indirect_template_head3234); if (state.failed) return retval;
			DebugLocation(715, 9);
			LPAREN240=(IToken)Match(input,LPAREN,Follow._LPAREN_in_rewrite_indirect_template_head3239); if (state.failed) return retval;
			DebugLocation(715, 11);
			PushFollow(Follow._rewrite_template_args_in_rewrite_indirect_template_head3242);
			rewrite_template_args241=rewrite_template_args();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, rewrite_template_args241.Tree);
			DebugLocation(715, 39);
			RPAREN242=(IToken)Match(input,RPAREN,Follow._RPAREN_in_rewrite_indirect_template_head3244); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_indirect_template_head", 56);
			LeaveRule("rewrite_indirect_template_head", 56);
			LeaveRule_rewrite_indirect_template_head();
		}
		DebugLocation(716, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_indirect_template_head"); }
		return retval;

	}
	// $ANTLR end "rewrite_indirect_template_head"

	partial void EnterRule_rewrite_template_args();
	partial void LeaveRule_rewrite_template_args();
	// $ANTLR start "rewrite_template_args"
	// Grammars\\ANTLR.g3:718:1: rewrite_template_args : ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] );
	[GrammarRule("rewrite_template_args")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_args()
	{
		EnterRule_rewrite_template_args();
		EnterRule("rewrite_template_args", 57);
		TraceIn("rewrite_template_args", 57);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken COMMA244 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_arg243 = default(AstParserRuleReturnScope<GrammarAST, IToken>);
		AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_arg245 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST COMMA244_tree = default(GrammarAST);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_rewrite_template_arg=new RewriteRuleSubtreeStream(adaptor,"rule rewrite_template_arg");
		try { DebugEnterRule(GrammarFileName, "rewrite_template_args");
		DebugLocation(718, 1);
		try
		{
			// Grammars\\ANTLR.g3:719:2: ( rewrite_template_arg ( COMMA rewrite_template_arg )* -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ ) | -> ARGLIST[\"ARGLIST\"] )
			int alt101=2;
			try { DebugEnterDecision(101, false);
			int LA101_1 = input.LA(1);

			if ((LA101_1==RULE_REF||LA101_1==TOKEN_REF))
			{
				alt101 = 1;
			}
			else if ((LA101_1==RPAREN))
			{
				alt101 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 101, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(101); }
			switch (alt101)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:719:4: rewrite_template_arg ( COMMA rewrite_template_arg )*
				{
				DebugLocation(719, 4);
				PushFollow(Follow._rewrite_template_arg_in_rewrite_template_args3256);
				rewrite_template_arg243=rewrite_template_arg();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_rewrite_template_arg.Add(rewrite_template_arg243.Tree);
				DebugLocation(719, 25);
				// Grammars\\ANTLR.g3:719:25: ( COMMA rewrite_template_arg )*
				try { DebugEnterSubRule(100);
				while (true)
				{
					int alt100=2;
					try { DebugEnterDecision(100, false);
					int LA100_1 = input.LA(1);

					if ((LA100_1==COMMA))
					{
						alt100 = 1;
					}


					} finally { DebugExitDecision(100); }
					switch ( alt100 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ANTLR.g3:719:26: COMMA rewrite_template_arg
						{
						DebugLocation(719, 26);
						COMMA244=(IToken)Match(input,COMMA,Follow._COMMA_in_rewrite_template_args3259); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA244);

						DebugLocation(719, 32);
						PushFollow(Follow._rewrite_template_arg_in_rewrite_template_args3261);
						rewrite_template_arg245=rewrite_template_arg();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_rewrite_template_arg.Add(rewrite_template_arg245.Tree);

						}
						break;

					default:
						goto loop100;
					}
				}

				loop100:
					;

				} finally { DebugExitSubRule(100); }



				{
				// AST REWRITE
				// elements: rewrite_template_arg
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 720:3: -> ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
				{
					DebugLocation(720, 6);
					// Grammars\\ANTLR.g3:720:6: ^( ARGLIST[\"ARGLIST\"] ( rewrite_template_arg )+ )
					{
					GrammarAST root_1 = (GrammarAST)adaptor.Nil();
					DebugLocation(720, 8);
					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ARGLIST, "ARGLIST"), root_1);

					DebugLocation(720, 27);
					if (!(stream_rewrite_template_arg.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_rewrite_template_arg.HasNext )
					{
						DebugLocation(720, 27);
						adaptor.AddChild(root_1, stream_rewrite_template_arg.NextTree());

					}
					stream_rewrite_template_arg.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:722:3: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (GrammarAST)adaptor.Nil();
				// 722:3: -> ARGLIST[\"ARGLIST\"]
				{
					DebugLocation(722, 6);
					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(ARGLIST, "ARGLIST"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_template_args", 57);
			LeaveRule("rewrite_template_args", 57);
			LeaveRule_rewrite_template_args();
		}
		DebugLocation(723, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_template_args"); }
		return retval;

	}
	// $ANTLR end "rewrite_template_args"

	partial void EnterRule_rewrite_template_arg();
	partial void LeaveRule_rewrite_template_arg();
	// $ANTLR start "rewrite_template_arg"
	// Grammars\\ANTLR.g3:725:1: rewrite_template_arg : id ASSIGN ^ ACTION ;
	[GrammarRule("rewrite_template_arg")]
	private AstParserRuleReturnScope<GrammarAST, IToken> rewrite_template_arg()
	{
		EnterRule_rewrite_template_arg();
		EnterRule("rewrite_template_arg", 58);
		TraceIn("rewrite_template_arg", 58);
		AstParserRuleReturnScope<GrammarAST, IToken> retval = new AstParserRuleReturnScope<GrammarAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		GrammarAST root_0 = default(GrammarAST);

		IToken ASSIGN247 = default(IToken);
		IToken ACTION248 = default(IToken);
		AstParserRuleReturnScope<GrammarAST, IToken> id246 = default(AstParserRuleReturnScope<GrammarAST, IToken>);

		GrammarAST ASSIGN247_tree = default(GrammarAST);
		GrammarAST ACTION248_tree = default(GrammarAST);
		try { DebugEnterRule(GrammarFileName, "rewrite_template_arg");
		DebugLocation(725, 1);
		try
		{
			// Grammars\\ANTLR.g3:726:2: ( id ASSIGN ^ ACTION )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:726:4: id ASSIGN ^ ACTION
			{
			root_0 = (GrammarAST)adaptor.Nil();

			DebugLocation(726, 4);
			PushFollow(Follow._id_in_rewrite_template_arg3296);
			id246=id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, id246.Tree);
			DebugLocation(726, 34);
			ASSIGN247=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_rewrite_template_arg3298); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ASSIGN247_tree = (GrammarAST)adaptor.Create(ARG,ASSIGN247,"ARG");
			root_0 = (GrammarAST)adaptor.BecomeRoot(ASSIGN247_tree, root_0);
			}
			DebugLocation(726, 36);
			ACTION248=(IToken)Match(input,ACTION,Follow._ACTION_in_rewrite_template_arg3310); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ACTION248_tree = (GrammarAST)adaptor.Create(ACTION248);
			adaptor.AddChild(root_0, ACTION248_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (GrammarAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (GrammarAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rewrite_template_arg", 58);
			LeaveRule("rewrite_template_arg", 58);
			LeaveRule_rewrite_template_arg();
		}
		DebugLocation(727, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_template_arg"); }
		return retval;

	}
	// $ANTLR end "rewrite_template_arg"

	partial void EnterRule_synpred1_ANTLR_fragment();
	partial void LeaveRule_synpred1_ANTLR_fragment();

	// $ANTLR start synpred1_ANTLR
	private void synpred1_ANTLR_fragment()
	{
		EnterRule_synpred1_ANTLR_fragment();
		EnterRule("synpred1_ANTLR_fragment", 59);
		TraceIn("synpred1_ANTLR_fragment", 59);
		try
		{
			// Grammars\\ANTLR.g3:428:4: ({...}? id WILDCARD ( terminal | ruleref ) )
			DebugEnterAlt(1);
			// Grammars\\ANTLR.g3:428:5: {...}? id WILDCARD ( terminal | ruleref )
			{
			DebugLocation(428, 5);
			if (!((LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&
						 LT(2).CharPositionInLine+1==LT(3).CharPositionInLine)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "synpred1_ANTLR", "LT(1).CharPositionInLine+LT(1).Text.Length==LT(2).CharPositionInLine&&\n\t\t\t LT(2).CharPositionInLine+1==LT(3).CharPositionInLine");
			}
			DebugLocation(429, 60);
			PushFollow(Follow._id_in_synpred1_ANTLR1755);
			id();
			PopFollow();
			if (state.failed) return;
			DebugLocation(429, 63);
			Match(input,WILDCARD,Follow._WILDCARD_in_synpred1_ANTLR1757); if (state.failed) return;
			DebugLocation(429, 72);
			// Grammars\\ANTLR.g3:429:72: ( terminal | ruleref )
			int alt102=2;
			try { DebugEnterSubRule(102);
			try { DebugEnterDecision(102, false);
			int LA102_1 = input.LA(1);

			if ((LA102_1==CHAR_LITERAL||LA102_1==STRING_LITERAL||LA102_1==TOKEN_REF||LA102_1==WILDCARD))
			{
				alt102 = 1;
			}
			else if ((LA102_1==RULE_REF))
			{
				alt102 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 102, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ANTLR.g3:429:73: terminal
				{
				DebugLocation(429, 73);
				PushFollow(Follow._terminal_in_synpred1_ANTLR1760);
				terminal();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ANTLR.g3:429:82: ruleref
				{
				DebugLocation(429, 82);
				PushFollow(Follow._ruleref_in_synpred1_ANTLR1762);
				ruleref();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(102); }


			}

		}
		finally
		{
			TraceOut("synpred1_ANTLR_fragment", 59);
			LeaveRule("synpred1_ANTLR_fragment", 59);
			LeaveRule_synpred1_ANTLR_fragment();
		}
	}
	// $ANTLR end synpred1_ANTLR
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _ACTION_in_grammar_319 = new BitSet(new ulong[]{0x1002040008000000UL,0x80000000UL});
		public static readonly BitSet _DOC_COMMENT_in_grammar_324 = new BitSet(new ulong[]{0x1002040000000000UL,0x80000000UL});
		public static readonly BitSet _grammarType_in_grammar_329 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_grammar_331 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _SEMI_in_grammar_335 = new BitSet(new ulong[]{0x400210008000200UL,0x6003001CUL});
		public static readonly BitSet _optionsSpec_in_grammar_341 = new BitSet(new ulong[]{0x210008000200UL,0x6003001CUL});
		public static readonly BitSet _delegateGrammars_in_grammar_352 = new BitSet(new ulong[]{0x10008000200UL,0x6003001CUL});
		public static readonly BitSet _tokensSpec_in_grammar_357 = new BitSet(new ulong[]{0x10008000200UL,0x4003001CUL});
		public static readonly BitSet _attrScopes_in_grammar_362 = new BitSet(new ulong[]{0x10008000200UL,0x4001001CUL});
		public static readonly BitSet _actions_in_grammar_366 = new BitSet(new ulong[]{0x10008000000UL,0x4001001CUL});
		public static readonly BitSet _rules_in_grammar_371 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_grammar_375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEXER_in_grammarType416 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _GRAMMAR_in_grammarType420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARSER_in_grammarType437 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _GRAMMAR_in_grammarType440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TREE_in_grammarType455 = new BitSet(new ulong[]{0x40000000000UL});
		public static readonly BitSet _GRAMMAR_in_grammarType460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GRAMMAR_in_grammarType476 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _action_in_actions494 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _AMPERSAND_in_action508 = new BitSet(new ulong[]{0x1002000000000000UL,0x40010000UL});
		public static readonly BitSet _actionScopeName_in_action512 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _COLON_in_action514 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _COLON_in_action517 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_action522 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_action524 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_actionScopeName537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LEXER_in_actionScopeName542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARSER_in_actionScopeName550 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPTIONS_in_optionsSpec568 = new BitSet(new ulong[]{0x0UL,0x40010080UL});
		public static readonly BitSet _option_in_optionsSpec572 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _SEMI_in_optionsSpec575 = new BitSet(new ulong[]{0x0UL,0x40010080UL});
		public static readonly BitSet _RCURLY_in_optionsSpec580 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_option593 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ASSIGN_in_option595 = new BitSet(new ulong[]{0x800000040000UL,0x41410000UL});
		public static readonly BitSet _optionValue_in_option598 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_optionValue617 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_optionValue629 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_optionValue638 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_optionValue649 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_optionValue669 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPORT_in_delegateGrammars690 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _delegateGrammar_in_delegateGrammars693 = new BitSet(new ulong[]{0x1000000UL,0x40000UL});
		public static readonly BitSet _COMMA_in_delegateGrammars696 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _delegateGrammar_in_delegateGrammars699 = new BitSet(new ulong[]{0x1000000UL,0x40000UL});
		public static readonly BitSet _SEMI_in_delegateGrammars703 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_delegateGrammar718 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ASSIGN_in_delegateGrammar720 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_delegateGrammar727 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKENS_in_tokensSpec740 = new BitSet(new ulong[]{0x0UL,0x40000080UL});
		public static readonly BitSet _tokenSpec_in_tokensSpec746 = new BitSet(new ulong[]{0x0UL,0x40000080UL});
		public static readonly BitSet _RCURLY_in_tokensSpec751 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_tokenSpec763 = new BitSet(new ulong[]{0x2000UL,0x40000UL});
		public static readonly BitSet _ASSIGN_in_tokenSpec766 = new BitSet(new ulong[]{0x40000UL,0x1000000UL});
		public static readonly BitSet _set_in_tokenSpec769 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _SEMI_in_tokenSpec777 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attrScope_in_attrScopes789 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _SCOPE_in_attrScope801 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_attrScope804 = new BitSet(new ulong[]{0x210UL});
		public static readonly BitSet _ruleActions_in_attrScope806 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_attrScope809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rule_in_rules820 = new BitSet(new ulong[]{0x10008000002UL,0x4001001CUL});
		public static readonly BitSet _DOC_COMMENT_in_rule846 = new BitSet(new ulong[]{0x10000000000UL,0x4001001CUL});
		public static readonly BitSet _PROTECTED_in_rule859 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _PUBLIC_in_rule867 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _PRIVATE_in_rule875 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _FRAGMENT_in_rule883 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_rule894 = new BitSet(new ulong[]{0x400000000409200UL,0x10020400UL});
		public static readonly BitSet _BANG_in_rule902 = new BitSet(new ulong[]{0x400000000401200UL,0x10020400UL});
		public static readonly BitSet _ARG_ACTION_in_rule911 = new BitSet(new ulong[]{0x400000000400200UL,0x10020400UL});
		public static readonly BitSet _RETURNS_in_rule920 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ARG_ACTION_in_rule924 = new BitSet(new ulong[]{0x400000000400200UL,0x10020000UL});
		public static readonly BitSet _throwsSpec_in_rule932 = new BitSet(new ulong[]{0x400000000400200UL,0x20000UL});
		public static readonly BitSet _optionsSpec_in_rule937 = new BitSet(new ulong[]{0x400200UL,0x20000UL});
		public static readonly BitSet _ruleScopeSpec_in_rule944 = new BitSet(new ulong[]{0x400200UL});
		public static readonly BitSet _ruleActions_in_rule948 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _COLON_in_rule953 = new BitSet(new ulong[]{0x888008000040010UL,0x541090800UL});
		public static readonly BitSet _ruleAltList_in_rule957 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _SEMI_in_rule962 = new BitSet(new ulong[]{0x4000020002UL});
		public static readonly BitSet _exceptionGroup_in_rule970 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ruleAction_in_ruleActions1095 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _AMPERSAND_in_ruleAction1109 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_ruleAction1112 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_ruleAction1114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THROWS_in_throwsSpec1125 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_throwsSpec1128 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_throwsSpec1131 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_throwsSpec1134 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _SCOPE_in_ruleScopeSpec1149 = new BitSet(new ulong[]{0x210UL});
		public static readonly BitSet _ruleActions_in_ruleScopeSpec1151 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_ruleScopeSpec1154 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _SCOPE_in_ruleScopeSpec1163 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _idList_in_ruleScopeSpec1165 = new BitSet(new ulong[]{0x0UL,0x40000UL});
		public static readonly BitSet _SEMI_in_ruleScopeSpec1167 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _alternative_in_ruleAltList1224 = new BitSet(new ulong[]{0x800000000000000UL,0x800UL});
		public static readonly BitSet _rewrite_in_ruleAltList1228 = new BitSet(new ulong[]{0x800000000000002UL});
		public static readonly BitSet _OR_in_ruleAltList1257 = new BitSet(new ulong[]{0x888008000040010UL,0x541090800UL});
		public static readonly BitSet _alternative_in_ruleAltList1261 = new BitSet(new ulong[]{0x800000000000000UL,0x800UL});
		public static readonly BitSet _rewrite_in_ruleAltList1265 = new BitSet(new ulong[]{0x800000000000002UL});
		public static readonly BitSet _LPAREN_in_block1341 = new BitSet(new ulong[]{0xC88008000440210UL,0x541094800UL});
		public static readonly BitSet _optionsSpec_in_block1379 = new BitSet(new ulong[]{0x400200UL});
		public static readonly BitSet _ruleActions_in_block1390 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _COLON_in_block1398 = new BitSet(new ulong[]{0x888008000040010UL,0x541094800UL});
		public static readonly BitSet _ACTION_in_block1404 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _COLON_in_block1406 = new BitSet(new ulong[]{0x888008000040010UL,0x541094800UL});
		public static readonly BitSet _alternative_in_block1418 = new BitSet(new ulong[]{0x800000000000000UL,0x4800UL});
		public static readonly BitSet _rewrite_in_block1422 = new BitSet(new ulong[]{0x800000000000000UL,0x4000UL});
		public static readonly BitSet _OR_in_block1432 = new BitSet(new ulong[]{0x888008000040010UL,0x541094800UL});
		public static readonly BitSet _alternative_in_block1436 = new BitSet(new ulong[]{0x800000000000000UL,0x4800UL});
		public static readonly BitSet _rewrite_in_block1440 = new BitSet(new ulong[]{0x800000000000000UL,0x4000UL});
		public static readonly BitSet _RPAREN_in_block1457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _element_in_alternative1497 = new BitSet(new ulong[]{0x88008000040012UL,0x541090000UL});
		public static readonly BitSet _exceptionHandler_in_exceptionGroup1543 = new BitSet(new ulong[]{0x4000020002UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup1546 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup1552 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_exceptionHandler1563 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ARG_ACTION_in_exceptionHandler1566 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_exceptionHandler1568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FINALLY_in_finallyClause1579 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_finallyClause1582 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _elementNoOptionSpec_in_element1593 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_elementNoOptionSpec1611 = new BitSet(new ulong[]{0x8000000000002000UL});
		public static readonly BitSet _ASSIGN_in_elementNoOptionSpec1614 = new BitSet(new ulong[]{0x88000000040000UL,0x441010000UL});
		public static readonly BitSet _PLUS_ASSIGN_in_elementNoOptionSpec1617 = new BitSet(new ulong[]{0x88000000040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_elementNoOptionSpec1626 = new BitSet(new ulong[]{0x4000000000000002UL,0x400020UL});
		public static readonly BitSet _ebnfSuffix_in_elementNoOptionSpec1629 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ebnf_in_elementNoOptionSpec1642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_elementNoOptionSpec1656 = new BitSet(new ulong[]{0x4000000000000002UL,0x400020UL});
		public static readonly BitSet _ebnfSuffix_in_elementNoOptionSpec1662 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ebnf_in_elementNoOptionSpec1676 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FORCED_ACTION_in_elementNoOptionSpec1681 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_elementNoOptionSpec1686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMPRED_in_elementNoOptionSpec1693 = new BitSet(new ulong[]{0x100000000002UL});
		public static readonly BitSet _IMPLIES_in_elementNoOptionSpec1697 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tree__in_elementNoOptionSpec1714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _range_in_atom1725 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_atom1728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_atom1731 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_atom1771 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _WILDCARD_in_atom1773 = new BitSet(new ulong[]{0x40000UL,0x441010000UL});
		public static readonly BitSet _terminal_in_atom1777 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ruleref_in_atom1779 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _terminal_in_atom1788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ruleref_in_atom1794 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _notSet_in_atom1803 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_atom1806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_atom1809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RULE_REF_in_ruleref1823 = new BitSet(new ulong[]{0x9002UL,0x2000UL});
		public static readonly BitSet _ARG_ACTION_in_ruleref1826 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_ruleref1830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_ruleref1833 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_notSet1847 = new BitSet(new ulong[]{0x8000000040000UL,0x41000000UL});
		public static readonly BitSet _notTerminal_in_notSet1854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_notSet1860 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_treeRoot1883 = new BitSet(new ulong[]{0x8000000000002000UL});
		public static readonly BitSet _ASSIGN_in_treeRoot1886 = new BitSet(new ulong[]{0x88000000040000UL,0x441010000UL});
		public static readonly BitSet _PLUS_ASSIGN_in_treeRoot1889 = new BitSet(new ulong[]{0x88000000040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_treeRoot1894 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_treeRoot1896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_treeRoot1902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_treeRoot1907 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TREE_BEGIN_in_tree_1918 = new BitSet(new ulong[]{0x88000000040000UL,0x441010000UL});
		public static readonly BitSet _treeRoot_in_tree_1923 = new BitSet(new ulong[]{0x88008000040010UL,0x541090000UL});
		public static readonly BitSet _element_in_tree_1925 = new BitSet(new ulong[]{0x88008000040010UL,0x541094000UL});
		public static readonly BitSet _RPAREN_in_tree_1930 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_ebnf1944 = new BitSet(new ulong[]{0x4000100000008002UL,0x402020UL});
		public static readonly BitSet _QUESTION_in_ebnf1950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_ebnf1968 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_ebnf1986 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPLIES_in_ebnf2004 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ROOT_in_ebnf2040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_ebnf2057 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_range2101 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _RANGE_in_range2103 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_range2115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_range2129 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _RANGE_in_range2133 = new BitSet(new ulong[]{0x0UL,0x40000000UL});
		public static readonly BitSet _TOKEN_REF_in_range2136 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_range2143 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _RANGE_in_range2147 = new BitSet(new ulong[]{0x0UL,0x1000000UL});
		public static readonly BitSet _STRING_LITERAL_in_range2150 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_range2157 = new BitSet(new ulong[]{0x0UL,0x40UL});
		public static readonly BitSet _RANGE_in_range2161 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_range2164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_terminal2184 = new BitSet(new ulong[]{0x100000000008002UL,0x2000UL});
		public static readonly BitSet _elementOptions_in_terminal2189 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_terminal2197 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_terminal2200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_terminal2209 = new BitSet(new ulong[]{0x100000000009002UL,0x2000UL});
		public static readonly BitSet _elementOptions_in_terminal2216 = new BitSet(new ulong[]{0x9002UL,0x2000UL});
		public static readonly BitSet _ARG_ACTION_in_terminal2227 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_terminal2236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_terminal2239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_terminal2248 = new BitSet(new ulong[]{0x100000000008002UL,0x2000UL});
		public static readonly BitSet _elementOptions_in_terminal2253 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_terminal2261 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_terminal2264 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WILDCARD_in_terminal2273 = new BitSet(new ulong[]{0x8002UL,0x2000UL});
		public static readonly BitSet _ROOT_in_terminal2276 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BANG_in_terminal2279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_ELEMENT_OPTION_in_elementOptions2298 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _defaultNodeOption_in_elementOptions2301 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CLOSE_ELEMENT_OPTION_in_elementOptions2304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPEN_ELEMENT_OPTION_in_elementOptions2310 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _elementOption_in_elementOptions2313 = new BitSet(new ulong[]{0x100000UL,0x40000UL});
		public static readonly BitSet _SEMI_in_elementOptions2317 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _elementOption_in_elementOptions2320 = new BitSet(new ulong[]{0x100000UL,0x40000UL});
		public static readonly BitSet _CLOSE_ELEMENT_OPTION_in_elementOptions2325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _elementOptionId_in_defaultNodeOption2338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_elementOption2354 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ASSIGN_in_elementOption2356 = new BitSet(new ulong[]{0xC0000000UL,0x41010000UL});
		public static readonly BitSet _elementOptionId_in_elementOption2363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_elementOption2377 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_elementOption2381 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_elementOption2385 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_elementOptionId2416 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _WILDCARD_in_elementOptionId2421 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_elementOptionId2425 = new BitSet(new ulong[]{0x2UL,0x400000000UL});
		public static readonly BitSet _QUESTION_in_ebnfSuffix2502 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_ebnfSuffix2516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_ebnfSuffix2530 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_idList2592 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_idList2595 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _id_in_idList2598 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _TOKEN_REF_in_id2611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RULE_REF_in_id2619 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_with_sempred_in_rewrite2635 = new BitSet(new ulong[]{0x0UL,0x800UL});
		public static readonly BitSet _REWRITE_in_rewrite2640 = new BitSet(new ulong[]{0x8002010040010UL,0x141010000UL});
		public static readonly BitSet _rewrite_alternative_in_rewrite2642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REWRITE_in_rewrite_with_sempred2673 = new BitSet(new ulong[]{0x0UL,0x80000UL});
		public static readonly BitSet _SEMPRED_in_rewrite_with_sempred2676 = new BitSet(new ulong[]{0x8002010040010UL,0x141010000UL});
		public static readonly BitSet _rewrite_alternative_in_rewrite_with_sempred2678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_rewrite_block2689 = new BitSet(new ulong[]{0x8002010040010UL,0x141014000UL});
		public static readonly BitSet _rewrite_alternative_in_rewrite_block2703 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPAREN_in_rewrite_block2707 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_template_in_rewrite_alternative2738 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_element_in_rewrite_alternative2750 = new BitSet(new ulong[]{0x8000010040012UL,0x141010000UL});
		public static readonly BitSet _ETC_in_rewrite_alternative2811 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_atom_in_rewrite_element2824 = new BitSet(new ulong[]{0x4000000000000002UL,0x400020UL});
		public static readonly BitSet _ebnfSuffix_in_rewrite_element2841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_ebnf_in_rewrite_element2859 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_tree_in_rewrite_element2866 = new BitSet(new ulong[]{0x4000000000000002UL,0x400020UL});
		public static readonly BitSet _ebnfSuffix_in_rewrite_element2883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_rewrite_atom2907 = new BitSet(new ulong[]{0x100000000001002UL});
		public static readonly BitSet _elementOptions_in_rewrite_atom2910 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _ARG_ACTION_in_rewrite_atom2915 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RULE_REF_in_rewrite_atom2922 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom2927 = new BitSet(new ulong[]{0x100000000000002UL});
		public static readonly BitSet _elementOptions_in_rewrite_atom2929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom2937 = new BitSet(new ulong[]{0x100000000000002UL});
		public static readonly BitSet _elementOptions_in_rewrite_atom2939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOLLAR_in_rewrite_atom2947 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _label_in_rewrite_atom2950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_rewrite_atom2956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_label2967 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RULE_REF_in_label2975 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_block_in_rewrite_ebnf2991 = new BitSet(new ulong[]{0x4000000000000000UL,0x400020UL});
		public static readonly BitSet _QUESTION_in_rewrite_ebnf2997 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_rewrite_ebnf3016 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_rewrite_ebnf3035 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree3063 = new BitSet(new ulong[]{0x10040010UL,0x41010000UL});
		public static readonly BitSet _rewrite_atom_in_rewrite_tree3069 = new BitSet(new ulong[]{0x8000010040010UL,0x141014000UL});
		public static readonly BitSet _rewrite_element_in_rewrite_tree3071 = new BitSet(new ulong[]{0x8000010040010UL,0x141014000UL});
		public static readonly BitSet _RPAREN_in_rewrite_tree3076 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_template_head_in_rewrite_template3111 = new BitSet(new ulong[]{0xC0000000UL});
		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template3130 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template3136 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_template_head_in_rewrite_template3151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_indirect_template_head_in_rewrite_template3160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_rewrite_template3169 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_rewrite_template_head3182 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LPAREN_in_rewrite_template_head3184 = new BitSet(new ulong[]{0x0UL,0x40014000UL});
		public static readonly BitSet _rewrite_template_args_in_rewrite_template_head3198 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPAREN_in_rewrite_template_head3202 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_rewrite_indirect_template_head3216 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_rewrite_indirect_template_head3230 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPAREN_in_rewrite_indirect_template_head3234 = new BitSet(new ulong[]{0x8000000000000UL});
		public static readonly BitSet _LPAREN_in_rewrite_indirect_template_head3239 = new BitSet(new ulong[]{0x0UL,0x40014000UL});
		public static readonly BitSet _rewrite_template_args_in_rewrite_indirect_template_head3242 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RPAREN_in_rewrite_indirect_template_head3244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_template_arg_in_rewrite_template_args3256 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _COMMA_in_rewrite_template_args3259 = new BitSet(new ulong[]{0x0UL,0x40010000UL});
		public static readonly BitSet _rewrite_template_arg_in_rewrite_template_args3261 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _id_in_rewrite_template_arg3296 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ASSIGN_in_rewrite_template_arg3298 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_rewrite_template_arg3310 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_in_synpred1_ANTLR1755 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _WILDCARD_in_synpred1_ANTLR1757 = new BitSet(new ulong[]{0x40000UL,0x441010000UL});
		public static readonly BitSet _terminal_in_synpred1_ANTLR1760 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ruleref_in_synpred1_ANTLR1762 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.Grammars
