//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\ActionAnalysisLexer.g3 2013-06-14 09:39:33

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.Grammars
{
/** We need to set Rule.referencedPredefinedRuleAttributes before
 *  code generation.  This filter looks at an action in context of
 *  its rule and outer alternative number and figures out which
 *  rules have predefined prefs referenced.  I need this so I can
 *  remove unusued labels.  This also tracks, for labeled rules,
 *  which are referenced by actions.
 */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ActionAnalysisLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ID=4;
	public const int X=5;
	public const int X_Y=6;
	public const int Y=7;

	// delegates
	// delegators

	private ActionAnalysisLexer()
	{
		OnCreated();
	}

	private ActionAnalysisLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	private ActionAnalysisLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Grammars\\ActionAnalysisLexer.g3"; } }

	public override IToken NextToken()
	{
		while (true)
		{
			if (input.LA(1) == CharStreamConstants.EndOfFile)
			{
				IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
				eof.Line = Line;
				eof.CharPositionInLine = CharPositionInLine;
				return eof;
			}
			state.token = null;
			state.channel = TokenChannels.Default;
			state.tokenStartCharIndex = input.Index;
			state.tokenStartCharPositionInLine = input.CharPositionInLine;
			state.tokenStartLine = input.Line;
			state.text = null;
			try
			{
				int m = input.Mark();
				state.backtracking=1;
				state.failed=false;
				mTokens();
				state.backtracking=0;
				if (state.failed)
				{
					input.Rewind(m);
					input.Consume();
				}
				else
				{
					Emit();
					return state.token;
				}
			}
			catch (RecognitionException re)
			{
				// shouldn't happen in backtracking mode, but...
				ReportError(re);
				Recover(re);
			}
		}
	}

	public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
	{
		if (state.backtracking > 1)
			base.Memoize(input, ruleIndex, ruleStartIndex);
	}

	public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
	{
		if (state.backtracking > 1)
			return base.AlreadyParsedRule(input, ruleIndex);

		return false;
	}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_X_Y();
	partial void LeaveRule_X_Y();

	// $ANTLR start "X_Y"
	[GrammarRule("X_Y")]
	private void mX_Y()
	{
		EnterRule_X_Y();
		EnterRule("X_Y", 1);
		TraceIn("X_Y", 1);
		try
		{
			int _type = X_Y;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionAnalysisLexer.g3:56:2: ( '$' x= ID '.' y= ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:56:4: '$' x= ID '.' y= ID {...}?
			{
			DebugLocation(56, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(56, 9);
			int xStart52 = CharIndex;
			int xStartLine52 = Line;
			int xStartCharPos52 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart52, CharIndex-1);
			x.Line = xStartLine52;
			x.CharPositionInLine = xStartCharPos52;
			DebugLocation(56, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(56, 18);
			int yStart58 = CharIndex;
			int yStartLine58 = Line;
			int yStartCharPos58 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart58, CharIndex-1);
			y.Line = yStartLine58;
			y.CharPositionInLine = yStartCharPos58;
			DebugLocation(56, 22);
			if (!((enclosingRule != null)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "X_Y", "enclosingRule != null");
			}
			DebugLocation(57, 3);
			if (state.backtracking == 1)
			{
				HandleAttributeMemberReference((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("X_Y", 1);
			LeaveRule("X_Y", 1);
			LeaveRule_X_Y();
		}
	}
	// $ANTLR end "X_Y"

	partial void EnterRule_X();
	partial void LeaveRule_X();

	// $ANTLR start "X"
	[GrammarRule("X")]
	private void mX()
	{
		EnterRule_X();
		EnterRule("X", 2);
		TraceIn("X", 2);
		try
		{
			int _type = X;
			int _channel = DefaultTokenChannel;
			CommonToken ID1 = default(CommonToken);

			// Grammars\\ActionAnalysisLexer.g3:62:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:62:4: '$' ID {...}?
			{
			DebugLocation(62, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(62, 8);
			int ID1Start79 = CharIndex;
			int ID1StartLine79 = Line;
			int ID1StartCharPos79 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID1Start79, CharIndex-1);
			ID1.Line = ID1StartLine79;
			ID1.CharPositionInLine = ID1StartCharPos79;
			DebugLocation(62, 11);
			if (!((enclosingRule != null && enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:default(string))) != null)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "X", "enclosingRule != null && enclosingRule.GetRuleLabel($ID.text) != null");
			}
			DebugLocation(63, 3);
			if (state.backtracking == 1)
			{
				HandleRuleLabelReference((ID1!=null?ID1.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("X", 2);
			LeaveRule("X", 2);
			LeaveRule_X();
		}
	}
	// $ANTLR end "X"

	partial void EnterRule_Y();
	partial void LeaveRule_Y();

	// $ANTLR start "Y"
	[GrammarRule("Y")]
	private void mY()
	{
		EnterRule_Y();
		EnterRule("Y", 3);
		TraceIn("Y", 3);
		try
		{
			int _type = Y;
			int _channel = DefaultTokenChannel;
			CommonToken ID2 = default(CommonToken);

			// Grammars\\ActionAnalysisLexer.g3:68:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:68:4: '$' ID {...}?
			{
			DebugLocation(68, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(68, 8);
			int ID2Start101 = CharIndex;
			int ID2StartLine101 = Line;
			int ID2StartCharPos101 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID2Start101, CharIndex-1);
			ID2.Line = ID2StartLine101;
			ID2.CharPositionInLine = ID2StartCharPos101;
			DebugLocation(68, 11);
			if (!((enclosingRule != null && enclosingRule.GetLocalAttributeScope((ID2!=null?ID2.Text:default(string))) != null)))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "Y", "enclosingRule != null && enclosingRule.GetLocalAttributeScope($ID.text) != null");
			}
			DebugLocation(69, 3);
			if (state.backtracking == 1)
			{
				HandleAttributeReference((ID2!=null?ID2.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Y", 3);
			LeaveRule("Y", 3);
			LeaveRule_Y();
		}
	}
	// $ANTLR end "Y"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 4);
		TraceIn("ID", 4);
		try
		{
			// Grammars\\ActionAnalysisLexer.g3:74:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:74:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			{
			DebugLocation(74, 4);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(74, 28);
			// Grammars\\ActionAnalysisLexer.g3:74:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='0' && LA1_1<='9')||(LA1_1>='A' && LA1_1<='Z')||LA1_1=='_'||(LA1_1>='a' && LA1_1<='z')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionAnalysisLexer.g3:
					{
					DebugLocation(74, 28);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		finally
		{
			TraceOut("ID", 4);
			LeaveRule("ID", 4);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	public override void mTokens()
	{
		// Grammars\\ActionAnalysisLexer.g3:1:39: ( X_Y | X | Y )
		int alt2=3;
		try { DebugEnterDecision(2, false);
		int LA2_1 = input.LA(1);

		if ((LA2_1=='$'))
		{
			int LA2_2 = input.LA(2);

			if ((EvaluatePredicate(synpred1_ActionAnalysisLexer_fragment)))
			{
				alt2 = 1;
			}
			else if ((EvaluatePredicate(synpred2_ActionAnalysisLexer_fragment)))
			{
				alt2 = 2;
			}
			else if ((true))
			{
				alt2 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 2, 1, input, 2);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}
		else
		{
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
			DebugRecognitionException(nvae);
			throw nvae;
		}
		} finally { DebugExitDecision(2); }
		switch (alt2)
		{
		case 1:
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:1:41: X_Y
			{
			DebugLocation(1, 41);
			mX_Y(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Grammars\\ActionAnalysisLexer.g3:1:45: X
			{
			DebugLocation(1, 45);
			mX(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Grammars\\ActionAnalysisLexer.g3:1:47: Y
			{
			DebugLocation(1, 47);
			mY(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_ActionAnalysisLexer_fragment();
	partial void LeaveRule_synpred1_ActionAnalysisLexer_fragment();

	// $ANTLR start synpred1_ActionAnalysisLexer
	private void synpred1_ActionAnalysisLexer_fragment()
	{
		EnterRule_synpred1_ActionAnalysisLexer_fragment();
		EnterRule("synpred1_ActionAnalysisLexer_fragment", 6);
		TraceIn("synpred1_ActionAnalysisLexer_fragment", 6);
		try
		{
			// Grammars\\ActionAnalysisLexer.g3:1:41: ( X_Y )
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:1:41: X_Y
			{
			DebugLocation(1, 41);
			mX_Y(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_ActionAnalysisLexer_fragment", 6);
			LeaveRule("synpred1_ActionAnalysisLexer_fragment", 6);
			LeaveRule_synpred1_ActionAnalysisLexer_fragment();
		}
	}
	// $ANTLR end synpred1_ActionAnalysisLexer

	partial void EnterRule_synpred2_ActionAnalysisLexer_fragment();
	partial void LeaveRule_synpred2_ActionAnalysisLexer_fragment();

	// $ANTLR start synpred2_ActionAnalysisLexer
	private void synpred2_ActionAnalysisLexer_fragment()
	{
		EnterRule_synpred2_ActionAnalysisLexer_fragment();
		EnterRule("synpred2_ActionAnalysisLexer_fragment", 7);
		TraceIn("synpred2_ActionAnalysisLexer_fragment", 7);
		try
		{
			// Grammars\\ActionAnalysisLexer.g3:1:45: ( X )
			DebugEnterAlt(1);
			// Grammars\\ActionAnalysisLexer.g3:1:45: X
			{
			DebugLocation(1, 45);
			mX(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_ActionAnalysisLexer_fragment", 7);
			LeaveRule("synpred2_ActionAnalysisLexer_fragment", 7);
			LeaveRule_synpred2_ActionAnalysisLexer_fragment();
		}
	}
	// $ANTLR end synpred2_ActionAnalysisLexer

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}

} // namespace Antlr3.Grammars
