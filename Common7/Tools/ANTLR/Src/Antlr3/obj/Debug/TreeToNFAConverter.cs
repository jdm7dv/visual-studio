//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\TreeToNFAConverter.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using Antlr3.Analysis;
using Antlr3.Misc;
using Antlr3.Tool;
using Antlr3.Extensions;
using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Antlr3.Grammars
{
/** Build an NFA from a tree representing an ANTLR grammar. */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class TreeToNFAConverter : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", "ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", "TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
	};
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ACTION_CHAR_LITERAL=5;
	public const int ACTION_ESC=6;
	public const int ACTION_STRING_LITERAL=7;
	public const int ALT=8;
	public const int AMPERSAND=9;
	public const int ARG=10;
	public const int ARGLIST=11;
	public const int ARG_ACTION=12;
	public const int ASSIGN=13;
	public const int BACKTRACK_SEMPRED=14;
	public const int BANG=15;
	public const int BLOCK=16;
	public const int CATCH=17;
	public const int CHAR_LITERAL=18;
	public const int CHAR_RANGE=19;
	public const int CLOSE_ELEMENT_OPTION=20;
	public const int CLOSURE=21;
	public const int COLON=22;
	public const int COMBINED_GRAMMAR=23;
	public const int COMMA=24;
	public const int COMMENT=25;
	public const int DIGIT=26;
	public const int DOC_COMMENT=27;
	public const int DOLLAR=28;
	public const int DOT=29;
	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
	public const int EOA=32;
	public const int EOB=33;
	public const int EOR=34;
	public const int EPSILON=35;
	public const int ESC=36;
	public const int ETC=37;
	public const int FINALLY=38;
	public const int FORCED_ACTION=39;
	public const int FRAGMENT=40;
	public const int GATED_SEMPRED=41;
	public const int GRAMMAR=42;
	public const int ID=43;
	public const int IMPLIES=44;
	public const int IMPORT=45;
	public const int INITACTION=46;
	public const int INT=47;
	public const int LABEL=48;
	public const int LEXER=49;
	public const int LEXER_GRAMMAR=50;
	public const int LPAREN=51;
	public const int ML_COMMENT=52;
	public const int NESTED_ACTION=53;
	public const int NESTED_ARG_ACTION=54;
	public const int NOT=55;
	public const int OPEN_ELEMENT_OPTION=56;
	public const int OPTIONAL=57;
	public const int OPTIONS=58;
	public const int OR=59;
	public const int PARSER=60;
	public const int PARSER_GRAMMAR=61;
	public const int PLUS=62;
	public const int PLUS_ASSIGN=63;
	public const int POSITIVE_CLOSURE=64;
	public const int PREC_RULE=65;
	public const int PRIVATE=66;
	public const int PROTECTED=67;
	public const int PUBLIC=68;
	public const int QUESTION=69;
	public const int RANGE=70;
	public const int RCURLY=71;
	public const int RECURSIVE_RULE_REF=72;
	public const int RET=73;
	public const int RETURNS=74;
	public const int REWRITE=75;
	public const int REWRITES=76;
	public const int ROOT=77;
	public const int RPAREN=78;
	public const int RULE=79;
	public const int RULE_REF=80;
	public const int SCOPE=81;
	public const int SEMI=82;
	public const int SEMPRED=83;
	public const int SL_COMMENT=84;
	public const int SRC=85;
	public const int STAR=86;
	public const int STRAY_BRACKET=87;
	public const int STRING_LITERAL=88;
	public const int SYNPRED=89;
	public const int SYN_SEMPRED=90;
	public const int TEMPLATE=91;
	public const int THROWS=92;
	public const int TOKENS=93;
	public const int TOKEN_REF=94;
	public const int TREE=95;
	public const int TREE_BEGIN=96;
	public const int TREE_GRAMMAR=97;
	public const int WILDCARD=98;
	public const int WS=99;
	public const int WS_LOOP=100;
	public const int WS_OPT=101;
	public const int XDIGIT=102;

	private TreeToNFAConverter(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	private TreeToNFAConverter(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return TreeToNFAConverter.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\TreeToNFAConverter.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_grammar_();
	partial void LeaveRule_grammar_();
	// $ANTLR start "grammar_"
	// Grammars\\TreeToNFAConverter.g3:57:1: public grammar_ : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
	[GrammarRule("grammar_")]
	public void grammar_()
	{
		EnterRule_grammar_();
		EnterRule("grammar_", 1);
		TraceIn("grammar_", 1);
		try { DebugEnterRule(GrammarFileName, "grammar_");
		DebugLocation(57, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:62:2: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:62:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
			{
			DebugLocation(62, 4);
			// Grammars\\TreeToNFAConverter.g3:62:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
			int alt1=4;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case LEXER_GRAMMAR:
				{
				alt1 = 1;
				}
				break;
			case PARSER_GRAMMAR:
				{
				alt1 = 2;
				}
				break;
			case TREE_GRAMMAR:
				{
				alt1 = 3;
				}
				break;
			case COMBINED_GRAMMAR:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:62:6: ^( LEXER_GRAMMAR grammarSpec )
				{
				DebugLocation(62, 6);
				DebugLocation(62, 8);
				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_70); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(62, 22);
				PushFollow(Follow._grammarSpec_in_grammar_72);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:63:5: ^( PARSER_GRAMMAR grammarSpec )
				{
				DebugLocation(63, 5);
				DebugLocation(63, 7);
				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_80); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(63, 22);
				PushFollow(Follow._grammarSpec_in_grammar_82);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\TreeToNFAConverter.g3:64:5: ^( TREE_GRAMMAR grammarSpec )
				{
				DebugLocation(64, 5);
				DebugLocation(64, 7);
				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_90); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(64, 20);
				PushFollow(Follow._grammarSpec_in_grammar_92);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\TreeToNFAConverter.g3:65:5: ^( COMBINED_GRAMMAR grammarSpec )
				{
				DebugLocation(65, 5);
				DebugLocation(65, 7);
				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_100); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(65, 24);
				PushFollow(Follow._grammarSpec_in_grammar_102);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

			if (state.backtracking == 0)
			{

					Finish();

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("grammar_", 1);
			LeaveRule("grammar_", 1);
			LeaveRule_grammar_();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "grammar_"); }
		return;

	}
	// $ANTLR end "grammar_"

	partial void EnterRule_attrScope();
	partial void LeaveRule_attrScope();
	// $ANTLR start "attrScope"
	// Grammars\\TreeToNFAConverter.g3:69:1: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
	[GrammarRule("attrScope")]
	private void attrScope()
	{
		EnterRule_attrScope();
		EnterRule("attrScope", 2);
		TraceIn("attrScope", 2);
		try { DebugEnterRule(GrammarFileName, "attrScope");
		DebugLocation(69, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:70:2: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:70:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
			{
			DebugLocation(70, 4);
			DebugLocation(70, 6);
			Match(input,SCOPE,Follow._SCOPE_in_attrScope119); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(70, 14);
			Match(input,ID,Follow._ID_in_attrScope121); if (state.failed) return;
			DebugLocation(70, 17);
			// Grammars\\TreeToNFAConverter.g3:70:17: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==AMPERSAND))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:70:19: ^( AMPERSAND ( . )* )
					{
					DebugLocation(70, 19);
					DebugLocation(70, 21);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope126); if (state.failed) return;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(70, 31);
						// Grammars\\TreeToNFAConverter.g3:70:31: ( . )*
						try { DebugEnterSubRule(2);
						while (true)
						{
							int alt2=2;
							try { DebugEnterDecision(2, false);
							int LA2_1 = input.LA(1);

							if (((LA2_1>=ACTION && LA2_1<=XDIGIT)))
							{
								alt2 = 1;
							}
							else if ((LA2_1==UP))
							{
								alt2 = 2;
							}


							} finally { DebugExitDecision(2); }
							switch ( alt2 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:70:31: .
								{
								DebugLocation(70, 31);
								MatchAny(input); if (state.failed) return;

								}
								break;

							default:
								goto loop2;
							}
						}

						loop2:
							;

						} finally { DebugExitSubRule(2); }


						Match(input, TokenTypes.Up, null); if (state.failed) return;
					}


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(70, 38);
			Match(input,ACTION,Follow._ACTION_in_attrScope135); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attrScope", 2);
			LeaveRule("attrScope", 2);
			LeaveRule_attrScope();
		}
		DebugLocation(71, 1);
		} finally { DebugExitRule(GrammarFileName, "attrScope"); }
		return;

	}
	// $ANTLR end "attrScope"

	partial void EnterRule_grammarSpec();
	partial void LeaveRule_grammarSpec();
	// $ANTLR start "grammarSpec"
	// Grammars\\TreeToNFAConverter.g3:73:1: grammarSpec : ID ( DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules ;
	[GrammarRule("grammarSpec")]
	private void grammarSpec()
	{
		EnterRule_grammarSpec();
		EnterRule("grammarSpec", 3);
		TraceIn("grammarSpec", 3);
		try { DebugEnterRule(GrammarFileName, "grammarSpec");
		DebugLocation(73, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:74:2: ( ID ( DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:74:4: ID ( DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules
			{
			DebugLocation(74, 4);
			Match(input,ID,Follow._ID_in_grammarSpec147); if (state.failed) return;
			DebugLocation(75, 3);
			// Grammars\\TreeToNFAConverter.g3:75:3: ( DOC_COMMENT )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==DOC_COMMENT))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:75:3: DOC_COMMENT
				{
				DebugLocation(75, 3);
				Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec151); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(76, 3);
			// Grammars\\TreeToNFAConverter.g3:76:3: ( ^( OPTIONS ( . )* ) )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==OPTIONS))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:76:5: ^( OPTIONS ( . )* )
				{
				DebugLocation(76, 5);
				DebugLocation(76, 7);
				Match(input,OPTIONS,Follow._OPTIONS_in_grammarSpec159); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(76, 15);
					// Grammars\\TreeToNFAConverter.g3:76:15: ( . )*
					try { DebugEnterSubRule(5);
					while (true)
					{
						int alt5=2;
						try { DebugEnterDecision(5, false);
						int LA5_1 = input.LA(1);

						if (((LA5_1>=ACTION && LA5_1<=XDIGIT)))
						{
							alt5 = 1;
						}
						else if ((LA5_1==UP))
						{
							alt5 = 2;
						}


						} finally { DebugExitDecision(5); }
						switch ( alt5 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:76:15: .
							{
							DebugLocation(76, 15);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop5;
						}
					}

					loop5:
						;

					} finally { DebugExitSubRule(5); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(77, 3);
			// Grammars\\TreeToNFAConverter.g3:77:3: ( ^( IMPORT ( . )* ) )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==IMPORT))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:77:5: ^( IMPORT ( . )* )
				{
				DebugLocation(77, 5);
				DebugLocation(77, 7);
				Match(input,IMPORT,Follow._IMPORT_in_grammarSpec173); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(77, 14);
					// Grammars\\TreeToNFAConverter.g3:77:14: ( . )*
					try { DebugEnterSubRule(7);
					while (true)
					{
						int alt7=2;
						try { DebugEnterDecision(7, false);
						int LA7_1 = input.LA(1);

						if (((LA7_1>=ACTION && LA7_1<=XDIGIT)))
						{
							alt7 = 1;
						}
						else if ((LA7_1==UP))
						{
							alt7 = 2;
						}


						} finally { DebugExitDecision(7); }
						switch ( alt7 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:77:14: .
							{
							DebugLocation(77, 14);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop7;
						}
					}

					loop7:
						;

					} finally { DebugExitSubRule(7); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(78, 3);
			// Grammars\\TreeToNFAConverter.g3:78:3: ( ^( TOKENS ( . )* ) )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==TOKENS))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:78:5: ^( TOKENS ( . )* )
				{
				DebugLocation(78, 5);
				DebugLocation(78, 7);
				Match(input,TOKENS,Follow._TOKENS_in_grammarSpec187); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(78, 14);
					// Grammars\\TreeToNFAConverter.g3:78:14: ( . )*
					try { DebugEnterSubRule(9);
					while (true)
					{
						int alt9=2;
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if (((LA9_1>=ACTION && LA9_1<=XDIGIT)))
						{
							alt9 = 1;
						}
						else if ((LA9_1==UP))
						{
							alt9 = 2;
						}


						} finally { DebugExitDecision(9); }
						switch ( alt9 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:78:14: .
							{
							DebugLocation(78, 14);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop9;
						}
					}

					loop9:
						;

					} finally { DebugExitSubRule(9); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(79, 3);
			// Grammars\\TreeToNFAConverter.g3:79:3: ( attrScope )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==SCOPE))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:79:3: attrScope
					{
					DebugLocation(79, 3);
					PushFollow(Follow._attrScope_in_grammarSpec198);
					attrScope();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(80, 3);
			// Grammars\\TreeToNFAConverter.g3:80:3: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==AMPERSAND))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:80:5: ^( AMPERSAND ( . )* )
					{
					DebugLocation(80, 5);
					DebugLocation(80, 7);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec206); if (state.failed) return;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(80, 17);
						// Grammars\\TreeToNFAConverter.g3:80:17: ( . )*
						try { DebugEnterSubRule(12);
						while (true)
						{
							int alt12=2;
							try { DebugEnterDecision(12, false);
							int LA12_1 = input.LA(1);

							if (((LA12_1>=ACTION && LA12_1<=XDIGIT)))
							{
								alt12 = 1;
							}
							else if ((LA12_1==UP))
							{
								alt12 = 2;
							}


							} finally { DebugExitDecision(12); }
							switch ( alt12 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:80:17: .
								{
								DebugLocation(80, 17);
								MatchAny(input); if (state.failed) return;

								}
								break;

							default:
								goto loop12;
							}
						}

						loop12:
							;

						} finally { DebugExitSubRule(12); }


						Match(input, TokenTypes.Up, null); if (state.failed) return;
					}


					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(81, 3);
			PushFollow(Follow._rules_in_grammarSpec218);
			rules();
			PopFollow();
			if (state.failed) return;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("grammarSpec", 3);
			LeaveRule("grammarSpec", 3);
			LeaveRule_grammarSpec();
		}
		DebugLocation(82, 1);
		} finally { DebugExitRule(GrammarFileName, "grammarSpec"); }
		return;

	}
	// $ANTLR end "grammarSpec"

	partial void EnterRule_rules();
	partial void LeaveRule_rules();
	// $ANTLR start "rules"
	// Grammars\\TreeToNFAConverter.g3:84:1: rules : ( rule | ^( PREC_RULE ( . )* ) )+ ;
	[GrammarRule("rules")]
	private void rules()
	{
		EnterRule_rules();
		EnterRule("rules", 4);
		TraceIn("rules", 4);
		try { DebugEnterRule(GrammarFileName, "rules");
		DebugLocation(84, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:85:2: ( ( rule | ^( PREC_RULE ( . )* ) )+ )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:85:4: ( rule | ^( PREC_RULE ( . )* ) )+
			{
			DebugLocation(85, 4);
			// Grammars\\TreeToNFAConverter.g3:85:4: ( rule | ^( PREC_RULE ( . )* ) )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=3;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==RULE))
				{
					alt15 = 1;
				}
				else if ((LA15_1==PREC_RULE))
				{
					alt15 = 2;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:85:5: rule
					{
					DebugLocation(85, 5);
					PushFollow(Follow._rule_in_rules230);
					rule();
					PopFollow();
					if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\TreeToNFAConverter.g3:85:12: ^( PREC_RULE ( . )* )
					{
					DebugLocation(85, 12);
					DebugLocation(85, 14);
					Match(input,PREC_RULE,Follow._PREC_RULE_in_rules235); if (state.failed) return;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(85, 24);
						// Grammars\\TreeToNFAConverter.g3:85:24: ( . )*
						try { DebugEnterSubRule(14);
						while (true)
						{
							int alt14=2;
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if (((LA14_1>=ACTION && LA14_1<=XDIGIT)))
							{
								alt14 = 1;
							}
							else if ((LA14_1==UP))
							{
								alt14 = 2;
							}


							} finally { DebugExitDecision(14); }
							switch ( alt14 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:85:24: .
								{
								DebugLocation(85, 24);
								MatchAny(input); if (state.failed) return;

								}
								break;

							default:
								goto loop14;
							}
						}

						loop14:
							;

						} finally { DebugExitSubRule(14); }


						Match(input, TokenTypes.Up, null); if (state.failed) return;
					}


					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rules", 4);
			LeaveRule("rules", 4);
			LeaveRule_rules();
		}
		DebugLocation(86, 1);
		} finally { DebugExitRule(GrammarFileName, "rules"); }
		return;

	}
	// $ANTLR end "rules"

	partial void EnterRule_rule();
	partial void LeaveRule_rule();
	// $ANTLR start "rule"
	// Grammars\\TreeToNFAConverter.g3:88:1: rule : ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) ;
	[GrammarRule("rule")]
	private TreeRuleReturnScope<GrammarAST> rule()
	{
		EnterRule_rule();
		EnterRule("rule", 5);
		TraceIn("rule", 5);
		TreeRuleReturnScope<GrammarAST> retval = new TreeRuleReturnScope<GrammarAST>();
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST id = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> b = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "rule");
		DebugLocation(88, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:89:2: ( ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:89:4: ^( RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block ( exceptionGroup )? EOR )
			{
			DebugLocation(89, 4);
			DebugLocation(89, 7);
			Match(input,RULE,Follow._RULE_in_rule254); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(89, 14);
			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule258); if (state.failed) return retval;
			DebugLocation(89, 22);
			if (state.backtracking == 0)
			{
				HandleRuleId(id);
			}
			DebugLocation(90, 4);
			// Grammars\\TreeToNFAConverter.g3:90:4: ( modifier )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==FRAGMENT||(LA16_1>=PRIVATE && LA16_1<=PUBLIC)))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:90:4: modifier
				{
				DebugLocation(90, 4);
				PushFollow(Follow._modifier_in_rule269);
				modifier();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(91, 4);
			DebugLocation(91, 6);
			Match(input,ARG,Follow._ARG_in_rule276); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(91, 10);
				// Grammars\\TreeToNFAConverter.g3:91:10: ( ARG_ACTION )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==ARG_ACTION))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:91:10: ARG_ACTION
					{
					DebugLocation(91, 10);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule278); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(17); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			DebugLocation(92, 4);
			DebugLocation(92, 6);
			Match(input,RET,Follow._RET_in_rule286); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(92, 10);
				// Grammars\\TreeToNFAConverter.g3:92:10: ( ARG_ACTION )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==ARG_ACTION))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:92:10: ARG_ACTION
					{
					DebugLocation(92, 10);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule288); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(18); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			DebugLocation(93, 4);
			// Grammars\\TreeToNFAConverter.g3:93:4: ( throwsSpec )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==THROWS))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:93:4: throwsSpec
				{
				DebugLocation(93, 4);
				PushFollow(Follow._throwsSpec_in_rule295);
				throwsSpec();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(94, 4);
			// Grammars\\TreeToNFAConverter.g3:94:4: ( ^( OPTIONS ( . )* ) )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==OPTIONS))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:94:6: ^( OPTIONS ( . )* )
				{
				DebugLocation(94, 6);
				DebugLocation(94, 8);
				Match(input,OPTIONS,Follow._OPTIONS_in_rule304); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(94, 16);
					// Grammars\\TreeToNFAConverter.g3:94:16: ( . )*
					try { DebugEnterSubRule(20);
					while (true)
					{
						int alt20=2;
						try { DebugEnterDecision(20, false);
						int LA20_1 = input.LA(1);

						if (((LA20_1>=ACTION && LA20_1<=XDIGIT)))
						{
							alt20 = 1;
						}
						else if ((LA20_1==UP))
						{
							alt20 = 2;
						}


						} finally { DebugExitDecision(20); }
						switch ( alt20 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:94:16: .
							{
							DebugLocation(94, 16);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop20;
						}
					}

					loop20:
						;

					} finally { DebugExitSubRule(20); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(95, 4);
			// Grammars\\TreeToNFAConverter.g3:95:4: ( ruleScopeSpec )?
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if ((LA22_1==SCOPE))
			{
				alt22 = 1;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:95:4: ruleScopeSpec
				{
				DebugLocation(95, 4);
				PushFollow(Follow._ruleScopeSpec_in_rule316);
				ruleScopeSpec();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(96, 4);
			// Grammars\\TreeToNFAConverter.g3:96:4: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==AMPERSAND))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:96:6: ^( AMPERSAND ( . )* )
					{
					DebugLocation(96, 6);
					DebugLocation(96, 8);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule325); if (state.failed) return retval;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
						DebugLocation(96, 18);
						// Grammars\\TreeToNFAConverter.g3:96:18: ( . )*
						try { DebugEnterSubRule(23);
						while (true)
						{
							int alt23=2;
							try { DebugEnterDecision(23, false);
							int LA23_1 = input.LA(1);

							if (((LA23_1>=ACTION && LA23_1<=XDIGIT)))
							{
								alt23 = 1;
							}
							else if ((LA23_1==UP))
							{
								alt23 = 2;
							}


							} finally { DebugExitDecision(23); }
							switch ( alt23 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:96:18: .
								{
								DebugLocation(96, 18);
								MatchAny(input); if (state.failed) return retval;

								}
								break;

							default:
								goto loop23;
							}
						}

						loop23:
							;

						} finally { DebugExitSubRule(23); }


						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					}


					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(97, 5);
			PushFollow(Follow._block_in_rule339);
			b=block();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(98, 4);
			// Grammars\\TreeToNFAConverter.g3:98:4: ( exceptionGroup )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==CATCH||LA25_1==FINALLY))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:98:4: exceptionGroup
				{
				DebugLocation(98, 4);
				PushFollow(Follow._exceptionGroup_in_rule344);
				exceptionGroup();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(99, 4);
			Match(input,EOR,Follow._EOR_in_rule350); if (state.failed) return retval;
			DebugLocation(100, 11);
			if (state.backtracking == 0)
			{
				HandleRule(retval.Start, (b!=null?((TreeToNFAConverter.block_return)b).g:default(StateCluster)), (b!=null?((GrammarAST)b.Start):default(GrammarAST)), id);
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rule", 5);
			LeaveRule("rule", 5);
			LeaveRule_rule();
		}
		DebugLocation(102, 1);
		} finally { DebugExitRule(GrammarFileName, "rule"); }
		return retval;

	}
	// $ANTLR end "rule"

	partial void EnterRule_modifier();
	partial void LeaveRule_modifier();
	// $ANTLR start "modifier"
	// Grammars\\TreeToNFAConverter.g3:104:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
	[GrammarRule("modifier")]
	private void modifier()
	{
		EnterRule_modifier();
		EnterRule("modifier", 6);
		TraceIn("modifier", 6);
		try { DebugEnterRule(GrammarFileName, "modifier");
		DebugLocation(104, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:105:2: ( 'protected' | 'public' | 'private' | 'fragment' )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:
			{
			DebugLocation(105, 2);
			if (input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC))
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("modifier", 6);
			LeaveRule("modifier", 6);
			LeaveRule_modifier();
		}
		DebugLocation(109, 1);
		} finally { DebugExitRule(GrammarFileName, "modifier"); }
		return;

	}
	// $ANTLR end "modifier"

	partial void EnterRule_throwsSpec();
	partial void LeaveRule_throwsSpec();
	// $ANTLR start "throwsSpec"
	// Grammars\\TreeToNFAConverter.g3:111:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
	[GrammarRule("throwsSpec")]
	private void throwsSpec()
	{
		EnterRule_throwsSpec();
		EnterRule("throwsSpec", 7);
		TraceIn("throwsSpec", 7);
		try { DebugEnterRule(GrammarFileName, "throwsSpec");
		DebugLocation(111, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:112:2: ( ^( 'throws' ( ID )+ ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:112:4: ^( 'throws' ( ID )+ )
			{
			DebugLocation(112, 4);
			DebugLocation(112, 6);
			Match(input,THROWS,Follow._THROWS_in_throwsSpec404); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(112, 15);
			// Grammars\\TreeToNFAConverter.g3:112:15: ( ID )+
			int cnt26=0;
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==ID))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:112:15: ID
					{
					DebugLocation(112, 15);
					Match(input,ID,Follow._ID_in_throwsSpec406); if (state.failed) return;

					}
					break;

				default:
					if (cnt26 >= 1)
						goto loop26;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee26 = new EarlyExitException( 26, input );
					DebugRecognitionException(eee26);
					throw eee26;
				}
				cnt26++;
			}
			loop26:
				;

			} finally { DebugExitSubRule(26); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("throwsSpec", 7);
			LeaveRule("throwsSpec", 7);
			LeaveRule_throwsSpec();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "throwsSpec"); }
		return;

	}
	// $ANTLR end "throwsSpec"

	partial void EnterRule_ruleScopeSpec();
	partial void LeaveRule_ruleScopeSpec();
	// $ANTLR start "ruleScopeSpec"
	// Grammars\\TreeToNFAConverter.g3:115:1: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
	[GrammarRule("ruleScopeSpec")]
	private void ruleScopeSpec()
	{
		EnterRule_ruleScopeSpec();
		EnterRule("ruleScopeSpec", 8);
		TraceIn("ruleScopeSpec", 8);
		try { DebugEnterRule(GrammarFileName, "ruleScopeSpec");
		DebugLocation(115, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:116:2: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:116:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
			{
			DebugLocation(116, 4);
			DebugLocation(116, 6);
			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec420); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(116, 14);
				// Grammars\\TreeToNFAConverter.g3:116:14: ( ^( AMPERSAND ( . )* ) )*
				try { DebugEnterSubRule(28);
				while (true)
				{
					int alt28=2;
					try { DebugEnterDecision(28, false);
					int LA28_1 = input.LA(1);

					if ((LA28_1==AMPERSAND))
					{
						alt28 = 1;
					}


					} finally { DebugExitDecision(28); }
					switch ( alt28 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:116:16: ^( AMPERSAND ( . )* )
						{
						DebugLocation(116, 16);
						DebugLocation(116, 18);
						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec425); if (state.failed) return;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return;
							DebugLocation(116, 28);
							// Grammars\\TreeToNFAConverter.g3:116:28: ( . )*
							try { DebugEnterSubRule(27);
							while (true)
							{
								int alt27=2;
								try { DebugEnterDecision(27, false);
								int LA27_1 = input.LA(1);

								if (((LA27_1>=ACTION && LA27_1<=XDIGIT)))
								{
									alt27 = 1;
								}
								else if ((LA27_1==UP))
								{
									alt27 = 2;
								}


								} finally { DebugExitDecision(27); }
								switch ( alt27 )
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\TreeToNFAConverter.g3:116:28: .
									{
									DebugLocation(116, 28);
									MatchAny(input); if (state.failed) return;

									}
									break;

								default:
									goto loop27;
								}
							}

							loop27:
								;

							} finally { DebugExitSubRule(27); }


							Match(input, TokenTypes.Up, null); if (state.failed) return;
						}


						}
						break;

					default:
						goto loop28;
					}
				}

				loop28:
					;

				} finally { DebugExitSubRule(28); }

				DebugLocation(116, 35);
				// Grammars\\TreeToNFAConverter.g3:116:35: ( ACTION )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1==ACTION))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:116:35: ACTION
					{
					DebugLocation(116, 35);
					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec434); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(29); }

				DebugLocation(116, 43);
				// Grammars\\TreeToNFAConverter.g3:116:43: ( ID )*
				try { DebugEnterSubRule(30);
				while (true)
				{
					int alt30=2;
					try { DebugEnterDecision(30, false);
					int LA30_1 = input.LA(1);

					if ((LA30_1==ID))
					{
						alt30 = 1;
					}


					} finally { DebugExitDecision(30); }
					switch ( alt30 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:116:43: ID
						{
						DebugLocation(116, 43);
						Match(input,ID,Follow._ID_in_ruleScopeSpec437); if (state.failed) return;

						}
						break;

					default:
						goto loop30;
					}
				}

				loop30:
					;

				} finally { DebugExitSubRule(30); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ruleScopeSpec", 8);
			LeaveRule("ruleScopeSpec", 8);
			LeaveRule_ruleScopeSpec();
		}
		DebugLocation(117, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleScopeSpec"); }
		return;

	}
	// $ANTLR end "ruleScopeSpec"

	private sealed partial class block_return : TreeRuleReturnScope<GrammarAST>
	{
		public StateCluster g;
		public block_return(TreeToNFAConverter grammar) {OnCreated(grammar);}
		partial void OnCreated(TreeToNFAConverter grammar);
	}

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// Grammars\\TreeToNFAConverter.g3:119:1: block returns [StateCluster g] : ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) );
	[GrammarRule("block")]
	private TreeToNFAConverter.block_return block()
	{
		EnterRule_block();
		EnterRule("block", 9);
		TraceIn("block", 9);
		TreeToNFAConverter.block_return retval = new TreeToNFAConverter.block_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		StateCluster a = default(StateCluster);
		TreeRuleReturnScope<GrammarAST> set1 = default(TreeRuleReturnScope<GrammarAST>);


			List<StateCluster> alts = new List<StateCluster>();
			this.blockLevel++;
			if ( this.blockLevel==1 )
				this.outerAltNum=1;

		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(119, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:127:2: ({...}? => set | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB ) )
			int alt34=2;
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1==BLOCK))
			{
				int LA34_2 = input.LA(2);

				if (((grammar.IsValidSet(this,retval.Start) &&
						 !currentRuleName.Equals(Grammar.ArtificialTokensRuleName))))
				{
					alt34 = 1;
				}
				else if ((true))
				{
					alt34 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:127:4: {...}? => set
				{
				DebugLocation(127, 4);
				if (!((grammar.IsValidSet(this,retval.Start) &&
						 !currentRuleName.Equals(Grammar.ArtificialTokensRuleName))))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "block", "grammar.IsValidSet(this,$start) &&\n\t\t !currentRuleName.Equals(Grammar.ArtificialTokensRuleName)");
				}
				DebugLocation(129, 3);
				PushFollow(Follow._set_in_block465);
				set1=set();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(129, 7);
				if (state.backtracking == 0)
				{
					retval.g = (set1!=null?((TreeToNFAConverter.set_return)set1).g:default(StateCluster));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:131:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (a= alternative rewrite )+ EOB )
				{
				DebugLocation(131, 4);
				DebugLocation(131, 7);
				Match(input,BLOCK,Follow._BLOCK_in_block475); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(131, 13);
				// Grammars\\TreeToNFAConverter.g3:131:13: ( ^( OPTIONS ( . )* ) )?
				int alt32=2;
				try { DebugEnterSubRule(32);
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1==OPTIONS))
				{
					alt32 = 1;
				}
				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:131:15: ^( OPTIONS ( . )* )
					{
					DebugLocation(131, 15);
					DebugLocation(131, 17);
					Match(input,OPTIONS,Follow._OPTIONS_in_block480); if (state.failed) return retval;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
						DebugLocation(131, 25);
						// Grammars\\TreeToNFAConverter.g3:131:25: ( . )*
						try { DebugEnterSubRule(31);
						while (true)
						{
							int alt31=2;
							try { DebugEnterDecision(31, false);
							int LA31_1 = input.LA(1);

							if (((LA31_1>=ACTION && LA31_1<=XDIGIT)))
							{
								alt31 = 1;
							}
							else if ((LA31_1==UP))
							{
								alt31 = 2;
							}


							} finally { DebugExitDecision(31); }
							switch ( alt31 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:131:25: .
								{
								DebugLocation(131, 25);
								MatchAny(input); if (state.failed) return retval;

								}
								break;

							default:
								goto loop31;
							}
						}

						loop31:
							;

						} finally { DebugExitSubRule(31); }


						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					}


					}
					break;

				}
				} finally { DebugExitSubRule(32); }

				DebugLocation(132, 4);
				// Grammars\\TreeToNFAConverter.g3:132:4: (a= alternative rewrite )+
				int cnt33=0;
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=2;
					try { DebugEnterDecision(33, false);
					int LA33_1 = input.LA(1);

					if ((LA33_1==ALT))
					{
						alt33 = 1;
					}


					} finally { DebugExitDecision(33); }
					switch (alt33)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:132:6: a= alternative rewrite
						{
						DebugLocation(132, 7);
						PushFollow(Follow._alternative_in_block496);
						a=alternative();
						PopFollow();
						if (state.failed) return retval;
						DebugLocation(132, 20);
						PushFollow(Follow._rewrite_in_block498);
						rewrite();
						PopFollow();
						if (state.failed) return retval;
						DebugLocation(133, 5);
						if (state.backtracking == 0)
						{

												alts.Add(a);
											
						}
						DebugLocation(136, 5);

											if ( blockLevel == 1 )
												outerAltNum++;
										

						}
						break;

					default:
						if (cnt33 >= 1)
							goto loop33;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee33 = new EarlyExitException( 33, input );
						DebugRecognitionException(eee33);
						throw eee33;
					}
					cnt33++;
				}
				loop33:
					;

				} finally { DebugExitSubRule(33); }

				DebugLocation(141, 4);
				Match(input,EOB,Follow._EOB_in_block521); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(143, 3);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildAlternativeBlock(alts);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("block", 9);
			LeaveRule("block", 9);
			LeaveRule_block();
			 blockLevel--; 
		}
		DebugLocation(144, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();
	// $ANTLR start "alternative"
	// Grammars\\TreeToNFAConverter.g3:147:1: alternative returns [StateCluster g] : ^( ALT (e= element )+ EOA ) ;
	[GrammarRule("alternative")]
	private StateCluster alternative()
	{
		EnterRule_alternative();
		EnterRule("alternative", 10);
		TraceIn("alternative", 10);
		StateCluster g = default(StateCluster);


		TreeRuleReturnScope<GrammarAST> e = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(147, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:148:2: ( ^( ALT (e= element )+ EOA ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:148:4: ^( ALT (e= element )+ EOA )
			{
			DebugLocation(148, 4);
			DebugLocation(148, 7);
			Match(input,ALT,Follow._ALT_in_alternative550); if (state.failed) return g;

			Match(input, TokenTypes.Down, null); if (state.failed) return g;
			DebugLocation(148, 11);
			// Grammars\\TreeToNFAConverter.g3:148:11: (e= element )+
			int cnt35=0;
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==ACTION||(LA35_1>=ASSIGN && LA35_1<=BLOCK)||(LA35_1>=CHAR_LITERAL && LA35_1<=CHAR_RANGE)||LA35_1==CLOSURE||LA35_1==DOT||LA35_1==EPSILON||LA35_1==FORCED_ACTION||LA35_1==GATED_SEMPRED||LA35_1==NOT||LA35_1==OPTIONAL||(LA35_1>=PLUS_ASSIGN && LA35_1<=POSITIVE_CLOSURE)||LA35_1==RANGE||LA35_1==ROOT||LA35_1==RULE_REF||LA35_1==SEMPRED||(LA35_1>=STRING_LITERAL && LA35_1<=SYN_SEMPRED)||LA35_1==TOKEN_REF||LA35_1==TREE_BEGIN||LA35_1==WILDCARD))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:148:12: e= element
					{
					DebugLocation(148, 13);
					PushFollow(Follow._element_in_alternative555);
					e=element();
					PopFollow();
					if (state.failed) return g;
					DebugLocation(148, 22);
					if (state.backtracking == 0)
					{
						g = HandleAlternativeElement(g, (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster)));
					}

					}
					break;

				default:
					if (cnt35 >= 1)
						goto loop35;

					if (state.backtracking>0) {state.failed=true; return g;}
					EarlyExitException eee35 = new EarlyExitException( 35, input );
					DebugRecognitionException(eee35);
					throw eee35;
				}
				cnt35++;
			}
			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(148, 68);
			Match(input,EOA,Follow._EOA_in_alternative562); if (state.failed) return g;

			Match(input, TokenTypes.Up, null); if (state.failed) return g;

			DebugLocation(149, 3);
			if (state.backtracking == 0)
			{
				g = HandleAlternativeEnd(g);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("alternative", 10);
			LeaveRule("alternative", 10);
			LeaveRule_alternative();
		}
		DebugLocation(150, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return g;

	}
	// $ANTLR end "alternative"

	partial void EnterRule_exceptionGroup();
	partial void LeaveRule_exceptionGroup();
	// $ANTLR start "exceptionGroup"
	// Grammars\\TreeToNFAConverter.g3:152:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
	[GrammarRule("exceptionGroup")]
	private void exceptionGroup()
	{
		EnterRule_exceptionGroup();
		EnterRule("exceptionGroup", 11);
		TraceIn("exceptionGroup", 11);
		try { DebugEnterRule(GrammarFileName, "exceptionGroup");
		DebugLocation(152, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:153:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==CATCH))
			{
				alt38 = 1;
			}
			else if ((LA38_1==FINALLY))
			{
				alt38 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:153:4: ( exceptionHandler )+ ( finallyClause )?
				{
				DebugLocation(153, 4);
				// Grammars\\TreeToNFAConverter.g3:153:4: ( exceptionHandler )+
				int cnt36=0;
				try { DebugEnterSubRule(36);
				while (true)
				{
					int alt36=2;
					try { DebugEnterDecision(36, false);
					int LA36_1 = input.LA(1);

					if ((LA36_1==CATCH))
					{
						alt36 = 1;
					}


					} finally { DebugExitDecision(36); }
					switch (alt36)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:153:4: exceptionHandler
						{
						DebugLocation(153, 4);
						PushFollow(Follow._exceptionHandler_in_exceptionGroup579);
						exceptionHandler();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						if (cnt36 >= 1)
							goto loop36;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee36 = new EarlyExitException( 36, input );
						DebugRecognitionException(eee36);
						throw eee36;
					}
					cnt36++;
				}
				loop36:
					;

				} finally { DebugExitSubRule(36); }

				DebugLocation(153, 22);
				// Grammars\\TreeToNFAConverter.g3:153:22: ( finallyClause )?
				int alt37=2;
				try { DebugEnterSubRule(37);
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1==FINALLY))
				{
					alt37 = 1;
				}
				} finally { DebugExitDecision(37); }
				switch (alt37)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:153:22: finallyClause
					{
					DebugLocation(153, 22);
					PushFollow(Follow._finallyClause_in_exceptionGroup582);
					finallyClause();
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(37); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:154:4: finallyClause
				{
				DebugLocation(154, 4);
				PushFollow(Follow._finallyClause_in_exceptionGroup588);
				finallyClause();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionGroup", 11);
			LeaveRule("exceptionGroup", 11);
			LeaveRule_exceptionGroup();
		}
		DebugLocation(155, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionGroup"); }
		return;

	}
	// $ANTLR end "exceptionGroup"

	partial void EnterRule_exceptionHandler();
	partial void LeaveRule_exceptionHandler();
	// $ANTLR start "exceptionHandler"
	// Grammars\\TreeToNFAConverter.g3:157:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
	[GrammarRule("exceptionHandler")]
	private void exceptionHandler()
	{
		EnterRule_exceptionHandler();
		EnterRule("exceptionHandler", 12);
		TraceIn("exceptionHandler", 12);
		try { DebugEnterRule(GrammarFileName, "exceptionHandler");
		DebugLocation(157, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:158:2: ( ^( 'catch' ARG_ACTION ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:158:7: ^( 'catch' ARG_ACTION ACTION )
			{
			DebugLocation(158, 7);
			DebugLocation(158, 9);
			Match(input,CATCH,Follow._CATCH_in_exceptionHandler603); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(158, 17);
			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler605); if (state.failed) return;
			DebugLocation(158, 28);
			Match(input,ACTION,Follow._ACTION_in_exceptionHandler607); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionHandler", 12);
			LeaveRule("exceptionHandler", 12);
			LeaveRule_exceptionHandler();
		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionHandler"); }
		return;

	}
	// $ANTLR end "exceptionHandler"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// Grammars\\TreeToNFAConverter.g3:161:1: finallyClause : ^( 'finally' ACTION ) ;
	[GrammarRule("finallyClause")]
	private void finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 13);
		TraceIn("finallyClause", 13);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(161, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:162:2: ( ^( 'finally' ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:162:7: ^( 'finally' ACTION )
			{
			DebugLocation(162, 7);
			DebugLocation(162, 9);
			Match(input,FINALLY,Follow._FINALLY_in_finallyClause623); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(162, 19);
			Match(input,ACTION,Follow._ACTION_in_finallyClause625); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("finallyClause", 13);
			LeaveRule("finallyClause", 13);
			LeaveRule_finallyClause();
		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_rewrite();
	partial void LeaveRule_rewrite();
	// $ANTLR start "rewrite"
	// Grammars\\TreeToNFAConverter.g3:165:1: rewrite : ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |);
	[GrammarRule("rewrite")]
	private TreeRuleReturnScope<GrammarAST> rewrite()
	{
		EnterRule_rewrite();
		EnterRule("rewrite", 14);
		TraceIn("rewrite", 14);
		TreeRuleReturnScope<GrammarAST> retval = new TreeRuleReturnScope<GrammarAST>();
		retval.Start = (GrammarAST)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "rewrite");
		DebugLocation(165, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:166:2: ( ^( REWRITES ( ^( REWRITE ( . )* ) )* ) |)
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==REWRITES))
			{
				alt41 = 1;
			}
			else if ((LA41_1==ALT||LA41_1==EOB))
			{
				alt41 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:166:4: ^( REWRITES ( ^( REWRITE ( . )* ) )* )
				{
				DebugLocation(166, 4);
				DebugLocation(166, 7);
				Match(input,REWRITES,Follow._REWRITES_in_rewrite639); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(167, 4);
					// Grammars\\TreeToNFAConverter.g3:167:4: ( ^( REWRITE ( . )* ) )*
					try { DebugEnterSubRule(40);
					while (true)
					{
						int alt40=2;
						try { DebugEnterDecision(40, false);
						int LA40_1 = input.LA(1);

						if ((LA40_1==REWRITE))
						{
							alt40 = 1;
						}


						} finally { DebugExitDecision(40); }
						switch ( alt40 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:168:5: ^( REWRITE ( . )* )
							{
							DebugLocation(168, 5);
							if (state.backtracking == 0)
							{

													if ( grammar.GetOption("output")==null )
													{
														ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
																				  grammar, retval.Start.Token, currentRuleName);
													}
												
							}
							DebugLocation(175, 5);
							DebugLocation(175, 7);
							Match(input,REWRITE,Follow._REWRITE_in_rewrite657); if (state.failed) return retval;

							if (input.LA(1) == TokenTypes.Down)
							{
								Match(input, TokenTypes.Down, null); if (state.failed) return retval;
								DebugLocation(175, 15);
								// Grammars\\TreeToNFAConverter.g3:175:15: ( . )*
								try { DebugEnterSubRule(39);
								while (true)
								{
									int alt39=2;
									try { DebugEnterDecision(39, false);
									int LA39_1 = input.LA(1);

									if (((LA39_1>=ACTION && LA39_1<=XDIGIT)))
									{
										alt39 = 1;
									}
									else if ((LA39_1==UP))
									{
										alt39 = 2;
									}


									} finally { DebugExitDecision(39); }
									switch ( alt39 )
									{
									case 1:
										DebugEnterAlt(1);
										// Grammars\\TreeToNFAConverter.g3:175:15: .
										{
										DebugLocation(175, 15);
										MatchAny(input); if (state.failed) return retval;

										}
										break;

									default:
										goto loop39;
									}
								}

								loop39:
									;

								} finally { DebugExitSubRule(39); }


								Match(input, TokenTypes.Up, null); if (state.failed) return retval;
							}


							}
							break;

						default:
							goto loop40;
						}
					}

					loop40:
						;

					} finally { DebugExitSubRule(40); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:179:2: 
				{
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite", 14);
			LeaveRule("rewrite", 14);
			LeaveRule_rewrite();
		}
		DebugLocation(179, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite"); }
		return retval;

	}
	// $ANTLR end "rewrite"

	private sealed partial class element_return : TreeRuleReturnScope<GrammarAST>
	{
		public StateCluster g;
		public element_return(TreeToNFAConverter grammar) {OnCreated(grammar);}
		partial void OnCreated(TreeToNFAConverter grammar);
	}

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// Grammars\\TreeToNFAConverter.g3:181:1: element returns [StateCluster g] : ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
	[GrammarRule("element")]
	private TreeToNFAConverter.element_return element()
	{
		EnterRule_element();
		EnterRule("element", 15);
		TraceIn("element", 15);
		TreeToNFAConverter.element_return retval = new TreeToNFAConverter.element_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST c1 = default(GrammarAST);
		GrammarAST c2 = default(GrammarAST);
		GrammarAST ACTION5 = default(GrammarAST);
		GrammarAST FORCED_ACTION6 = default(GrammarAST);
		GrammarAST SEMPRED7 = default(GrammarAST);
		GrammarAST SYN_SEMPRED8 = default(GrammarAST);
		GrammarAST BACKTRACK_SEMPRED9 = default(GrammarAST);
		GrammarAST GATED_SEMPRED10 = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> e = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> a = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> b = default(TreeRuleReturnScope<GrammarAST>);
		StateCluster atom_or_notatom2 = default(StateCluster);
		TreeRuleReturnScope<GrammarAST> ebnf3 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> tree_4 = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(181, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:182:2: ( ^( ROOT e= element ) | ^( BANG e= element ) | ^( ASSIGN ID e= element ) | ^( PLUS_ASSIGN ID e= element ) | ^( RANGE a= atom[null] b= atom[null] ) | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | atom_or_notatom | ebnf | tree_ | ^( SYNPRED block ) | ACTION | FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
			int alt43=17;
			try { DebugEnterDecision(43, false);
			switch (input.LA(1))
			{
			case ROOT:
				{
				alt43 = 1;
				}
				break;
			case BANG:
				{
				alt43 = 2;
				}
				break;
			case ASSIGN:
				{
				alt43 = 3;
				}
				break;
			case PLUS_ASSIGN:
				{
				alt43 = 4;
				}
				break;
			case RANGE:
				{
				alt43 = 5;
				}
				break;
			case CHAR_RANGE:
				{
				alt43 = 6;
				}
				break;
			case CHAR_LITERAL:
			case DOT:
			case NOT:
			case RULE_REF:
			case STRING_LITERAL:
			case TOKEN_REF:
			case WILDCARD:
				{
				alt43 = 7;
				}
				break;
			case BLOCK:
			case CLOSURE:
			case OPTIONAL:
			case POSITIVE_CLOSURE:
				{
				alt43 = 8;
				}
				break;
			case TREE_BEGIN:
				{
				alt43 = 9;
				}
				break;
			case SYNPRED:
				{
				alt43 = 10;
				}
				break;
			case ACTION:
				{
				alt43 = 11;
				}
				break;
			case FORCED_ACTION:
				{
				alt43 = 12;
				}
				break;
			case SEMPRED:
				{
				alt43 = 13;
				}
				break;
			case SYN_SEMPRED:
				{
				alt43 = 14;
				}
				break;
			case BACKTRACK_SEMPRED:
				{
				alt43 = 15;
				}
				break;
			case GATED_SEMPRED:
				{
				alt43 = 16;
				}
				break;
			case EPSILON:
				{
				alt43 = 17;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:182:4: ^( ROOT e= element )
				{
				DebugLocation(182, 4);
				DebugLocation(182, 6);
				Match(input,ROOT,Follow._ROOT_in_element690); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(182, 12);
				PushFollow(Follow._element_in_element694);
				e=element();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(182, 29);
				if (state.backtracking == 0)
				{
					retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:183:4: ^( BANG e= element )
				{
				DebugLocation(183, 4);
				DebugLocation(183, 6);
				Match(input,BANG,Follow._BANG_in_element710); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(183, 12);
				PushFollow(Follow._element_in_element714);
				e=element();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(183, 29);
				if (state.backtracking == 0)
				{
					retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\TreeToNFAConverter.g3:184:4: ^( ASSIGN ID e= element )
				{
				DebugLocation(184, 4);
				DebugLocation(184, 6);
				Match(input,ASSIGN,Follow._ASSIGN_in_element730); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(184, 13);
				Match(input,ID,Follow._ID_in_element732); if (state.failed) return retval;
				DebugLocation(184, 17);
				PushFollow(Follow._element_in_element736);
				e=element();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(184, 33);
				if (state.backtracking == 0)
				{
					retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster));
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\TreeToNFAConverter.g3:185:4: ^( PLUS_ASSIGN ID e= element )
				{
				DebugLocation(185, 4);
				DebugLocation(185, 6);
				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element751); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(185, 18);
				Match(input,ID,Follow._ID_in_element753); if (state.failed) return retval;
				DebugLocation(185, 22);
				PushFollow(Follow._element_in_element757);
				e=element();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(185, 37);
				if (state.backtracking == 0)
				{
					retval.g = (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster));
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\TreeToNFAConverter.g3:186:4: ^( RANGE a= atom[null] b= atom[null] )
				{
				DebugLocation(186, 4);
				DebugLocation(186, 6);
				Match(input,RANGE,Follow._RANGE_in_element771); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(186, 13);
				PushFollow(Follow._atom_in_element775);
				a=atom(null);
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(186, 26);
				PushFollow(Follow._atom_in_element780);
				b=atom(null);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(186, 42);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildRange(grammar.GetTokenType((a!=null?(input.TokenStream.ToString(input.TreeAdaptor.GetTokenStartIndex(a.Start),input.TreeAdaptor.GetTokenStopIndex(a.Start))):default(string))), grammar.GetTokenType((b!=null?(input.TokenStream.ToString(input.TreeAdaptor.GetTokenStartIndex(b.Start),input.TreeAdaptor.GetTokenStopIndex(b.Start))):default(string))));
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\TreeToNFAConverter.g3:187:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
				{
				DebugLocation(187, 4);
				DebugLocation(187, 6);
				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element793); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(187, 19);
				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element797); if (state.failed) return retval;
				DebugLocation(187, 35);
				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element801); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(187, 50);
				if (state.backtracking == 0)
				{
					if (grammar.type == GrammarType.Lexer) retval.g = factory.BuildCharRange((c1!=null?c1.Text:default(string)), (c2!=null?c2.Text:default(string)));
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\TreeToNFAConverter.g3:188:4: atom_or_notatom
				{
				DebugLocation(188, 4);
				PushFollow(Follow._atom_or_notatom_in_element809);
				atom_or_notatom2=atom_or_notatom();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(188, 28);
				if (state.backtracking == 0)
				{
					retval.g = atom_or_notatom2;
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\TreeToNFAConverter.g3:189:4: ebnf
				{
				DebugLocation(189, 4);
				PushFollow(Follow._ebnf_in_element824);
				ebnf3=ebnf();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(189, 19);
				if (state.backtracking == 0)
				{
					retval.g = (ebnf3!=null?((TreeToNFAConverter.ebnf_return)ebnf3).g:default(StateCluster));
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\TreeToNFAConverter.g3:190:4: tree_
				{
				DebugLocation(190, 4);
				PushFollow(Follow._tree__in_element841);
				tree_4=tree_();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(190, 20);
				if (state.backtracking == 0)
				{
					retval.g = (tree_4!=null?((TreeToNFAConverter.tree__return)tree_4).g:default(StateCluster));
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\TreeToNFAConverter.g3:191:4: ^( SYNPRED block )
				{
				DebugLocation(191, 4);
				DebugLocation(191, 6);
				Match(input,SYNPRED,Follow._SYNPRED_in_element859); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(191, 14);
				PushFollow(Follow._block_in_element861);
				block();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammars\\TreeToNFAConverter.g3:192:4: ACTION
				{
				DebugLocation(192, 4);
				ACTION5=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element867); if (state.failed) return retval;
				DebugLocation(192, 21);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildAction(ACTION5);
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammars\\TreeToNFAConverter.g3:193:4: FORCED_ACTION
				{
				DebugLocation(193, 4);
				FORCED_ACTION6=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element884); if (state.failed) return retval;
				DebugLocation(193, 26);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildAction(FORCED_ACTION6);
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Grammars\\TreeToNFAConverter.g3:194:4: SEMPRED
				{
				DebugLocation(194, 4);
				SEMPRED7=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element899); if (state.failed) return retval;
				DebugLocation(194, 22);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildSemanticPredicate(SEMPRED7);
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Grammars\\TreeToNFAConverter.g3:195:4: SYN_SEMPRED
				{
				DebugLocation(195, 4);
				SYN_SEMPRED8=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element916); if (state.failed) return retval;
				DebugLocation(195, 25);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildSemanticPredicate(SYN_SEMPRED8);
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// Grammars\\TreeToNFAConverter.g3:196:4: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(196, 4);
				DebugLocation(196, 6);
				BACKTRACK_SEMPRED9=(GrammarAST)Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element933); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(196, 24);
					// Grammars\\TreeToNFAConverter.g3:196:24: ( . )*
					try { DebugEnterSubRule(42);
					while (true)
					{
						int alt42=2;
						try { DebugEnterDecision(42, false);
						int LA42_1 = input.LA(1);

						if (((LA42_1>=ACTION && LA42_1<=XDIGIT)))
						{
							alt42 = 1;
						}
						else if ((LA42_1==UP))
						{
							alt42 = 2;
						}


						} finally { DebugExitDecision(42); }
						switch ( alt42 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:196:24: .
							{
							DebugLocation(196, 24);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop42;
						}
					}

					loop42:
						;

					} finally { DebugExitSubRule(42); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(196, 34);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildSemanticPredicate(BACKTRACK_SEMPRED9);
				}

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// Grammars\\TreeToNFAConverter.g3:197:4: GATED_SEMPRED
				{
				DebugLocation(197, 4);
				GATED_SEMPRED10=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element950); if (state.failed) return retval;
				DebugLocation(197, 26);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildSemanticPredicate(GATED_SEMPRED10);
				}

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// Grammars\\TreeToNFAConverter.g3:198:4: EPSILON
				{
				DebugLocation(198, 4);
				Match(input,EPSILON,Follow._EPSILON_in_element965); if (state.failed) return retval;
				DebugLocation(198, 22);
				if (state.backtracking == 0)
				{
					retval.g = factory.BuildEpsilon();
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("element", 15);
			LeaveRule("element", 15);
			LeaveRule_element();
		}
		DebugLocation(199, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return retval;

	}
	// $ANTLR end "element"

	private sealed partial class ebnf_return : TreeRuleReturnScope<GrammarAST>
	{
		public StateCluster g;
		public ebnf_return(TreeToNFAConverter grammar) {OnCreated(grammar);}
		partial void OnCreated(TreeToNFAConverter grammar);
	}

	partial void EnterRule_ebnf();
	partial void LeaveRule_ebnf();
	// $ANTLR start "ebnf"
	// Grammars\\TreeToNFAConverter.g3:201:1: ebnf returns [StateCluster g] : ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) );
	[GrammarRule("ebnf")]
	private TreeToNFAConverter.ebnf_return ebnf()
	{
		EnterRule_ebnf();
		EnterRule("ebnf", 16);
		TraceIn("ebnf", 16);
		TreeToNFAConverter.ebnf_return retval = new TreeToNFAConverter.ebnf_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> b = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> set11 = default(TreeRuleReturnScope<GrammarAST>);


			GrammarAST blk = retval.Start;
			if (blk.Type != BLOCK)
				blk = (GrammarAST)blk.GetChild(0);

		try { DebugEnterRule(GrammarFileName, "ebnf");
		DebugLocation(201, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:208:2: ({...}? => set |b= block | ^( OPTIONAL b= block ) | ^( CLOSURE b= block ) | ^( POSITIVE_CLOSURE b= block ) )
			int alt44=5;
			try { DebugEnterDecision(44, false);
			switch (input.LA(1))
			{
			case BLOCK:
				{
				int LA44_2 = input.LA(2);

				if (((grammar.IsValidSet(this,retval.Start))))
				{
					alt44 = 1;
				}
				else if ((true))
				{
					alt44 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 44, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case OPTIONAL:
				{
				alt44 = 3;
				}
				break;
			case CLOSURE:
				{
				alt44 = 4;
				}
				break;
			case POSITIVE_CLOSURE:
				{
				alt44 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 44, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:208:4: {...}? => set
				{
				DebugLocation(208, 4);
				if (!((grammar.IsValidSet(this,retval.Start))))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "ebnf", "grammar.IsValidSet(this,$start)");
				}
				DebugLocation(208, 42);
				PushFollow(Follow._set_in_ebnf1001);
				set11=set();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(208, 46);
				if (state.backtracking == 0)
				{
					retval.g = HandleEbnfSet((set11!=null?((TreeToNFAConverter.set_return)set11).g:default(StateCluster)));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:209:4: b= block
				{
				DebugLocation(209, 5);
				PushFollow(Follow._block_in_ebnf1010);
				b=block();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(209, 17);
				if (state.backtracking == 0)
				{
					retval.g = HandleEbnfBlock(blk, (b!=null?((TreeToNFAConverter.block_return)b).g:default(StateCluster)));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\TreeToNFAConverter.g3:210:4: ^( OPTIONAL b= block )
				{
				DebugLocation(210, 4);
				DebugLocation(210, 6);
				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1023); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(210, 16);
				PushFollow(Follow._block_in_ebnf1027);
				b=block();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(210, 26);
				if (state.backtracking == 0)
				{
					retval.g = HandleEbnfOptionalBlock(retval.Start, blk, (b!=null?((TreeToNFAConverter.block_return)b).g:default(StateCluster)));
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\TreeToNFAConverter.g3:211:4: ^( CLOSURE b= block )
				{
				DebugLocation(211, 4);
				DebugLocation(211, 6);
				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1038); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(211, 15);
				PushFollow(Follow._block_in_ebnf1042);
				b=block();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(211, 25);
				if (state.backtracking == 0)
				{
					retval.g = HandleEbnfClosureBlock(retval.Start, blk, (b!=null?((TreeToNFAConverter.block_return)b).g:default(StateCluster)));
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\TreeToNFAConverter.g3:212:4: ^( POSITIVE_CLOSURE b= block )
				{
				DebugLocation(212, 4);
				DebugLocation(212, 6);
				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1053); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(212, 24);
				PushFollow(Follow._block_in_ebnf1057);
				b=block();
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(212, 32);
				if (state.backtracking == 0)
				{
					retval.g = HandleEbnfPositiveClosureBlock(retval.Start, blk, (b!=null?((TreeToNFAConverter.block_return)b).g:default(StateCluster)));
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ebnf", 16);
			LeaveRule("ebnf", 16);
			LeaveRule_ebnf();
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "ebnf"); }
		return retval;

	}
	// $ANTLR end "ebnf"

	private sealed partial class tree__return : TreeRuleReturnScope<GrammarAST>
	{
		public StateCluster g;
		public tree__return(TreeToNFAConverter grammar) {OnCreated(grammar);}
		partial void OnCreated(TreeToNFAConverter grammar);
	}

	partial void EnterRule_tree_();
	partial void LeaveRule_tree_();
	// $ANTLR start "tree_"
	// Grammars\\TreeToNFAConverter.g3:215:1: tree_ returns [StateCluster g] : ^( TREE_BEGIN e= element (e= element )* ) ;
	[GrammarRule("tree_")]
	private TreeToNFAConverter.tree__return tree_()
	{
		EnterRule_tree_();
		EnterRule("tree_", 17);
		TraceIn("tree_", 17);
		TreeToNFAConverter.tree__return retval = new TreeToNFAConverter.tree__return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> e = default(TreeRuleReturnScope<GrammarAST>);


			StateCluster down = null;

		try { DebugEnterRule(GrammarFileName, "tree_");
		DebugLocation(215, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:220:2: ( ^( TREE_BEGIN e= element (e= element )* ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:220:4: ^( TREE_BEGIN e= element (e= element )* )
			{
			DebugLocation(220, 4);
			DebugLocation(220, 7);
			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1082); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(221, 5);
			PushFollow(Follow._element_in_tree_1089);
			e=element();
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(221, 15);
			if (state.backtracking == 0)
			{
				retval.g = HandleTreeFirstElement((e!=null?((GrammarAST)e.Start):default(GrammarAST)), (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster)), out down);
			}
			DebugLocation(222, 4);
			// Grammars\\TreeToNFAConverter.g3:222:4: (e= element )*
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=2;
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==ACTION||(LA45_1>=ASSIGN && LA45_1<=BLOCK)||(LA45_1>=CHAR_LITERAL && LA45_1<=CHAR_RANGE)||LA45_1==CLOSURE||LA45_1==DOT||LA45_1==EPSILON||LA45_1==FORCED_ACTION||LA45_1==GATED_SEMPRED||LA45_1==NOT||LA45_1==OPTIONAL||(LA45_1>=PLUS_ASSIGN && LA45_1<=POSITIVE_CLOSURE)||LA45_1==RANGE||LA45_1==ROOT||LA45_1==RULE_REF||LA45_1==SEMPRED||(LA45_1>=STRING_LITERAL && LA45_1<=SYN_SEMPRED)||LA45_1==TOKEN_REF||LA45_1==TREE_BEGIN||LA45_1==WILDCARD))
				{
					alt45 = 1;
				}


				} finally { DebugExitDecision(45); }
				switch ( alt45 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:222:6: e= element
					{
					DebugLocation(222, 7);
					PushFollow(Follow._element_in_tree_1101);
					e=element();
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(222, 16);
					if (state.backtracking == 0)
					{
						retval.g = HandleTreeElement(retval.g, (e!=null?((TreeToNFAConverter.element_return)e).g:default(StateCluster)));
					}

					}
					break;

				default:
					goto loop45;
				}
			}

			loop45:
				;

			} finally { DebugExitSubRule(45); }

			DebugLocation(224, 8);
			if (state.backtracking == 0)
			{
				retval.g = HandleTreeAfterLastElement(retval.Start, retval.g, (e!=null?((GrammarAST)e.Start):default(GrammarAST)), down);
			}

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tree_", 17);
			LeaveRule("tree_", 17);
			LeaveRule_tree_();
		}
		DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "tree_"); }
		return retval;

	}
	// $ANTLR end "tree_"

	partial void EnterRule_atom_or_notatom();
	partial void LeaveRule_atom_or_notatom();
	// $ANTLR start "atom_or_notatom"
	// Grammars\\TreeToNFAConverter.g3:228:1: atom_or_notatom returns [StateCluster g=null] : ( atom[null] | ^(n= NOT (c= CHAR_LITERAL ( ast_suffix )? |t= TOKEN_REF ( ast_suffix )? | set ) ) );
	[GrammarRule("atom_or_notatom")]
	private StateCluster atom_or_notatom()
	{
		EnterRule_atom_or_notatom();
		EnterRule("atom_or_notatom", 18);
		TraceIn("atom_or_notatom", 18);
		StateCluster g = null;


		GrammarAST n = default(GrammarAST);
		GrammarAST c = default(GrammarAST);
		GrammarAST t = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> atom12 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> set13 = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "atom_or_notatom");
		DebugLocation(228, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:229:2: ( atom[null] | ^(n= NOT (c= CHAR_LITERAL ( ast_suffix )? |t= TOKEN_REF ( ast_suffix )? | set ) ) )
			int alt49=2;
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==CHAR_LITERAL||LA49_1==DOT||LA49_1==RULE_REF||LA49_1==STRING_LITERAL||LA49_1==TOKEN_REF||LA49_1==WILDCARD))
			{
				alt49 = 1;
			}
			else if ((LA49_1==NOT))
			{
				alt49 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return g;}
				NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:229:4: atom[null]
				{
				DebugLocation(229, 4);
				PushFollow(Follow._atom_in_atom_or_notatom1137);
				atom12=atom(null);
				PopFollow();
				if (state.failed) return g;
				DebugLocation(229, 15);
				if (state.backtracking == 0)
				{
					g = (atom12!=null?((TreeToNFAConverter.atom_return)atom12).g:default(StateCluster));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:230:4: ^(n= NOT (c= CHAR_LITERAL ( ast_suffix )? |t= TOKEN_REF ( ast_suffix )? | set ) )
				{
				DebugLocation(230, 4);
				DebugLocation(230, 8);
				n=(GrammarAST)Match(input,NOT,Follow._NOT_in_atom_or_notatom1149); if (state.failed) return g;

				Match(input, TokenTypes.Down, null); if (state.failed) return g;
				DebugLocation(231, 4);
				// Grammars\\TreeToNFAConverter.g3:231:4: (c= CHAR_LITERAL ( ast_suffix )? |t= TOKEN_REF ( ast_suffix )? | set )
				int alt48=3;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				switch (input.LA(1))
				{
				case CHAR_LITERAL:
					{
					alt48 = 1;
					}
					break;
				case TOKEN_REF:
					{
					alt48 = 2;
					}
					break;
				case BLOCK:
					{
					alt48 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return g;}
						NoViableAltException nvae = new NoViableAltException("", 48, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:231:6: c= CHAR_LITERAL ( ast_suffix )?
					{
					DebugLocation(231, 7);
					c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom_or_notatom1158); if (state.failed) return g;
					DebugLocation(231, 21);
					// Grammars\\TreeToNFAConverter.g3:231:21: ( ast_suffix )?
					int alt46=2;
					try { DebugEnterSubRule(46);
					try { DebugEnterDecision(46, false);
					int LA46_1 = input.LA(1);

					if ((LA46_1==BANG||LA46_1==ROOT))
					{
						alt46 = 1;
					}
					} finally { DebugExitDecision(46); }
					switch (alt46)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:231:21: ast_suffix
						{
						DebugLocation(231, 21);
						PushFollow(Follow._ast_suffix_in_atom_or_notatom1160);
						ast_suffix();
						PopFollow();
						if (state.failed) return g;

						}
						break;

					}
					} finally { DebugExitSubRule(46); }

					DebugLocation(231, 34);
					if (state.backtracking == 0)
					{
						g = HandleNotAtomCharLiteral(n, c);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\TreeToNFAConverter.g3:232:6: t= TOKEN_REF ( ast_suffix )?
					{
					DebugLocation(232, 7);
					t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom_or_notatom1173); if (state.failed) return g;
					DebugLocation(232, 18);
					// Grammars\\TreeToNFAConverter.g3:232:18: ( ast_suffix )?
					int alt47=2;
					try { DebugEnterSubRule(47);
					try { DebugEnterDecision(47, false);
					int LA47_1 = input.LA(1);

					if ((LA47_1==BANG||LA47_1==ROOT))
					{
						alt47 = 1;
					}
					} finally { DebugExitDecision(47); }
					switch (alt47)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:232:18: ast_suffix
						{
						DebugLocation(232, 18);
						PushFollow(Follow._ast_suffix_in_atom_or_notatom1175);
						ast_suffix();
						PopFollow();
						if (state.failed) return g;

						}
						break;

					}
					} finally { DebugExitSubRule(47); }

					DebugLocation(232, 32);
					if (state.backtracking == 0)
					{
						g = HandleNotAtomTokenReference(n, t);
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\TreeToNFAConverter.g3:233:6: set
					{
					DebugLocation(233, 6);
					PushFollow(Follow._set_in_atom_or_notatom1187);
					set13=set();
					PopFollow();
					if (state.failed) return g;
					DebugLocation(233, 17);
					if (state.backtracking == 0)
					{
						g = HandleNotAtomSet(n, (set13!=null?((GrammarAST)set13.Start):default(GrammarAST)));
					}

					}
					break;

				}
				} finally { DebugExitSubRule(48); }

				DebugLocation(235, 4);
				if (state.backtracking == 0)
				{
					HandleNotAtomEnd(n, g);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return g;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom_or_notatom", 18);
			LeaveRule("atom_or_notatom", 18);
			LeaveRule_atom_or_notatom();
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "atom_or_notatom"); }
		return g;

	}
	// $ANTLR end "atom_or_notatom"

	private sealed partial class atom_return : TreeRuleReturnScope<GrammarAST>
	{
		public StateCluster g;
		public atom_return(TreeToNFAConverter grammar) {OnCreated(grammar);}
		partial void OnCreated(TreeToNFAConverter grammar);
	}

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\TreeToNFAConverter.g3:239:1: atom[string scopeName] returns [StateCluster g] : ( ^(r= RULE_REF ( ARG_ACTION )? ( ast_suffix )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ( ast_suffix )? ) | ^(c= CHAR_LITERAL ( ast_suffix )? ) | ^(s= STRING_LITERAL ( ast_suffix )? ) | ^(w= WILDCARD ( ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) );
	[GrammarRule("atom")]
	private TreeToNFAConverter.atom_return atom(string scopeName)
	{
		EnterRule_atom();
		EnterRule("atom", 19);
		TraceIn("atom", 19);
		TreeToNFAConverter.atom_return retval = new TreeToNFAConverter.atom_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST r = default(GrammarAST);
		GrammarAST t = default(GrammarAST);
		GrammarAST c = default(GrammarAST);
		GrammarAST s = default(GrammarAST);
		GrammarAST w = default(GrammarAST);
		GrammarAST scope_ = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> a = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(239, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:240:2: ( ^(r= RULE_REF ( ARG_ACTION )? ( ast_suffix )? ) | ^(t= TOKEN_REF ( ARG_ACTION )? ( ast_suffix )? ) | ^(c= CHAR_LITERAL ( ast_suffix )? ) | ^(s= STRING_LITERAL ( ast_suffix )? ) | ^(w= WILDCARD ( ast_suffix )? ) | ^( DOT scope_= ID a= atom[$scope_.text] ) )
			int alt57=6;
			try { DebugEnterDecision(57, false);
			switch (input.LA(1))
			{
			case RULE_REF:
				{
				alt57 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt57 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt57 = 3;
				}
				break;
			case STRING_LITERAL:
				{
				alt57 = 4;
				}
				break;
			case WILDCARD:
				{
				alt57 = 5;
				}
				break;
			case DOT:
				{
				alt57 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:240:4: ^(r= RULE_REF ( ARG_ACTION )? ( ast_suffix )? )
				{
				DebugLocation(240, 4);
				DebugLocation(240, 7);
				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1229); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(240, 17);
					// Grammars\\TreeToNFAConverter.g3:240:17: ( ARG_ACTION )?
					int alt50=2;
					try { DebugEnterSubRule(50);
					try { DebugEnterDecision(50, false);
					int LA50_1 = input.LA(1);

					if ((LA50_1==ARG_ACTION))
					{
						alt50 = 1;
					}
					} finally { DebugExitDecision(50); }
					switch (alt50)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:240:17: ARG_ACTION
						{
						DebugLocation(240, 17);
						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1231); if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(50); }

					DebugLocation(240, 29);
					// Grammars\\TreeToNFAConverter.g3:240:29: ( ast_suffix )?
					int alt51=2;
					try { DebugEnterSubRule(51);
					try { DebugEnterDecision(51, false);
					int LA51_1 = input.LA(1);

					if ((LA51_1==BANG||LA51_1==ROOT))
					{
						alt51 = 1;
					}
					} finally { DebugExitDecision(51); }
					switch (alt51)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:240:29: ast_suffix
						{
						DebugLocation(240, 29);
						PushFollow(Follow._ast_suffix_in_atom1234);
						ast_suffix();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(51); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(240, 42);
				if (state.backtracking == 0)
				{
					retval.g = HandleAtomRuleReference(scopeName, r);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:241:4: ^(t= TOKEN_REF ( ARG_ACTION )? ( ast_suffix )? )
				{
				DebugLocation(241, 4);
				DebugLocation(241, 7);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1246); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(241, 18);
					// Grammars\\TreeToNFAConverter.g3:241:18: ( ARG_ACTION )?
					int alt52=2;
					try { DebugEnterSubRule(52);
					try { DebugEnterDecision(52, false);
					int LA52_1 = input.LA(1);

					if ((LA52_1==ARG_ACTION))
					{
						alt52 = 1;
					}
					} finally { DebugExitDecision(52); }
					switch (alt52)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:241:18: ARG_ACTION
						{
						DebugLocation(241, 18);
						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1248); if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(52); }

					DebugLocation(241, 30);
					// Grammars\\TreeToNFAConverter.g3:241:30: ( ast_suffix )?
					int alt53=2;
					try { DebugEnterSubRule(53);
					try { DebugEnterDecision(53, false);
					int LA53_1 = input.LA(1);

					if ((LA53_1==BANG||LA53_1==ROOT))
					{
						alt53 = 1;
					}
					} finally { DebugExitDecision(53); }
					switch (alt53)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:241:30: ast_suffix
						{
						DebugLocation(241, 30);
						PushFollow(Follow._ast_suffix_in_atom1251);
						ast_suffix();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(53); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(241, 43);
				if (state.backtracking == 0)
				{
					retval.g = HandleAtomTokenReference(scopeName, t);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\TreeToNFAConverter.g3:242:4: ^(c= CHAR_LITERAL ( ast_suffix )? )
				{
				DebugLocation(242, 4);
				DebugLocation(242, 7);
				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1263); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(242, 21);
					// Grammars\\TreeToNFAConverter.g3:242:21: ( ast_suffix )?
					int alt54=2;
					try { DebugEnterSubRule(54);
					try { DebugEnterDecision(54, false);
					int LA54_1 = input.LA(1);

					if ((LA54_1==BANG||LA54_1==ROOT))
					{
						alt54 = 1;
					}
					} finally { DebugExitDecision(54); }
					switch (alt54)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:242:21: ast_suffix
						{
						DebugLocation(242, 21);
						PushFollow(Follow._ast_suffix_in_atom1265);
						ast_suffix();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(54); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(242, 36);
				if (state.backtracking == 0)
				{
					retval.g = HandleAtomCharLiteral(c);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\TreeToNFAConverter.g3:243:4: ^(s= STRING_LITERAL ( ast_suffix )? )
				{
				DebugLocation(243, 4);
				DebugLocation(243, 7);
				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1279); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(243, 23);
					// Grammars\\TreeToNFAConverter.g3:243:23: ( ast_suffix )?
					int alt55=2;
					try { DebugEnterSubRule(55);
					try { DebugEnterDecision(55, false);
					int LA55_1 = input.LA(1);

					if ((LA55_1==BANG||LA55_1==ROOT))
					{
						alt55 = 1;
					}
					} finally { DebugExitDecision(55); }
					switch (alt55)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:243:23: ast_suffix
						{
						DebugLocation(243, 23);
						PushFollow(Follow._ast_suffix_in_atom1281);
						ast_suffix();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(55); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(243, 38);
				if (state.backtracking == 0)
				{
					retval.g = HandleAtomStringLiteral(s);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\TreeToNFAConverter.g3:244:4: ^(w= WILDCARD ( ast_suffix )? )
				{
				DebugLocation(244, 4);
				DebugLocation(244, 7);
				w=(GrammarAST)Match(input,WILDCARD,Follow._WILDCARD_in_atom1295); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(244, 17);
					// Grammars\\TreeToNFAConverter.g3:244:17: ( ast_suffix )?
					int alt56=2;
					try { DebugEnterSubRule(56);
					try { DebugEnterDecision(56, false);
					int LA56_1 = input.LA(1);

					if ((LA56_1==BANG||LA56_1==ROOT))
					{
						alt56 = 1;
					}
					} finally { DebugExitDecision(56); }
					switch (alt56)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:244:17: ast_suffix
						{
						DebugLocation(244, 17);
						PushFollow(Follow._ast_suffix_in_atom1297);
						ast_suffix();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(56); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(244, 33);
				if (state.backtracking == 0)
				{
					retval.g = HandleAtomWildcard(w);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\TreeToNFAConverter.g3:245:4: ^( DOT scope_= ID a= atom[$scope_.text] )
				{
				DebugLocation(245, 4);
				DebugLocation(245, 6);
				Match(input,DOT,Follow._DOT_in_atom1310); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(245, 16);
				scope_=(GrammarAST)Match(input,ID,Follow._ID_in_atom1314); if (state.failed) return retval;
				DebugLocation(245, 21);
				PushFollow(Follow._atom_in_atom1318);
				a=atom((scope_!=null?scope_.Text:default(string)));
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(245, 42);
				if (state.backtracking == 0)
				{
					retval.g = (a!=null?((TreeToNFAConverter.atom_return)a).g:default(StateCluster));
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 19);
			LeaveRule("atom", 19);
			LeaveRule_atom();
		}
		DebugLocation(246, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_ast_suffix();
	partial void LeaveRule_ast_suffix();
	// $ANTLR start "ast_suffix"
	// Grammars\\TreeToNFAConverter.g3:248:1: ast_suffix : ( ROOT | BANG );
	[GrammarRule("ast_suffix")]
	private void ast_suffix()
	{
		EnterRule_ast_suffix();
		EnterRule("ast_suffix", 20);
		TraceIn("ast_suffix", 20);
		try { DebugEnterRule(GrammarFileName, "ast_suffix");
		DebugLocation(248, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:249:2: ( ROOT | BANG )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:
			{
			DebugLocation(249, 2);
			if (input.LA(1)==BANG||input.LA(1)==ROOT)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ast_suffix", 20);
			LeaveRule("ast_suffix", 20);
			LeaveRule_ast_suffix();
		}
		DebugLocation(251, 1);
		} finally { DebugExitRule(GrammarFileName, "ast_suffix"); }
		return;

	}
	// $ANTLR end "ast_suffix"

	private sealed partial class set_return : TreeRuleReturnScope<GrammarAST>
	{
		public StateCluster g;
		public set_return(TreeToNFAConverter grammar) {OnCreated(grammar);}
		partial void OnCreated(TreeToNFAConverter grammar);
	}

	partial void EnterRule_set();
	partial void LeaveRule_set();
	// $ANTLR start "set"
	// Grammars\\TreeToNFAConverter.g3:253:1: set returns [StateCluster g] : ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) ;
	[GrammarRule("set")]
	private TreeToNFAConverter.set_return set()
	{
		EnterRule_set();
		EnterRule("set", 21);
		TraceIn("set", 21);
		TreeToNFAConverter.set_return retval = new TreeToNFAConverter.set_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST b = default(GrammarAST);


			IIntSet elements=new IntervalSet();
			if ( state.backtracking == 0 )
				retval.Start.SetValue = elements; // track set for use by code gen

		try { DebugEnterRule(GrammarFileName, "set");
		DebugLocation(253, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:260:2: ( ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:260:4: ^(b= BLOCK ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+ EOB )
			{
			DebugLocation(260, 4);
			DebugLocation(260, 8);
			b=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_set1363); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(261, 6);
			// Grammars\\TreeToNFAConverter.g3:261:6: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA ) )+
			int cnt60=0;
			try { DebugEnterSubRule(60);
			while (true)
			{
				int alt60=2;
				try { DebugEnterDecision(60, false);
				int LA60_1 = input.LA(1);

				if ((LA60_1==ALT))
				{
					alt60 = 1;
				}


				} finally { DebugExitDecision(60); }
				switch (alt60)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:261:7: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? setElement[elements] EOA )
					{
					DebugLocation(261, 7);
					DebugLocation(261, 9);
					Match(input,ALT,Follow._ALT_in_set1372); if (state.failed) return retval;

					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(261, 13);
					// Grammars\\TreeToNFAConverter.g3:261:13: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
					int alt59=2;
					try { DebugEnterSubRule(59);
					try { DebugEnterDecision(59, false);
					int LA59_1 = input.LA(1);

					if ((LA59_1==BACKTRACK_SEMPRED))
					{
						alt59 = 1;
					}
					} finally { DebugExitDecision(59); }
					switch (alt59)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:261:15: ^( BACKTRACK_SEMPRED ( . )* )
						{
						DebugLocation(261, 15);
						DebugLocation(261, 17);
						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_set1377); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(261, 35);
							// Grammars\\TreeToNFAConverter.g3:261:35: ( . )*
							try { DebugEnterSubRule(58);
							while (true)
							{
								int alt58=2;
								try { DebugEnterDecision(58, false);
								int LA58_1 = input.LA(1);

								if (((LA58_1>=ACTION && LA58_1<=XDIGIT)))
								{
									alt58 = 1;
								}
								else if ((LA58_1==UP))
								{
									alt58 = 2;
								}


								} finally { DebugExitDecision(58); }
								switch ( alt58 )
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\TreeToNFAConverter.g3:261:35: .
									{
									DebugLocation(261, 35);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop58;
								}
							}

							loop58:
								;

							} finally { DebugExitSubRule(58); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}


						}
						break;

					}
					} finally { DebugExitSubRule(59); }

					DebugLocation(261, 42);
					PushFollow(Follow._setElement_in_set1386);
					setElement(elements);
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(261, 63);
					Match(input,EOA,Follow._EOA_in_set1389); if (state.failed) return retval;

					Match(input, TokenTypes.Up, null); if (state.failed) return retval;


					}
					break;

				default:
					if (cnt60 >= 1)
						goto loop60;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee60 = new EarlyExitException( 60, input );
					DebugRecognitionException(eee60);
					throw eee60;
				}
				cnt60++;
			}
			loop60:
				;

			} finally { DebugExitSubRule(60); }

			DebugLocation(262, 6);
			Match(input,EOB,Follow._EOB_in_set1399); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;

			DebugLocation(264, 3);
			if (state.backtracking == 0)
			{

						retval.g = factory.BuildSet(elements,b);
						b.followingNFAState = retval.g.Right;
						b.SetValue = elements; // track set value of this block
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("set", 21);
			LeaveRule("set", 21);
			LeaveRule_set();
		}
		DebugLocation(270, 1);
		} finally { DebugExitRule(GrammarFileName, "set"); }
		return retval;

	}
	// $ANTLR end "set"

	partial void EnterRule_setRule();
	partial void LeaveRule_setRule();
	// $ANTLR start "setRule"
	// Grammars\\TreeToNFAConverter.g3:272:1: setRule returns [IIntSet elements = new IntervalSet()] : ^( RULE ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
	[GrammarRule("setRule")]
	private IIntSet setRule()
	{
		EnterRule_setRule();
		EnterRule("setRule", 22);
		TraceIn("setRule", 22);
		IIntSet elements =  new IntervalSet();


		try { DebugEnterRule(GrammarFileName, "setRule");
		DebugLocation(272, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:273:2: ( ^( RULE ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:273:4: ^( RULE ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( OPTIONS ( . )* ) )? ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+ EOB ) ( exceptionGroup )? EOR )
			{
			DebugLocation(273, 4);
			DebugLocation(273, 7);
			Match(input,RULE,Follow._RULE_in_setRule1428); if (state.failed) return elements;

			Match(input, TokenTypes.Down, null); if (state.failed) return elements;
			DebugLocation(273, 12);
			Match(input,ID,Follow._ID_in_setRule1430); if (state.failed) return elements;
			DebugLocation(273, 15);
			// Grammars\\TreeToNFAConverter.g3:273:15: ( modifier )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			int LA61_1 = input.LA(1);

			if ((LA61_1==FRAGMENT||(LA61_1>=PRIVATE && LA61_1<=PUBLIC)))
			{
				alt61 = 1;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:273:15: modifier
				{
				DebugLocation(273, 15);
				PushFollow(Follow._modifier_in_setRule1432);
				modifier();
				PopFollow();
				if (state.failed) return elements;

				}
				break;

			}
			} finally { DebugExitSubRule(61); }

			DebugLocation(273, 25);
			Match(input,ARG,Follow._ARG_in_setRule1435); if (state.failed) return elements;
			DebugLocation(273, 29);
			Match(input,RET,Follow._RET_in_setRule1437); if (state.failed) return elements;
			DebugLocation(273, 33);
			// Grammars\\TreeToNFAConverter.g3:273:33: ( ^( OPTIONS ( . )* ) )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			int LA63_1 = input.LA(1);

			if ((LA63_1==OPTIONS))
			{
				alt63 = 1;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:273:35: ^( OPTIONS ( . )* )
				{
				DebugLocation(273, 35);
				DebugLocation(273, 37);
				Match(input,OPTIONS,Follow._OPTIONS_in_setRule1442); if (state.failed) return elements;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return elements;
					DebugLocation(273, 45);
					// Grammars\\TreeToNFAConverter.g3:273:45: ( . )*
					try { DebugEnterSubRule(62);
					while (true)
					{
						int alt62=2;
						try { DebugEnterDecision(62, false);
						int LA62_1 = input.LA(1);

						if (((LA62_1>=ACTION && LA62_1<=XDIGIT)))
						{
							alt62 = 1;
						}
						else if ((LA62_1==UP))
						{
							alt62 = 2;
						}


						} finally { DebugExitDecision(62); }
						switch ( alt62 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:273:45: .
							{
							DebugLocation(273, 45);
							MatchAny(input); if (state.failed) return elements;

							}
							break;

						default:
							goto loop62;
						}
					}

					loop62:
						;

					} finally { DebugExitSubRule(62); }


					Match(input, TokenTypes.Up, null); if (state.failed) return elements;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(273, 52);
			// Grammars\\TreeToNFAConverter.g3:273:52: ( ruleScopeSpec )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_1 = input.LA(1);

			if ((LA64_1==SCOPE))
			{
				alt64 = 1;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:273:52: ruleScopeSpec
				{
				DebugLocation(273, 52);
				PushFollow(Follow._ruleScopeSpec_in_setRule1451);
				ruleScopeSpec();
				PopFollow();
				if (state.failed) return elements;

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(274, 4);
			// Grammars\\TreeToNFAConverter.g3:274:4: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(66);
			while (true)
			{
				int alt66=2;
				try { DebugEnterDecision(66, false);
				int LA66_1 = input.LA(1);

				if ((LA66_1==AMPERSAND))
				{
					alt66 = 1;
				}


				} finally { DebugExitDecision(66); }
				switch ( alt66 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:274:6: ^( AMPERSAND ( . )* )
					{
					DebugLocation(274, 6);
					DebugLocation(274, 8);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_setRule1460); if (state.failed) return elements;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return elements;
						DebugLocation(274, 18);
						// Grammars\\TreeToNFAConverter.g3:274:18: ( . )*
						try { DebugEnterSubRule(65);
						while (true)
						{
							int alt65=2;
							try { DebugEnterDecision(65, false);
							int LA65_1 = input.LA(1);

							if (((LA65_1>=ACTION && LA65_1<=XDIGIT)))
							{
								alt65 = 1;
							}
							else if ((LA65_1==UP))
							{
								alt65 = 2;
							}


							} finally { DebugExitDecision(65); }
							switch ( alt65 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:274:18: .
								{
								DebugLocation(274, 18);
								MatchAny(input); if (state.failed) return elements;

								}
								break;

							default:
								goto loop65;
							}
						}

						loop65:
							;

						} finally { DebugExitSubRule(65); }


						Match(input, TokenTypes.Up, null); if (state.failed) return elements;
					}


					}
					break;

				default:
					goto loop66;
				}
			}

			loop66:
				;

			} finally { DebugExitSubRule(66); }

			DebugLocation(275, 4);
			DebugLocation(275, 7);
			Match(input,BLOCK,Follow._BLOCK_in_setRule1474); if (state.failed) return elements;

			Match(input, TokenTypes.Down, null); if (state.failed) return elements;
			DebugLocation(275, 13);
			// Grammars\\TreeToNFAConverter.g3:275:13: ( ^( OPTIONS ( . )* ) )?
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_1 = input.LA(1);

			if ((LA68_1==OPTIONS))
			{
				alt68 = 1;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:275:15: ^( OPTIONS ( . )* )
				{
				DebugLocation(275, 15);
				DebugLocation(275, 17);
				Match(input,OPTIONS,Follow._OPTIONS_in_setRule1479); if (state.failed) return elements;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return elements;
					DebugLocation(275, 25);
					// Grammars\\TreeToNFAConverter.g3:275:25: ( . )*
					try { DebugEnterSubRule(67);
					while (true)
					{
						int alt67=2;
						try { DebugEnterDecision(67, false);
						int LA67_1 = input.LA(1);

						if (((LA67_1>=ACTION && LA67_1<=XDIGIT)))
						{
							alt67 = 1;
						}
						else if ((LA67_1==UP))
						{
							alt67 = 2;
						}


						} finally { DebugExitDecision(67); }
						switch ( alt67 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:275:25: .
							{
							DebugLocation(275, 25);
							MatchAny(input); if (state.failed) return elements;

							}
							break;

						default:
							goto loop67;
						}
					}

					loop67:
						;

					} finally { DebugExitSubRule(67); }


					Match(input, TokenTypes.Up, null); if (state.failed) return elements;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(68); }

			DebugLocation(276, 5);
			// Grammars\\TreeToNFAConverter.g3:276:5: ( ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA ) )+
			int cnt70=0;
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==ALT))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch (alt70)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:276:7: ^( ALT ( BACKTRACK_SEMPRED )? setElement[elements] EOA )
					{
					DebugLocation(276, 7);
					DebugLocation(276, 9);
					Match(input,ALT,Follow._ALT_in_setRule1495); if (state.failed) return elements;

					Match(input, TokenTypes.Down, null); if (state.failed) return elements;
					DebugLocation(276, 13);
					// Grammars\\TreeToNFAConverter.g3:276:13: ( BACKTRACK_SEMPRED )?
					int alt69=2;
					try { DebugEnterSubRule(69);
					try { DebugEnterDecision(69, false);
					int LA69_1 = input.LA(1);

					if ((LA69_1==BACKTRACK_SEMPRED))
					{
						alt69 = 1;
					}
					} finally { DebugExitDecision(69); }
					switch (alt69)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:276:13: BACKTRACK_SEMPRED
						{
						DebugLocation(276, 13);
						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_setRule1497); if (state.failed) return elements;

						}
						break;

					}
					} finally { DebugExitSubRule(69); }

					DebugLocation(276, 32);
					PushFollow(Follow._setElement_in_setRule1500);
					setElement(elements);
					PopFollow();
					if (state.failed) return elements;
					DebugLocation(276, 53);
					Match(input,EOA,Follow._EOA_in_setRule1503); if (state.failed) return elements;

					Match(input, TokenTypes.Up, null); if (state.failed) return elements;


					}
					break;

				default:
					if (cnt70 >= 1)
						goto loop70;

					if (state.backtracking>0) {state.failed=true; return elements;}
					EarlyExitException eee70 = new EarlyExitException( 70, input );
					DebugRecognitionException(eee70);
					throw eee70;
				}
				cnt70++;
			}
			loop70:
				;

			} finally { DebugExitSubRule(70); }

			DebugLocation(277, 5);
			Match(input,EOB,Follow._EOB_in_setRule1513); if (state.failed) return elements;

			Match(input, TokenTypes.Up, null); if (state.failed) return elements;

			DebugLocation(279, 4);
			// Grammars\\TreeToNFAConverter.g3:279:4: ( exceptionGroup )?
			int alt71=2;
			try { DebugEnterSubRule(71);
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==CATCH||LA71_1==FINALLY))
			{
				alt71 = 1;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:279:4: exceptionGroup
				{
				DebugLocation(279, 4);
				PushFollow(Follow._exceptionGroup_in_setRule1524);
				exceptionGroup();
				PopFollow();
				if (state.failed) return elements;

				}
				break;

			}
			} finally { DebugExitSubRule(71); }

			DebugLocation(280, 4);
			Match(input,EOR,Follow._EOR_in_setRule1530); if (state.failed) return elements;

			Match(input, TokenTypes.Up, null); if (state.failed) return elements;


			}

		}
		catch (RecognitionException re)
		{
			 re.PreserveStackTrace(); throw; 
		}

		finally
		{
			TraceOut("setRule", 22);
			LeaveRule("setRule", 22);
			LeaveRule_setRule();
		}
		DebugLocation(282, 1);
		} finally { DebugExitRule(GrammarFileName, "setRule"); }
		return elements;

	}
	// $ANTLR end "setRule"

	partial void EnterRule_setElement();
	partial void LeaveRule_setElement();
	// $ANTLR start "setElement"
	// Grammars\\TreeToNFAConverter.g3:285:1: setElement[IIntSet elements] : (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) );
	[GrammarRule("setElement")]
	private void setElement(IIntSet elements)
	{
		EnterRule_setElement();
		EnterRule("setElement", 23);
		TraceIn("setElement", 23);
		GrammarAST c = default(GrammarAST);
		GrammarAST t = default(GrammarAST);
		GrammarAST s = default(GrammarAST);
		GrammarAST c1 = default(GrammarAST);
		GrammarAST c2 = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> gset = default(TreeRuleReturnScope<GrammarAST>);


			IIntSet ns = null;

		try { DebugEnterRule(GrammarFileName, "setElement");
		DebugLocation(285, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:290:2: (c= CHAR_LITERAL |t= TOKEN_REF |s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) |gset= set | ^( NOT setElement[ns] ) )
			int alt72=6;
			try { DebugEnterDecision(72, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				alt72 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt72 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				alt72 = 3;
				}
				break;
			case CHAR_RANGE:
				{
				alt72 = 4;
				}
				break;
			case BLOCK:
				{
				alt72 = 5;
				}
				break;
			case NOT:
				{
				alt72 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 72, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(72); }
			switch (alt72)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:290:4: c= CHAR_LITERAL
				{
				DebugLocation(290, 5);
				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1559); if (state.failed) return;
				DebugLocation(290, 27);
				if (state.backtracking == 0)
				{
					HandleSetElementCharLiteral(elements, c);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:291:4: t= TOKEN_REF
				{
				DebugLocation(291, 5);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_setElement1576); if (state.failed) return;
				DebugLocation(291, 25);
				if (state.backtracking == 0)
				{
					HandleSetElementTokenReference(elements, t);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\TreeToNFAConverter.g3:292:4: s= STRING_LITERAL
				{
				DebugLocation(292, 5);
				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_setElement1594); if (state.failed) return;
				DebugLocation(292, 28);
				if (state.backtracking == 0)
				{
					HandleSetElementStringLiteral(elements, s);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\TreeToNFAConverter.g3:293:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
				{
				DebugLocation(293, 4);
				DebugLocation(293, 6);
				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_setElement1609); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(293, 19);
				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1613); if (state.failed) return;
				DebugLocation(293, 35);
				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1617); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;

				DebugLocation(293, 50);
				if (state.backtracking == 0)
				{
					HandleSetElementCharRange(elements, c1, c2);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\TreeToNFAConverter.g3:294:4: gset= set
				{
				DebugLocation(294, 8);
				PushFollow(Follow._set_in_setElement1627);
				gset=set();
				PopFollow();
				if (state.failed) return;
				DebugLocation(294, 22);
				if (state.backtracking == 0)
				{
					HandleSetElementSet(elements, (gset!=null?((TreeToNFAConverter.set_return)gset).g:default(StateCluster)));
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\TreeToNFAConverter.g3:295:4: ^( NOT setElement[ns] )
				{
				DebugLocation(295, 4);
				DebugLocation(295, 7);
				Match(input,NOT,Follow._NOT_in_setElement1645); if (state.failed) return;

				DebugLocation(295, 21);
				if (state.backtracking == 0)
				{
					ns=new IntervalSet();
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(296, 4);
				PushFollow(Follow._setElement_in_setElement1662);
				setElement(ns);
				PopFollow();
				if (state.failed) return;
				DebugLocation(296, 26);
				if (state.backtracking == 0)
				{
					HandleSetElementNotSetElement(elements, ns);
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("setElement", 23);
			LeaveRule("setElement", 23);
			LeaveRule_setElement();
		}
		DebugLocation(298, 1);
		} finally { DebugExitRule(GrammarFileName, "setElement"); }
		return;

	}
	// $ANTLR end "setElement"

	partial void EnterRule_testBlockAsSet();
	partial void LeaveRule_testBlockAsSet();
	// $ANTLR start "testBlockAsSet"
	// Grammars\\TreeToNFAConverter.g3:307:1: testBlockAsSet returns [int alts=0] options {backtrack=true; } : ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ;
	[GrammarRule("testBlockAsSet")]
	private int testBlockAsSet()
	{
		EnterRule_testBlockAsSet();
		EnterRule("testBlockAsSet", 24);
		TraceIn("testBlockAsSet", 24);
		int alts = 0;


		int testSetElement14 = default(int);


			inTest++;

		try { DebugEnterRule(GrammarFileName, "testBlockAsSet");
		DebugLocation(307, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:313:2: ( ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:313:4: ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB )
			{
			DebugLocation(313, 4);
			DebugLocation(313, 7);
			Match(input,BLOCK,Follow._BLOCK_in_testBlockAsSet1711); if (state.failed) return alts;

			Match(input, TokenTypes.Down, null); if (state.failed) return alts;
			DebugLocation(314, 4);
			// Grammars\\TreeToNFAConverter.g3:314:4: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
			int cnt74=0;
			try { DebugEnterSubRule(74);
			while (true)
			{
				int alt74=2;
				try { DebugEnterDecision(74, false);
				int LA74_1 = input.LA(1);

				if ((LA74_1==ALT))
				{
					alt74 = 1;
				}


				} finally { DebugExitDecision(74); }
				switch (alt74)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:314:6: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
					{
					DebugLocation(314, 6);
					DebugLocation(314, 8);
					Match(input,ALT,Follow._ALT_in_testBlockAsSet1719); if (state.failed) return alts;

					Match(input, TokenTypes.Down, null); if (state.failed) return alts;
					DebugLocation(314, 12);
					// Grammars\\TreeToNFAConverter.g3:314:12: ( BACKTRACK_SEMPRED )?
					int alt73=2;
					try { DebugEnterSubRule(73);
					try { DebugEnterDecision(73, false);
					int LA73_1 = input.LA(1);

					if ((LA73_1==BACKTRACK_SEMPRED))
					{
						alt73 = 1;
					}
					} finally { DebugExitDecision(73); }
					switch (alt73)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:314:12: BACKTRACK_SEMPRED
						{
						DebugLocation(314, 12);
						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_testBlockAsSet1721); if (state.failed) return alts;

						}
						break;

					}
					} finally { DebugExitSubRule(73); }

					DebugLocation(314, 31);
					PushFollow(Follow._testSetElement_in_testBlockAsSet1724);
					testSetElement14=testSetElement();
					PopFollow();
					if (state.failed) return alts;
					DebugLocation(314, 46);
					alts += testSetElement14;
					DebugLocation(314, 81);
					Match(input,EOA,Follow._EOA_in_testBlockAsSet1728); if (state.failed) return alts;

					Match(input, TokenTypes.Up, null); if (state.failed) return alts;


					}
					break;

				default:
					if (cnt74 >= 1)
						goto loop74;

					if (state.backtracking>0) {state.failed=true; return alts;}
					EarlyExitException eee74 = new EarlyExitException( 74, input );
					DebugRecognitionException(eee74);
					throw eee74;
				}
				cnt74++;
			}
			loop74:
				;

			} finally { DebugExitSubRule(74); }

			DebugLocation(316, 4);
			Match(input,EOB,Follow._EOB_in_testBlockAsSet1740); if (state.failed) return alts;

			Match(input, TokenTypes.Up, null); if (state.failed) return alts;


			}

		}
		catch (RecognitionException re)
		{
			 re.PreserveStackTrace(); throw; 
		}

		finally
		{
			TraceOut("testBlockAsSet", 24);
			LeaveRule("testBlockAsSet", 24);
			LeaveRule_testBlockAsSet();
			 inTest--; 
		}
		DebugLocation(318, 1);
		} finally { DebugExitRule(GrammarFileName, "testBlockAsSet"); }
		return alts;

	}
	// $ANTLR end "testBlockAsSet"

	partial void EnterRule_testSetRule();
	partial void LeaveRule_testSetRule();
	// $ANTLR start "testSetRule"
	// Grammars\\TreeToNFAConverter.g3:322:1: testSetRule returns [int alts=0] : ^( RULE ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) ;
	[GrammarRule("testSetRule")]
	private int testSetRule()
	{
		EnterRule_testSetRule();
		EnterRule("testSetRule", 25);
		TraceIn("testSetRule", 25);
		int alts = 0;


		int testSetElement15 = default(int);


			inTest++;

		try { DebugEnterRule(GrammarFileName, "testSetRule");
		DebugLocation(322, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:327:2: ( ^( RULE ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR ) )
			DebugEnterAlt(1);
			// Grammars\\TreeToNFAConverter.g3:327:4: ^( RULE ID ( modifier )? ARG RET ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ^( BLOCK ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+ EOB ) ( exceptionGroup )? EOR )
			{
			DebugLocation(327, 4);
			DebugLocation(327, 7);
			Match(input,RULE,Follow._RULE_in_testSetRule1775); if (state.failed) return alts;

			Match(input, TokenTypes.Down, null); if (state.failed) return alts;
			DebugLocation(327, 12);
			Match(input,ID,Follow._ID_in_testSetRule1777); if (state.failed) return alts;
			DebugLocation(327, 15);
			// Grammars\\TreeToNFAConverter.g3:327:15: ( modifier )?
			int alt75=2;
			try { DebugEnterSubRule(75);
			try { DebugEnterDecision(75, false);
			int LA75_1 = input.LA(1);

			if ((LA75_1==FRAGMENT||(LA75_1>=PRIVATE && LA75_1<=PUBLIC)))
			{
				alt75 = 1;
			}
			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:327:15: modifier
				{
				DebugLocation(327, 15);
				PushFollow(Follow._modifier_in_testSetRule1779);
				modifier();
				PopFollow();
				if (state.failed) return alts;

				}
				break;

			}
			} finally { DebugExitSubRule(75); }

			DebugLocation(327, 25);
			Match(input,ARG,Follow._ARG_in_testSetRule1782); if (state.failed) return alts;
			DebugLocation(327, 29);
			Match(input,RET,Follow._RET_in_testSetRule1784); if (state.failed) return alts;
			DebugLocation(327, 33);
			// Grammars\\TreeToNFAConverter.g3:327:33: ( ^( OPTIONS ( . )* ) )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_1 = input.LA(1);

			if ((LA77_1==OPTIONS))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:327:35: ^( OPTIONS ( . )* )
				{
				DebugLocation(327, 35);
				DebugLocation(327, 37);
				Match(input,OPTIONS,Follow._OPTIONS_in_testSetRule1789); if (state.failed) return alts;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return alts;
					DebugLocation(327, 45);
					// Grammars\\TreeToNFAConverter.g3:327:45: ( . )*
					try { DebugEnterSubRule(76);
					while (true)
					{
						int alt76=2;
						try { DebugEnterDecision(76, false);
						int LA76_1 = input.LA(1);

						if (((LA76_1>=ACTION && LA76_1<=XDIGIT)))
						{
							alt76 = 1;
						}
						else if ((LA76_1==UP))
						{
							alt76 = 2;
						}


						} finally { DebugExitDecision(76); }
						switch ( alt76 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\TreeToNFAConverter.g3:327:45: .
							{
							DebugLocation(327, 45);
							MatchAny(input); if (state.failed) return alts;

							}
							break;

						default:
							goto loop76;
						}
					}

					loop76:
						;

					} finally { DebugExitSubRule(76); }


					Match(input, TokenTypes.Up, null); if (state.failed) return alts;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(77); }

			DebugLocation(327, 52);
			// Grammars\\TreeToNFAConverter.g3:327:52: ( ruleScopeSpec )?
			int alt78=2;
			try { DebugEnterSubRule(78);
			try { DebugEnterDecision(78, false);
			int LA78_1 = input.LA(1);

			if ((LA78_1==SCOPE))
			{
				alt78 = 1;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:327:52: ruleScopeSpec
				{
				DebugLocation(327, 52);
				PushFollow(Follow._ruleScopeSpec_in_testSetRule1798);
				ruleScopeSpec();
				PopFollow();
				if (state.failed) return alts;

				}
				break;

			}
			} finally { DebugExitSubRule(78); }

			DebugLocation(328, 4);
			// Grammars\\TreeToNFAConverter.g3:328:4: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(80);
			while (true)
			{
				int alt80=2;
				try { DebugEnterDecision(80, false);
				int LA80_1 = input.LA(1);

				if ((LA80_1==AMPERSAND))
				{
					alt80 = 1;
				}


				} finally { DebugExitDecision(80); }
				switch ( alt80 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:328:6: ^( AMPERSAND ( . )* )
					{
					DebugLocation(328, 6);
					DebugLocation(328, 8);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_testSetRule1807); if (state.failed) return alts;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return alts;
						DebugLocation(328, 18);
						// Grammars\\TreeToNFAConverter.g3:328:18: ( . )*
						try { DebugEnterSubRule(79);
						while (true)
						{
							int alt79=2;
							try { DebugEnterDecision(79, false);
							int LA79_1 = input.LA(1);

							if (((LA79_1>=ACTION && LA79_1<=XDIGIT)))
							{
								alt79 = 1;
							}
							else if ((LA79_1==UP))
							{
								alt79 = 2;
							}


							} finally { DebugExitDecision(79); }
							switch ( alt79 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\TreeToNFAConverter.g3:328:18: .
								{
								DebugLocation(328, 18);
								MatchAny(input); if (state.failed) return alts;

								}
								break;

							default:
								goto loop79;
							}
						}

						loop79:
							;

						} finally { DebugExitSubRule(79); }


						Match(input, TokenTypes.Up, null); if (state.failed) return alts;
					}


					}
					break;

				default:
					goto loop80;
				}
			}

			loop80:
				;

			} finally { DebugExitSubRule(80); }

			DebugLocation(329, 4);
			DebugLocation(329, 7);
			Match(input,BLOCK,Follow._BLOCK_in_testSetRule1821); if (state.failed) return alts;

			Match(input, TokenTypes.Down, null); if (state.failed) return alts;
			DebugLocation(330, 5);
			// Grammars\\TreeToNFAConverter.g3:330:5: ( ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA ) )+
			int cnt82=0;
			try { DebugEnterSubRule(82);
			while (true)
			{
				int alt82=2;
				try { DebugEnterDecision(82, false);
				int LA82_1 = input.LA(1);

				if ((LA82_1==ALT))
				{
					alt82 = 1;
				}


				} finally { DebugExitDecision(82); }
				switch (alt82)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\TreeToNFAConverter.g3:330:7: ^( ALT ( BACKTRACK_SEMPRED )? testSetElement EOA )
					{
					DebugLocation(330, 7);
					DebugLocation(330, 9);
					Match(input,ALT,Follow._ALT_in_testSetRule1830); if (state.failed) return alts;

					Match(input, TokenTypes.Down, null); if (state.failed) return alts;
					DebugLocation(330, 13);
					// Grammars\\TreeToNFAConverter.g3:330:13: ( BACKTRACK_SEMPRED )?
					int alt81=2;
					try { DebugEnterSubRule(81);
					try { DebugEnterDecision(81, false);
					int LA81_1 = input.LA(1);

					if ((LA81_1==BACKTRACK_SEMPRED))
					{
						alt81 = 1;
					}
					} finally { DebugExitDecision(81); }
					switch (alt81)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\TreeToNFAConverter.g3:330:13: BACKTRACK_SEMPRED
						{
						DebugLocation(330, 13);
						Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_testSetRule1832); if (state.failed) return alts;

						}
						break;

					}
					} finally { DebugExitSubRule(81); }

					DebugLocation(330, 32);
					PushFollow(Follow._testSetElement_in_testSetRule1835);
					testSetElement15=testSetElement();
					PopFollow();
					if (state.failed) return alts;
					DebugLocation(330, 47);
					alts += testSetElement15;
					DebugLocation(330, 82);
					Match(input,EOA,Follow._EOA_in_testSetRule1839); if (state.failed) return alts;

					Match(input, TokenTypes.Up, null); if (state.failed) return alts;


					}
					break;

				default:
					if (cnt82 >= 1)
						goto loop82;

					if (state.backtracking>0) {state.failed=true; return alts;}
					EarlyExitException eee82 = new EarlyExitException( 82, input );
					DebugRecognitionException(eee82);
					throw eee82;
				}
				cnt82++;
			}
			loop82:
				;

			} finally { DebugExitSubRule(82); }

			DebugLocation(332, 5);
			Match(input,EOB,Follow._EOB_in_testSetRule1853); if (state.failed) return alts;

			Match(input, TokenTypes.Up, null); if (state.failed) return alts;

			DebugLocation(334, 4);
			// Grammars\\TreeToNFAConverter.g3:334:4: ( exceptionGroup )?
			int alt83=2;
			try { DebugEnterSubRule(83);
			try { DebugEnterDecision(83, false);
			int LA83_1 = input.LA(1);

			if ((LA83_1==CATCH||LA83_1==FINALLY))
			{
				alt83 = 1;
			}
			} finally { DebugExitDecision(83); }
			switch (alt83)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:334:4: exceptionGroup
				{
				DebugLocation(334, 4);
				PushFollow(Follow._exceptionGroup_in_testSetRule1863);
				exceptionGroup();
				PopFollow();
				if (state.failed) return alts;

				}
				break;

			}
			} finally { DebugExitSubRule(83); }

			DebugLocation(335, 4);
			Match(input,EOR,Follow._EOR_in_testSetRule1869); if (state.failed) return alts;

			Match(input, TokenTypes.Up, null); if (state.failed) return alts;


			}

		}
		catch (RecognitionException re)
		{
			 re.PreserveStackTrace(); throw; 
		}

		finally
		{
			TraceOut("testSetRule", 25);
			LeaveRule("testSetRule", 25);
			LeaveRule_testSetRule();
			 inTest--; 
		}
		DebugLocation(337, 1);
		} finally { DebugExitRule(GrammarFileName, "testSetRule"); }
		return alts;

	}
	// $ANTLR end "testSetRule"

	partial void EnterRule_testSetElement();
	partial void LeaveRule_testSetElement();
	// $ANTLR start "testSetElement"
	// Grammars\\TreeToNFAConverter.g3:342:1: testSetElement returns [int alts=1] : (c= CHAR_LITERAL {...}?|t= TOKEN_REF {...}?|{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) );
	[GrammarRule("testSetElement")]
	private int testSetElement()
	{
		EnterRule_testSetElement();
		EnterRule("testSetElement", 26);
		TraceIn("testSetElement", 26);
		int alts = 1;


		GrammarAST c = default(GrammarAST);
		GrammarAST t = default(GrammarAST);
		GrammarAST s = default(GrammarAST);
		GrammarAST c1 = default(GrammarAST);
		GrammarAST c2 = default(GrammarAST);
		int tse = default(int);
		int testBlockAsSet16 = default(int);

		try { DebugEnterRule(GrammarFileName, "testSetElement");
		DebugLocation(342, 1);
		try
		{
			// Grammars\\TreeToNFAConverter.g3:343:2: (c= CHAR_LITERAL {...}?|t= TOKEN_REF {...}?|{...}? =>s= STRING_LITERAL | ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL ) | testBlockAsSet | ^( NOT tse= testSetElement ) )
			int alt84=6;
			try { DebugEnterDecision(84, false);
			int LA84_1 = input.LA(1);

			if ((LA84_1==CHAR_LITERAL))
			{
				alt84 = 1;
			}
			else if ((LA84_1==TOKEN_REF))
			{
				alt84 = 2;
			}
			else if ((LA84_1==STRING_LITERAL) && ((grammar.type!=GrammarType.Lexer)))
			{
				alt84 = 3;
			}
			else if ((LA84_1==CHAR_RANGE))
			{
				alt84 = 4;
			}
			else if ((LA84_1==BLOCK))
			{
				alt84 = 5;
			}
			else if ((LA84_1==NOT))
			{
				alt84 = 6;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return alts;}
				NoViableAltException nvae = new NoViableAltException("", 84, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(84); }
			switch (alt84)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\TreeToNFAConverter.g3:343:4: c= CHAR_LITERAL {...}?
				{
				DebugLocation(343, 5);
				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1901); if (state.failed) return alts;
				DebugLocation(343, 19);
				if (!((!HasElementOptions(c))))
				{
					if (state.backtracking>0) {state.failed=true; return alts;}
					throw new FailedPredicateException(input, "testSetElement", "!HasElementOptions($c)");
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\TreeToNFAConverter.g3:344:4: t= TOKEN_REF {...}?
				{
				DebugLocation(344, 5);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_testSetElement1910); if (state.failed) return alts;
				DebugLocation(344, 16);
				if (!((!HasElementOptions(t))))
				{
					if (state.backtracking>0) {state.failed=true; return alts;}
					throw new FailedPredicateException(input, "testSetElement", "!HasElementOptions($t)");
				}
				DebugLocation(345, 3);

							if ( grammar.type==GrammarType.Lexer )
							{
								Rule rule = grammar.GetRule((t!=null?t.Text:default(string)));
								if ( rule==null )
								{
									//throw new RecognitionException("invalid rule");
									throw new RecognitionException();
								}
								// recursively will invoke this rule to match elements in target rule ref
								alts += TestSetRule(rule.Tree);
							}
						

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\TreeToNFAConverter.g3:358:6: {...}? =>s= STRING_LITERAL
				{
				DebugLocation(358, 6);
				if (!((grammar.type!=GrammarType.Lexer)))
				{
					if (state.backtracking>0) {state.failed=true; return alts;}
					throw new FailedPredicateException(input, "testSetElement", "grammar.type!=GrammarType.Lexer");
				}
				DebugLocation(358, 45);
				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_testSetElement1929); if (state.failed) return alts;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\TreeToNFAConverter.g3:359:4: ^( CHAR_RANGE c1= CHAR_LITERAL c2= CHAR_LITERAL )
				{
				DebugLocation(359, 4);
				DebugLocation(359, 6);
				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_testSetElement1935); if (state.failed) return alts;

				Match(input, TokenTypes.Down, null); if (state.failed) return alts;
				DebugLocation(359, 19);
				c1=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1939); if (state.failed) return alts;
				DebugLocation(359, 35);
				c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1943); if (state.failed) return alts;

				Match(input, TokenTypes.Up, null); if (state.failed) return alts;

				DebugLocation(360, 3);
				 alts = IntervalSet.Of( Grammar.GetCharValueFromGrammarCharLiteral((c1!=null?c1.Text:default(string))), Grammar.GetCharValueFromGrammarCharLiteral((c2!=null?c2.Text:default(string))) ).Count; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\TreeToNFAConverter.g3:361:6: testBlockAsSet
				{
				DebugLocation(361, 6);
				PushFollow(Follow._testBlockAsSet_in_testSetElement1955);
				testBlockAsSet16=testBlockAsSet();
				PopFollow();
				if (state.failed) return alts;
				DebugLocation(362, 3);
				 alts = testBlockAsSet16; 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\TreeToNFAConverter.g3:363:6: ^( NOT tse= testSetElement )
				{
				DebugLocation(363, 6);
				DebugLocation(363, 9);
				Match(input,NOT,Follow._NOT_in_testSetElement1968); if (state.failed) return alts;

				Match(input, TokenTypes.Down, null); if (state.failed) return alts;
				DebugLocation(363, 16);
				PushFollow(Follow._testSetElement_in_testSetElement1972);
				tse=testSetElement();
				PopFollow();
				if (state.failed) return alts;

				Match(input, TokenTypes.Up, null); if (state.failed) return alts;

				DebugLocation(364, 3);
				 alts = grammar.TokenTypes.Length - tse; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			 re.PreserveStackTrace(); throw; 
		}

		finally
		{
			TraceOut("testSetElement", 26);
			LeaveRule("testSetElement", 26);
			LeaveRule_testSetElement();
		}
		DebugLocation(365, 1);
		} finally { DebugExitRule(GrammarFileName, "testSetElement"); }
		return alts;

	}
	// $ANTLR end "testSetElement"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_70 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_72 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_80 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_82 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_GRAMMAR_in_grammar_90 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_92 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_100 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_102 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SCOPE_in_attrScope119 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_attrScope121 = new BitSet(new ulong[]{0x210UL});
		public static readonly BitSet _AMPERSAND_in_attrScope126 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_attrScope135 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_grammarSpec147 = new BitSet(new ulong[]{0x400200008000200UL,0x20028002UL});
		public static readonly BitSet _DOC_COMMENT_in_grammarSpec151 = new BitSet(new ulong[]{0x400200000000200UL,0x20028002UL});
		public static readonly BitSet _OPTIONS_in_grammarSpec159 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IMPORT_in_grammarSpec173 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TOKENS_in_grammarSpec187 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _attrScope_in_grammarSpec198 = new BitSet(new ulong[]{0x200UL,0x28002UL});
		public static readonly BitSet _AMPERSAND_in_grammarSpec206 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rules_in_grammarSpec218 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rule_in_rules230 = new BitSet(new ulong[]{0x2UL,0x8002UL});
		public static readonly BitSet _PREC_RULE_in_rules235 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _RULE_in_rule254 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rule258 = new BitSet(new ulong[]{0x10000000400UL,0x1CUL});
		public static readonly BitSet _modifier_in_rule269 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ARG_in_rule276 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rule278 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RET_in_rule286 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rule288 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _throwsSpec_in_rule295 = new BitSet(new ulong[]{0x400000000010200UL,0x20000UL});
		public static readonly BitSet _OPTIONS_in_rule304 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleScopeSpec_in_rule316 = new BitSet(new ulong[]{0x10200UL});
		public static readonly BitSet _AMPERSAND_in_rule325 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_rule339 = new BitSet(new ulong[]{0x4400020000UL});
		public static readonly BitSet _exceptionGroup_in_rule344 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _EOR_in_rule350 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _THROWS_in_throwsSpec404 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_throwsSpec406 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _SCOPE_in_ruleScopeSpec420 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec425 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_ruleScopeSpec434 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _ID_in_ruleScopeSpec437 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _set_in_block465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_in_block475 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _OPTIONS_in_block480 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _alternative_in_block496 = new BitSet(new ulong[]{0x200000100UL,0x1000UL});
		public static readonly BitSet _rewrite_in_block498 = new BitSet(new ulong[]{0x200000100UL});
		public static readonly BitSet _EOB_in_block521 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_alternative550 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_alternative555 = new BitSet(new ulong[]{0x82800289202DE010UL,0x547092041UL});
		public static readonly BitSet _EOA_in_alternative562 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _exceptionHandler_in_exceptionGroup579 = new BitSet(new ulong[]{0x4000020002UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup582 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup588 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_exceptionHandler603 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_exceptionHandler605 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_exceptionHandler607 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FINALLY_in_finallyClause623 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_finallyClause625 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _REWRITES_in_rewrite639 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _REWRITE_in_rewrite657 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ROOT_in_element690 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element694 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BANG_in_element710 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element714 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_element730 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element732 = new BitSet(new ulong[]{0x82800288202DE010UL,0x547092041UL});
		public static readonly BitSet _element_in_element736 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PLUS_ASSIGN_in_element751 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element753 = new BitSet(new ulong[]{0x82800288202DE010UL,0x547092041UL});
		public static readonly BitSet _element_in_element757 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RANGE_in_element771 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _atom_in_element775 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_element780 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_RANGE_in_element793 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_element797 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_element801 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _atom_or_notatom_in_element809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ebnf_in_element824 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tree__in_element841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYNPRED_in_element859 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_element861 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ACTION_in_element867 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FORCED_ACTION_in_element884 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMPRED_in_element899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYN_SEMPRED_in_element916 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_element933 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _GATED_SEMPRED_in_element950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EPSILON_in_element965 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_ebnf1001 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_ebnf1010 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPTIONAL_in_ebnf1023 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1027 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CLOSURE_in_ebnf1038 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1042 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1053 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1057 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_BEGIN_in_tree_1082 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_tree_1089 = new BitSet(new ulong[]{0x82800288202DE018UL,0x547092041UL});
		public static readonly BitSet _element_in_tree_1101 = new BitSet(new ulong[]{0x82800288202DE018UL,0x547092041UL});
		public static readonly BitSet _atom_in_atom_or_notatom1137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_atom_or_notatom1149 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_atom_or_notatom1158 = new BitSet(new ulong[]{0x8008UL,0x2000UL});
		public static readonly BitSet _ast_suffix_in_atom_or_notatom1160 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TOKEN_REF_in_atom_or_notatom1173 = new BitSet(new ulong[]{0x8008UL,0x2000UL});
		public static readonly BitSet _ast_suffix_in_atom_or_notatom1175 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _set_in_atom_or_notatom1187 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RULE_REF_in_atom1229 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1231 = new BitSet(new ulong[]{0x8008UL,0x2000UL});
		public static readonly BitSet _ast_suffix_in_atom1234 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TOKEN_REF_in_atom1246 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1248 = new BitSet(new ulong[]{0x8008UL,0x2000UL});
		public static readonly BitSet _ast_suffix_in_atom1251 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_atom1263 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ast_suffix_in_atom1265 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STRING_LITERAL_in_atom1279 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ast_suffix_in_atom1281 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _WILDCARD_in_atom1295 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ast_suffix_in_atom1297 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DOT_in_atom1310 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_atom1314 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_atom1318 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BLOCK_in_set1363 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALT_in_set1372 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_set1377 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _setElement_in_set1386 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_set1389 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EOB_in_set1399 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RULE_in_setRule1428 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_setRule1430 = new BitSet(new ulong[]{0x10000000400UL,0x1CUL});
		public static readonly BitSet _modifier_in_setRule1432 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ARG_in_setRule1435 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RET_in_setRule1437 = new BitSet(new ulong[]{0x400000000010200UL,0x20000UL});
		public static readonly BitSet _OPTIONS_in_setRule1442 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleScopeSpec_in_setRule1451 = new BitSet(new ulong[]{0x10200UL});
		public static readonly BitSet _AMPERSAND_in_setRule1460 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BLOCK_in_setRule1474 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _OPTIONS_in_setRule1479 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALT_in_setRule1495 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_setRule1497 = new BitSet(new ulong[]{0x800000000D0000UL,0x41000000UL});
		public static readonly BitSet _setElement_in_setRule1500 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_setRule1503 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EOB_in_setRule1513 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _exceptionGroup_in_setRule1524 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _EOR_in_setRule1530 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_setElement1559 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_setElement1576 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_setElement1594 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_RANGE_in_setElement1609 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_setElement1613 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_setElement1617 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _set_in_setElement1627 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_setElement1645 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _setElement_in_setElement1662 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BLOCK_in_testBlockAsSet1711 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALT_in_testBlockAsSet1719 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_testBlockAsSet1721 = new BitSet(new ulong[]{0x800000000D0000UL,0x41000000UL});
		public static readonly BitSet _testSetElement_in_testBlockAsSet1724 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_testBlockAsSet1728 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EOB_in_testBlockAsSet1740 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RULE_in_testSetRule1775 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_testSetRule1777 = new BitSet(new ulong[]{0x10000000400UL,0x1CUL});
		public static readonly BitSet _modifier_in_testSetRule1779 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ARG_in_testSetRule1782 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RET_in_testSetRule1784 = new BitSet(new ulong[]{0x400000000010200UL,0x20000UL});
		public static readonly BitSet _OPTIONS_in_testSetRule1789 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleScopeSpec_in_testSetRule1798 = new BitSet(new ulong[]{0x10200UL});
		public static readonly BitSet _AMPERSAND_in_testSetRule1807 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BLOCK_in_testSetRule1821 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALT_in_testSetRule1830 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_testSetRule1832 = new BitSet(new ulong[]{0x800000000D0000UL,0x41000000UL});
		public static readonly BitSet _testSetElement_in_testSetRule1835 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_testSetRule1839 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EOB_in_testSetRule1853 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _exceptionGroup_in_testSetRule1863 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _EOR_in_testSetRule1869 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1901 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_testSetElement1910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_testSetElement1929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_RANGE_in_testSetElement1935 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1939 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_testSetElement1943 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _testBlockAsSet_in_testSetElement1955 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_testSetElement1968 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _testSetElement_in_testSetElement1972 = new BitSet(new ulong[]{0x8UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.Grammars
