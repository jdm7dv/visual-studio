//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\ActionTranslator.g3 2013-06-14 09:39:32

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.Grammars
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ActionTranslator : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ARG=5;
	public const int ATTR_VALUE_EXPR=6;
	public const int DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR=7;
	public const int DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR=8;
	public const int DYNAMIC_SCOPE_ATTR=9;
	public const int ENCLOSING_RULE_SCOPE_ATTR=10;
	public const int ERROR_SCOPED_XY=11;
	public const int ERROR_X=12;
	public const int ERROR_XY=13;
	public const int ESC=14;
	public const int ID=15;
	public const int INDIRECT_TEMPLATE_INSTANCE=16;
	public const int INT=17;
	public const int ISOLATED_DYNAMIC_SCOPE=18;
	public const int ISOLATED_LEXER_RULE_REF=19;
	public const int ISOLATED_TOKEN_REF=20;
	public const int LABEL_REF=21;
	public const int LOCAL_ATTR=22;
	public const int RULE_SCOPE_ATTR=23;
	public const int SCOPE_INDEX_EXPR=24;
	public const int SET_ATTRIBUTE=25;
	public const int SET_DYNAMIC_SCOPE_ATTR=26;
	public const int SET_ENCLOSING_RULE_SCOPE_ATTR=27;
	public const int SET_EXPR_ATTRIBUTE=28;
	public const int SET_LOCAL_ATTR=29;
	public const int SET_RULE_SCOPE_ATTR=30;
	public const int SET_TOKEN_SCOPE_ATTR=31;
	public const int TEMPLATE_EXPR=32;
	public const int TEMPLATE_INSTANCE=33;
	public const int TEXT=34;
	public const int TOKEN_SCOPE_ATTR=35;
	public const int UNKNOWN_SYNTAX=36;
	public const int WS=37;

	// delegates
	// delegators

	private ActionTranslator()
	{
		OnCreated();
	}

	private ActionTranslator(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	private ActionTranslator(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Grammars\\ActionTranslator.g3"; } }

	public override IToken NextToken()
	{
		while (true)
		{
			if (input.LA(1) == CharStreamConstants.EndOfFile)
			{
				IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
				eof.Line = Line;
				eof.CharPositionInLine = CharPositionInLine;
				return eof;
			}
			state.token = null;
			state.channel = TokenChannels.Default;
			state.tokenStartCharIndex = input.Index;
			state.tokenStartCharPositionInLine = input.CharPositionInLine;
			state.tokenStartLine = input.Line;
			state.text = null;
			try
			{
				int m = input.Mark();
				state.backtracking=1;
				state.failed=false;
				mTokens();
				state.backtracking=0;
				if (state.failed)
				{
					input.Rewind(m);
					input.Consume();
				}
				else
				{
					Emit();
					return state.token;
				}
			}
			catch (RecognitionException re)
			{
				// shouldn't happen in backtracking mode, but...
				ReportError(re);
				Recover(re);
			}
		}
	}

	public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
	{
		if (state.backtracking > 1)
			base.Memoize(input, ruleIndex, ruleStartIndex);
	}

	public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
	{
		if (state.backtracking > 1)
			return base.AlreadyParsedRule(input, ruleIndex);

		return false;
	}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_SET_ENCLOSING_RULE_SCOPE_ATTR();
	partial void LeaveRule_SET_ENCLOSING_RULE_SCOPE_ATTR();

	// $ANTLR start "SET_ENCLOSING_RULE_SCOPE_ATTR"
	[GrammarRule("SET_ENCLOSING_RULE_SCOPE_ATTR")]
	private void mSET_ENCLOSING_RULE_SCOPE_ATTR()
	{
		EnterRule_SET_ENCLOSING_RULE_SCOPE_ATTR();
		EnterRule("SET_ENCLOSING_RULE_SCOPE_ATTR", 1);
		TraceIn("SET_ENCLOSING_RULE_SCOPE_ATTR", 1);
		try
		{
			int _type = SET_ENCLOSING_RULE_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);
			CommonToken expr = default(CommonToken);

			// Grammars\\ActionTranslator.g3:53:2: ( '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:53:4: '$' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
			{
			DebugLocation(53, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(53, 9);
			int xStart53 = CharIndex;
			int xStartLine53 = Line;
			int xStartCharPos53 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart53, CharIndex-1);
			x.Line = xStartLine53;
			x.CharPositionInLine = xStartCharPos53;
			DebugLocation(53, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(53, 18);
			int yStart59 = CharIndex;
			int yStartLine59 = Line;
			int yStartCharPos59 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart59, CharIndex-1);
			y.Line = yStartLine59;
			y.CharPositionInLine = yStartCharPos59;
			DebugLocation(53, 22);
			// Grammars\\ActionTranslator.g3:53:22: ( WS )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if (((LA1_1>='\t' && LA1_1<='\n')||LA1_1=='\r'||LA1_1==' '))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:53:22: WS
				{
				DebugLocation(53, 22);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(53, 26);
			Match('='); if (state.failed) return;
			DebugLocation(53, 34);
			int exprStart68 = CharIndex;
			int exprStartLine68 = Line;
			int exprStartCharPos68 = CharPositionInLine;
			mATTR_VALUE_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart68, CharIndex-1);
			expr.Line = exprStartLine68;
			expr.CharPositionInLine = exprStartCharPos68;
			DebugLocation(53, 51);
			Match(';'); if (state.failed) return;
			DebugLocation(53, 55);
			if (!((CanMatchSetEnclosingRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "SET_ENCLOSING_RULE_SCOPE_ATTR", "CanMatchSetEnclosingRuleScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(54, 3);
			if (state.backtracking == 1)
			{
				HandleSetEnclosingRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_ENCLOSING_RULE_SCOPE_ATTR", 1);
			LeaveRule("SET_ENCLOSING_RULE_SCOPE_ATTR", 1);
			LeaveRule_SET_ENCLOSING_RULE_SCOPE_ATTR();
		}
	}
	// $ANTLR end "SET_ENCLOSING_RULE_SCOPE_ATTR"

	partial void EnterRule_ENCLOSING_RULE_SCOPE_ATTR();
	partial void LeaveRule_ENCLOSING_RULE_SCOPE_ATTR();

	// $ANTLR start "ENCLOSING_RULE_SCOPE_ATTR"
	[GrammarRule("ENCLOSING_RULE_SCOPE_ATTR")]
	private void mENCLOSING_RULE_SCOPE_ATTR()
	{
		EnterRule_ENCLOSING_RULE_SCOPE_ATTR();
		EnterRule("ENCLOSING_RULE_SCOPE_ATTR", 2);
		TraceIn("ENCLOSING_RULE_SCOPE_ATTR", 2);
		try
		{
			int _type = ENCLOSING_RULE_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:58:2: ( '$' x= ID '.' y= ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:58:4: '$' x= ID '.' y= ID {...}?
			{
			DebugLocation(58, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(58, 9);
			int xStart91 = CharIndex;
			int xStartLine91 = Line;
			int xStartCharPos91 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart91, CharIndex-1);
			x.Line = xStartLine91;
			x.CharPositionInLine = xStartCharPos91;
			DebugLocation(58, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(58, 18);
			int yStart97 = CharIndex;
			int yStartLine97 = Line;
			int yStartCharPos97 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart97, CharIndex-1);
			y.Line = yStartLine97;
			y.CharPositionInLine = yStartCharPos97;
			DebugLocation(58, 22);
			if (!((CanMatchEnclosingRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "ENCLOSING_RULE_SCOPE_ATTR", "CanMatchEnclosingRuleScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(59, 3);
			if (state.backtracking == 1)
			{
				HandleEnclosingRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ENCLOSING_RULE_SCOPE_ATTR", 2);
			LeaveRule("ENCLOSING_RULE_SCOPE_ATTR", 2);
			LeaveRule_ENCLOSING_RULE_SCOPE_ATTR();
		}
	}
	// $ANTLR end "ENCLOSING_RULE_SCOPE_ATTR"

	partial void EnterRule_SET_TOKEN_SCOPE_ATTR();
	partial void LeaveRule_SET_TOKEN_SCOPE_ATTR();

	// $ANTLR start "SET_TOKEN_SCOPE_ATTR"
	[GrammarRule("SET_TOKEN_SCOPE_ATTR")]
	private void mSET_TOKEN_SCOPE_ATTR()
	{
		EnterRule_SET_TOKEN_SCOPE_ATTR();
		EnterRule("SET_TOKEN_SCOPE_ATTR", 3);
		TraceIn("SET_TOKEN_SCOPE_ATTR", 3);
		try
		{
			int _type = SET_TOKEN_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:64:2: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:64:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?
			{
			DebugLocation(64, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(64, 9);
			int xStart120 = CharIndex;
			int xStartLine120 = Line;
			int xStartCharPos120 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart120, CharIndex-1);
			x.Line = xStartLine120;
			x.CharPositionInLine = xStartCharPos120;
			DebugLocation(64, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(64, 18);
			int yStart126 = CharIndex;
			int yStartLine126 = Line;
			int yStartCharPos126 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart126, CharIndex-1);
			y.Line = yStartLine126;
			y.CharPositionInLine = yStartCharPos126;
			DebugLocation(64, 22);
			// Grammars\\ActionTranslator.g3:64:22: ( WS )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if (((LA2_1>='\t' && LA2_1<='\n')||LA2_1=='\r'||LA2_1==' '))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:64:22: WS
				{
				DebugLocation(64, 22);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(64, 26);
			Match('='); if (state.failed) return;
			DebugLocation(64, 30);
			if (!((CanMatchSetTokenScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "SET_TOKEN_SCOPE_ATTR", "CanMatchSetTokenScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(65, 3);
			if (state.backtracking == 1)
			{
				HandleSetTokenScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_TOKEN_SCOPE_ATTR", 3);
			LeaveRule("SET_TOKEN_SCOPE_ATTR", 3);
			LeaveRule_SET_TOKEN_SCOPE_ATTR();
		}
	}
	// $ANTLR end "SET_TOKEN_SCOPE_ATTR"

	partial void EnterRule_TOKEN_SCOPE_ATTR();
	partial void LeaveRule_TOKEN_SCOPE_ATTR();

	// $ANTLR start "TOKEN_SCOPE_ATTR"
	[GrammarRule("TOKEN_SCOPE_ATTR")]
	private void mTOKEN_SCOPE_ATTR()
	{
		EnterRule_TOKEN_SCOPE_ATTR();
		EnterRule("TOKEN_SCOPE_ATTR", 4);
		TraceIn("TOKEN_SCOPE_ATTR", 4);
		try
		{
			int _type = TOKEN_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:72:2: ( '$' x= ID '.' y= ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:72:4: '$' x= ID '.' y= ID {...}?
			{
			DebugLocation(72, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(72, 9);
			int xStart154 = CharIndex;
			int xStartLine154 = Line;
			int xStartCharPos154 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart154, CharIndex-1);
			x.Line = xStartLine154;
			x.CharPositionInLine = xStartCharPos154;
			DebugLocation(72, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(72, 18);
			int yStart160 = CharIndex;
			int yStartLine160 = Line;
			int yStartCharPos160 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart160, CharIndex-1);
			y.Line = yStartLine160;
			y.CharPositionInLine = yStartCharPos160;
			DebugLocation(72, 22);
			if (!((CanMatchTokenScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "TOKEN_SCOPE_ATTR", "CanMatchTokenScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(73, 3);
			if (state.backtracking == 1)
			{
				HandleTokenScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TOKEN_SCOPE_ATTR", 4);
			LeaveRule("TOKEN_SCOPE_ATTR", 4);
			LeaveRule_TOKEN_SCOPE_ATTR();
		}
	}
	// $ANTLR end "TOKEN_SCOPE_ATTR"

	partial void EnterRule_SET_RULE_SCOPE_ATTR();
	partial void LeaveRule_SET_RULE_SCOPE_ATTR();

	// $ANTLR start "SET_RULE_SCOPE_ATTR"
	[GrammarRule("SET_RULE_SCOPE_ATTR")]
	private void mSET_RULE_SCOPE_ATTR()
	{
		EnterRule_SET_RULE_SCOPE_ATTR();
		EnterRule("SET_RULE_SCOPE_ATTR", 5);
		TraceIn("SET_RULE_SCOPE_ATTR", 5);
		try
		{
			int _type = SET_RULE_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:82:2: ( '$' x= ID '.' y= ID ( WS )? '=' {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:82:4: '$' x= ID '.' y= ID ( WS )? '=' {...}?
			{
			DebugLocation(82, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(82, 9);
			int xStart183 = CharIndex;
			int xStartLine183 = Line;
			int xStartCharPos183 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart183, CharIndex-1);
			x.Line = xStartLine183;
			x.CharPositionInLine = xStartCharPos183;
			DebugLocation(82, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(82, 18);
			int yStart189 = CharIndex;
			int yStartLine189 = Line;
			int yStartCharPos189 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart189, CharIndex-1);
			y.Line = yStartLine189;
			y.CharPositionInLine = yStartCharPos189;
			DebugLocation(82, 22);
			// Grammars\\ActionTranslator.g3:82:22: ( WS )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if (((LA3_1>='\t' && LA3_1<='\n')||LA3_1=='\r'||LA3_1==' '))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:82:22: WS
				{
				DebugLocation(82, 22);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(82, 26);
			Match('='); if (state.failed) return;
			DebugLocation(82, 30);
			if (!((CanMatchSetRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "CanMatchSetRuleScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(83, 3);
			if (state.backtracking == 1)
			{
				HandleSetRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_RULE_SCOPE_ATTR", 5);
			LeaveRule("SET_RULE_SCOPE_ATTR", 5);
			LeaveRule_SET_RULE_SCOPE_ATTR();
		}
	}
	// $ANTLR end "SET_RULE_SCOPE_ATTR"

	partial void EnterRule_RULE_SCOPE_ATTR();
	partial void LeaveRule_RULE_SCOPE_ATTR();

	// $ANTLR start "RULE_SCOPE_ATTR"
	[GrammarRule("RULE_SCOPE_ATTR")]
	private void mRULE_SCOPE_ATTR()
	{
		EnterRule_RULE_SCOPE_ATTR();
		EnterRule("RULE_SCOPE_ATTR", 6);
		TraceIn("RULE_SCOPE_ATTR", 6);
		try
		{
			int _type = RULE_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:88:2: ( '$' x= ID '.' y= ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:88:4: '$' x= ID '.' y= ID {...}?
			{
			DebugLocation(88, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(88, 9);
			int xStart217 = CharIndex;
			int xStartLine217 = Line;
			int xStartCharPos217 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart217, CharIndex-1);
			x.Line = xStartLine217;
			x.CharPositionInLine = xStartCharPos217;
			DebugLocation(88, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(88, 18);
			int yStart223 = CharIndex;
			int yStartLine223 = Line;
			int yStartCharPos223 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart223, CharIndex-1);
			y.Line = yStartLine223;
			y.CharPositionInLine = yStartCharPos223;
			DebugLocation(88, 22);
			if (!((CanMatchRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "CanMatchRuleScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(89, 3);
			if (state.backtracking == 1)
			{
				HandleRuleScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RULE_SCOPE_ATTR", 6);
			LeaveRule("RULE_SCOPE_ATTR", 6);
			LeaveRule_RULE_SCOPE_ATTR();
		}
	}
	// $ANTLR end "RULE_SCOPE_ATTR"

	partial void EnterRule_LABEL_REF();
	partial void LeaveRule_LABEL_REF();

	// $ANTLR start "LABEL_REF"
	[GrammarRule("LABEL_REF")]
	private void mLABEL_REF()
	{
		EnterRule_LABEL_REF();
		EnterRule("LABEL_REF", 7);
		TraceIn("LABEL_REF", 7);
		try
		{
			int _type = LABEL_REF;
			int _channel = DefaultTokenChannel;
			CommonToken ID1 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:95:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:95:4: '$' ID {...}?
			{
			DebugLocation(95, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(95, 8);
			int ID1Start245 = CharIndex;
			int ID1StartLine245 = Line;
			int ID1StartCharPos245 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID1Start245, CharIndex-1);
			ID1.Line = ID1StartLine245;
			ID1.CharPositionInLine = ID1StartCharPos245;
			DebugLocation(95, 11);
			if (!((CanMatchLabelReference((ID1!=null?ID1.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "LABEL_REF", "CanMatchLabelReference($ID.text)");
			}
			DebugLocation(96, 3);
			if (state.backtracking == 1)
			{
				HandleLabelReference((ID1!=null?ID1.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LABEL_REF", 7);
			LeaveRule("LABEL_REF", 7);
			LeaveRule_LABEL_REF();
		}
	}
	// $ANTLR end "LABEL_REF"

	partial void EnterRule_ISOLATED_TOKEN_REF();
	partial void LeaveRule_ISOLATED_TOKEN_REF();

	// $ANTLR start "ISOLATED_TOKEN_REF"
	[GrammarRule("ISOLATED_TOKEN_REF")]
	private void mISOLATED_TOKEN_REF()
	{
		EnterRule_ISOLATED_TOKEN_REF();
		EnterRule("ISOLATED_TOKEN_REF", 8);
		TraceIn("ISOLATED_TOKEN_REF", 8);
		try
		{
			int _type = ISOLATED_TOKEN_REF;
			int _channel = DefaultTokenChannel;
			CommonToken ID2 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:101:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:101:4: '$' ID {...}?
			{
			DebugLocation(101, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(101, 8);
			int ID2Start266 = CharIndex;
			int ID2StartLine266 = Line;
			int ID2StartCharPos266 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID2Start266, CharIndex-1);
			ID2.Line = ID2StartLine266;
			ID2.CharPositionInLine = ID2StartCharPos266;
			DebugLocation(101, 11);
			if (!((CanMatchIsolatedTokenReference((ID2!=null?ID2.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "ISOLATED_TOKEN_REF", "CanMatchIsolatedTokenReference($ID.text)");
			}
			DebugLocation(102, 3);
			if (state.backtracking == 1)
			{
				HandleIsolatedTokenReference((ID2!=null?ID2.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ISOLATED_TOKEN_REF", 8);
			LeaveRule("ISOLATED_TOKEN_REF", 8);
			LeaveRule_ISOLATED_TOKEN_REF();
		}
	}
	// $ANTLR end "ISOLATED_TOKEN_REF"

	partial void EnterRule_ISOLATED_LEXER_RULE_REF();
	partial void LeaveRule_ISOLATED_LEXER_RULE_REF();

	// $ANTLR start "ISOLATED_LEXER_RULE_REF"
	[GrammarRule("ISOLATED_LEXER_RULE_REF")]
	private void mISOLATED_LEXER_RULE_REF()
	{
		EnterRule_ISOLATED_LEXER_RULE_REF();
		EnterRule("ISOLATED_LEXER_RULE_REF", 9);
		TraceIn("ISOLATED_LEXER_RULE_REF", 9);
		try
		{
			int _type = ISOLATED_LEXER_RULE_REF;
			int _channel = DefaultTokenChannel;
			CommonToken ID3 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:107:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:107:4: '$' ID {...}?
			{
			DebugLocation(107, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(107, 8);
			int ID3Start287 = CharIndex;
			int ID3StartLine287 = Line;
			int ID3StartCharPos287 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID3 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID3Start287, CharIndex-1);
			ID3.Line = ID3StartLine287;
			ID3.CharPositionInLine = ID3StartCharPos287;
			DebugLocation(107, 11);
			if (!((CanMatchIsolatedLexerRuleReference((ID3!=null?ID3.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "ISOLATED_LEXER_RULE_REF", "CanMatchIsolatedLexerRuleReference($ID.text)");
			}
			DebugLocation(108, 3);
			if (state.backtracking == 1)
			{
				HandleIsolatedLexerRuleReference((ID3!=null?ID3.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ISOLATED_LEXER_RULE_REF", 9);
			LeaveRule("ISOLATED_LEXER_RULE_REF", 9);
			LeaveRule_ISOLATED_LEXER_RULE_REF();
		}
	}
	// $ANTLR end "ISOLATED_LEXER_RULE_REF"

	partial void EnterRule_SET_LOCAL_ATTR();
	partial void LeaveRule_SET_LOCAL_ATTR();

	// $ANTLR start "SET_LOCAL_ATTR"
	[GrammarRule("SET_LOCAL_ATTR")]
	private void mSET_LOCAL_ATTR()
	{
		EnterRule_SET_LOCAL_ATTR();
		EnterRule("SET_LOCAL_ATTR", 10);
		TraceIn("SET_LOCAL_ATTR", 10);
		try
		{
			int _type = SET_LOCAL_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken expr = default(CommonToken);
			CommonToken ID4 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:123:2: ( '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:123:4: '$' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
			{
			DebugLocation(123, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(123, 8);
			int ID4Start308 = CharIndex;
			int ID4StartLine308 = Line;
			int ID4StartCharPos308 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID4 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID4Start308, CharIndex-1);
			ID4.Line = ID4StartLine308;
			ID4.CharPositionInLine = ID4StartCharPos308;
			DebugLocation(123, 11);
			// Grammars\\ActionTranslator.g3:123:11: ( WS )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if (((LA4_1>='\t' && LA4_1<='\n')||LA4_1=='\r'||LA4_1==' '))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:123:11: WS
				{
				DebugLocation(123, 11);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(123, 15);
			Match('='); if (state.failed) return;
			DebugLocation(123, 23);
			int exprStart317 = CharIndex;
			int exprStartLine317 = Line;
			int exprStartCharPos317 = CharPositionInLine;
			mATTR_VALUE_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart317, CharIndex-1);
			expr.Line = exprStartLine317;
			expr.CharPositionInLine = exprStartCharPos317;
			DebugLocation(123, 40);
			Match(';'); if (state.failed) return;
			DebugLocation(123, 44);
			if (!((CanMatchSetLocalAttribute((ID4!=null?ID4.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "SET_LOCAL_ATTR", "CanMatchSetLocalAttribute($ID.text)");
			}
			DebugLocation(124, 3);
			if (state.backtracking == 1)
			{
				HandleSetLocalAttribute((ID4!=null?ID4.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_LOCAL_ATTR", 10);
			LeaveRule("SET_LOCAL_ATTR", 10);
			LeaveRule_SET_LOCAL_ATTR();
		}
	}
	// $ANTLR end "SET_LOCAL_ATTR"

	partial void EnterRule_LOCAL_ATTR();
	partial void LeaveRule_LOCAL_ATTR();

	// $ANTLR start "LOCAL_ATTR"
	[GrammarRule("LOCAL_ATTR")]
	private void mLOCAL_ATTR()
	{
		EnterRule_LOCAL_ATTR();
		EnterRule("LOCAL_ATTR", 11);
		TraceIn("LOCAL_ATTR", 11);
		try
		{
			int _type = LOCAL_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken ID5 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:128:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:128:4: '$' ID {...}?
			{
			DebugLocation(128, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(128, 8);
			int ID5Start338 = CharIndex;
			int ID5StartLine338 = Line;
			int ID5StartCharPos338 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID5 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID5Start338, CharIndex-1);
			ID5.Line = ID5StartLine338;
			ID5.CharPositionInLine = ID5StartCharPos338;
			DebugLocation(128, 11);
			if (!((CanMatchLocalAttribute((ID5!=null?ID5.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "LOCAL_ATTR", "CanMatchLocalAttribute($ID.text)");
			}
			DebugLocation(129, 3);
			if (state.backtracking == 1)
			{
				HandleLocalAttribute((ID5!=null?ID5.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LOCAL_ATTR", 11);
			LeaveRule("LOCAL_ATTR", 11);
			LeaveRule_LOCAL_ATTR();
		}
	}
	// $ANTLR end "LOCAL_ATTR"

	partial void EnterRule_SET_DYNAMIC_SCOPE_ATTR();
	partial void LeaveRule_SET_DYNAMIC_SCOPE_ATTR();

	// $ANTLR start "SET_DYNAMIC_SCOPE_ATTR"
	[GrammarRule("SET_DYNAMIC_SCOPE_ATTR")]
	private void mSET_DYNAMIC_SCOPE_ATTR()
	{
		EnterRule_SET_DYNAMIC_SCOPE_ATTR();
		EnterRule("SET_DYNAMIC_SCOPE_ATTR", 12);
		TraceIn("SET_DYNAMIC_SCOPE_ATTR", 12);
		try
		{
			int _type = SET_DYNAMIC_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);
			CommonToken expr = default(CommonToken);

			// Grammars\\ActionTranslator.g3:145:2: ( '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:145:4: '$' x= ID '::' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' {...}?
			{
			DebugLocation(145, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(145, 9);
			int xStart361 = CharIndex;
			int xStartLine361 = Line;
			int xStartCharPos361 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart361, CharIndex-1);
			x.Line = xStartLine361;
			x.CharPositionInLine = xStartCharPos361;
			DebugLocation(145, 13);
			Match("::"); if (state.failed) return;

			DebugLocation(145, 19);
			int yStart367 = CharIndex;
			int yStartLine367 = Line;
			int yStartCharPos367 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart367, CharIndex-1);
			y.Line = yStartLine367;
			y.CharPositionInLine = yStartCharPos367;
			DebugLocation(145, 23);
			// Grammars\\ActionTranslator.g3:145:23: ( WS )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if (((LA5_1>='\t' && LA5_1<='\n')||LA5_1=='\r'||LA5_1==' '))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:145:23: WS
				{
				DebugLocation(145, 23);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(145, 27);
			Match('='); if (state.failed) return;
			DebugLocation(145, 35);
			int exprStart376 = CharIndex;
			int exprStartLine376 = Line;
			int exprStartCharPos376 = CharPositionInLine;
			mATTR_VALUE_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart376, CharIndex-1);
			expr.Line = exprStartLine376;
			expr.CharPositionInLine = exprStartCharPos376;
			DebugLocation(145, 52);
			Match(';'); if (state.failed) return;
			DebugLocation(145, 56);
			if (!((CanMatchSetDynamicScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "SET_DYNAMIC_SCOPE_ATTR", "CanMatchSetDynamicScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(146, 3);
			if (state.backtracking == 1)
			{
				HandleSetDynamicScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_DYNAMIC_SCOPE_ATTR", 12);
			LeaveRule("SET_DYNAMIC_SCOPE_ATTR", 12);
			LeaveRule_SET_DYNAMIC_SCOPE_ATTR();
		}
	}
	// $ANTLR end "SET_DYNAMIC_SCOPE_ATTR"

	partial void EnterRule_DYNAMIC_SCOPE_ATTR();
	partial void LeaveRule_DYNAMIC_SCOPE_ATTR();

	// $ANTLR start "DYNAMIC_SCOPE_ATTR"
	[GrammarRule("DYNAMIC_SCOPE_ATTR")]
	private void mDYNAMIC_SCOPE_ATTR()
	{
		EnterRule_DYNAMIC_SCOPE_ATTR();
		EnterRule("DYNAMIC_SCOPE_ATTR", 13);
		TraceIn("DYNAMIC_SCOPE_ATTR", 13);
		try
		{
			int _type = DYNAMIC_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:150:2: ( '$' x= ID '::' y= ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:150:4: '$' x= ID '::' y= ID {...}?
			{
			DebugLocation(150, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(150, 9);
			int xStart399 = CharIndex;
			int xStartLine399 = Line;
			int xStartCharPos399 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart399, CharIndex-1);
			x.Line = xStartLine399;
			x.CharPositionInLine = xStartCharPos399;
			DebugLocation(150, 13);
			Match("::"); if (state.failed) return;

			DebugLocation(150, 19);
			int yStart405 = CharIndex;
			int yStartLine405 = Line;
			int yStartCharPos405 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart405, CharIndex-1);
			y.Line = yStartLine405;
			y.CharPositionInLine = yStartCharPos405;
			DebugLocation(150, 23);
			if (!((CanMatchDynamicScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "DYNAMIC_SCOPE_ATTR", "CanMatchDynamicScopeAttribute($x.text, $y.text)");
			}
			DebugLocation(151, 3);
			if (state.backtracking == 1)
			{
				HandleDynamicScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DYNAMIC_SCOPE_ATTR", 13);
			LeaveRule("DYNAMIC_SCOPE_ATTR", 13);
			LeaveRule_DYNAMIC_SCOPE_ATTR();
		}
	}
	// $ANTLR end "DYNAMIC_SCOPE_ATTR"

	partial void EnterRule_ERROR_SCOPED_XY();
	partial void LeaveRule_ERROR_SCOPED_XY();

	// $ANTLR start "ERROR_SCOPED_XY"
	[GrammarRule("ERROR_SCOPED_XY")]
	private void mERROR_SCOPED_XY()
	{
		EnterRule_ERROR_SCOPED_XY();
		EnterRule("ERROR_SCOPED_XY", 14);
		TraceIn("ERROR_SCOPED_XY", 14);
		try
		{
			int _type = ERROR_SCOPED_XY;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:155:2: ( '$' x= ID '::' y= ID )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:155:4: '$' x= ID '::' y= ID
			{
			DebugLocation(155, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(155, 9);
			int xStart426 = CharIndex;
			int xStartLine426 = Line;
			int xStartCharPos426 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart426, CharIndex-1);
			x.Line = xStartLine426;
			x.CharPositionInLine = xStartCharPos426;
			DebugLocation(155, 13);
			Match("::"); if (state.failed) return;

			DebugLocation(155, 19);
			int yStart432 = CharIndex;
			int yStartLine432 = Line;
			int yStartCharPos432 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart432, CharIndex-1);
			y.Line = yStartLine432;
			y.CharPositionInLine = yStartCharPos432;
			DebugLocation(156, 3);
			if (state.backtracking == 1)
			{
				HandleErrorScopedXY((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ERROR_SCOPED_XY", 14);
			LeaveRule("ERROR_SCOPED_XY", 14);
			LeaveRule_ERROR_SCOPED_XY();
		}
	}
	// $ANTLR end "ERROR_SCOPED_XY"

	partial void EnterRule_DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR();
	partial void LeaveRule_DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR();

	// $ANTLR start "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"
	[GrammarRule("DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR")]
	private void mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR()
	{
		EnterRule_DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR();
		EnterRule("DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR", 15);
		TraceIn("DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR", 15);
		try
		{
			int _type = DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken expr = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:168:2: ( '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:168:4: '$' x= ID '[' '-' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
			{
			DebugLocation(168, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(168, 9);
			int xStart453 = CharIndex;
			int xStartLine453 = Line;
			int xStartCharPos453 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart453, CharIndex-1);
			x.Line = xStartLine453;
			x.CharPositionInLine = xStartCharPos453;
			DebugLocation(168, 13);
			Match('['); if (state.failed) return;
			DebugLocation(168, 17);
			Match('-'); if (state.failed) return;
			DebugLocation(168, 25);
			int exprStart461 = CharIndex;
			int exprStartLine461 = Line;
			int exprStartCharPos461 = CharPositionInLine;
			mSCOPE_INDEX_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart461, CharIndex-1);
			expr.Line = exprStartLine461;
			expr.CharPositionInLine = exprStartCharPos461;
			DebugLocation(168, 43);
			Match(']'); if (state.failed) return;
			DebugLocation(168, 47);
			Match("::"); if (state.failed) return;

			DebugLocation(168, 53);
			int yStart469 = CharIndex;
			int yStartLine469 = Line;
			int yStartCharPos469 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart469, CharIndex-1);
			y.Line = yStartLine469;
			y.CharPositionInLine = yStartCharPos469;
			DebugLocation(169, 3);
			if (state.backtracking == 1)
			{
				HandleDynamicNegativeIndexedScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR", 15);
			LeaveRule("DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR", 15);
			LeaveRule_DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR();
		}
	}
	// $ANTLR end "DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR"

	partial void EnterRule_DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR();
	partial void LeaveRule_DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR();

	// $ANTLR start "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"
	[GrammarRule("DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR")]
	private void mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR()
	{
		EnterRule_DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR();
		EnterRule("DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR", 16);
		TraceIn("DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR", 16);
		try
		{
			int _type = DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken expr = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:173:2: ( '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:173:4: '$' x= ID '[' expr= SCOPE_INDEX_EXPR ']' '::' y= ID
			{
			DebugLocation(173, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(173, 9);
			int xStart488 = CharIndex;
			int xStartLine488 = Line;
			int xStartCharPos488 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart488, CharIndex-1);
			x.Line = xStartLine488;
			x.CharPositionInLine = xStartCharPos488;
			DebugLocation(173, 13);
			Match('['); if (state.failed) return;
			DebugLocation(173, 21);
			int exprStart494 = CharIndex;
			int exprStartLine494 = Line;
			int exprStartCharPos494 = CharPositionInLine;
			mSCOPE_INDEX_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart494, CharIndex-1);
			expr.Line = exprStartLine494;
			expr.CharPositionInLine = exprStartCharPos494;
			DebugLocation(173, 39);
			Match(']'); if (state.failed) return;
			DebugLocation(173, 43);
			Match("::"); if (state.failed) return;

			DebugLocation(173, 49);
			int yStart502 = CharIndex;
			int yStartLine502 = Line;
			int yStartCharPos502 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart502, CharIndex-1);
			y.Line = yStartLine502;
			y.CharPositionInLine = yStartCharPos502;
			DebugLocation(174, 3);
			if (state.backtracking == 1)
			{
				HandleDynamicAbsoluteIndexedScopeAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR", 16);
			LeaveRule("DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR", 16);
			LeaveRule_DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR();
		}
	}
	// $ANTLR end "DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR"

	partial void EnterRule_SCOPE_INDEX_EXPR();
	partial void LeaveRule_SCOPE_INDEX_EXPR();

	// $ANTLR start "SCOPE_INDEX_EXPR"
	[GrammarRule("SCOPE_INDEX_EXPR")]
	private void mSCOPE_INDEX_EXPR()
	{
		EnterRule_SCOPE_INDEX_EXPR();
		EnterRule("SCOPE_INDEX_EXPR", 17);
		TraceIn("SCOPE_INDEX_EXPR", 17);
		try
		{
			// Grammars\\ActionTranslator.g3:179:2: ( (~ ']' )+ )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:179:4: (~ ']' )+
			{
			DebugLocation(179, 4);
			// Grammars\\ActionTranslator.g3:179:4: (~ ']' )+
			int cnt6=0;
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if (((LA6_1>='\u0000' && LA6_1<='\\')||(LA6_1>='^' && LA6_1<='\uFFFF')))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:
					{
					DebugLocation(179, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt6 >= 1)
						goto loop6;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee6 = new EarlyExitException( 6, input );
					DebugRecognitionException(eee6);
					throw eee6;
				}
				cnt6++;
			}
			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

		}
		finally
		{
			TraceOut("SCOPE_INDEX_EXPR", 17);
			LeaveRule("SCOPE_INDEX_EXPR", 17);
			LeaveRule_SCOPE_INDEX_EXPR();
		}
	}
	// $ANTLR end "SCOPE_INDEX_EXPR"

	partial void EnterRule_ISOLATED_DYNAMIC_SCOPE();
	partial void LeaveRule_ISOLATED_DYNAMIC_SCOPE();

	// $ANTLR start "ISOLATED_DYNAMIC_SCOPE"
	[GrammarRule("ISOLATED_DYNAMIC_SCOPE")]
	private void mISOLATED_DYNAMIC_SCOPE()
	{
		EnterRule_ISOLATED_DYNAMIC_SCOPE();
		EnterRule("ISOLATED_DYNAMIC_SCOPE", 18);
		TraceIn("ISOLATED_DYNAMIC_SCOPE", 18);
		try
		{
			int _type = ISOLATED_DYNAMIC_SCOPE;
			int _channel = DefaultTokenChannel;
			CommonToken ID6 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:188:2: ( '$' ID {...}?)
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:188:4: '$' ID {...}?
			{
			DebugLocation(188, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(188, 8);
			int ID6Start540 = CharIndex;
			int ID6StartLine540 = Line;
			int ID6StartCharPos540 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID6 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID6Start540, CharIndex-1);
			ID6.Line = ID6StartLine540;
			ID6.CharPositionInLine = ID6StartCharPos540;
			DebugLocation(188, 11);
			if (!((CanMatchIsolatedDynamicScope((ID6!=null?ID6.Text:default(string))))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "ISOLATED_DYNAMIC_SCOPE", "CanMatchIsolatedDynamicScope($ID.text)");
			}
			DebugLocation(189, 3);
			if (state.backtracking == 1)
			{
				HandleIsolatedDynamicScope((ID6!=null?ID6.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ISOLATED_DYNAMIC_SCOPE", 18);
			LeaveRule("ISOLATED_DYNAMIC_SCOPE", 18);
			LeaveRule_ISOLATED_DYNAMIC_SCOPE();
		}
	}
	// $ANTLR end "ISOLATED_DYNAMIC_SCOPE"

	partial void EnterRule_TEMPLATE_INSTANCE();
	partial void LeaveRule_TEMPLATE_INSTANCE();

	// $ANTLR start "TEMPLATE_INSTANCE"
	[GrammarRule("TEMPLATE_INSTANCE")]
	private void mTEMPLATE_INSTANCE()
	{
		EnterRule_TEMPLATE_INSTANCE();
		EnterRule("TEMPLATE_INSTANCE", 19);
		TraceIn("TEMPLATE_INSTANCE", 19);
		try
		{
			int _type = TEMPLATE_INSTANCE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ActionTranslator.g3:197:2: ( '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:197:4: '%' ID '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
			{
			DebugLocation(197, 4);
			Match('%'); if (state.failed) return;
			DebugLocation(197, 8);
			mID(); if (state.failed) return;
			DebugLocation(197, 11);
			Match('('); if (state.failed) return;
			DebugLocation(197, 15);
			// Grammars\\ActionTranslator.g3:197:15: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if (((LA11_1>='\t' && LA11_1<='\n')||LA11_1=='\r'||LA11_1==' '||(LA11_1>='@' && LA11_1<='Z')||LA11_1=='_'||(LA11_1>='a' && LA11_1<='z')))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:197:17: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
				{
				DebugLocation(197, 17);
				// Grammars\\ActionTranslator.g3:197:17: ( WS )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if (((LA7_1>='\t' && LA7_1<='\n')||LA7_1=='\r'||LA7_1==' '))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:197:17: WS
					{
					DebugLocation(197, 17);
					mWS(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(7); }

				DebugLocation(197, 21);
				mARG(); if (state.failed) return;
				DebugLocation(197, 25);
				// Grammars\\ActionTranslator.g3:197:25: ( ',' ( WS )? ARG )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_1 = input.LA(1);

					if ((LA9_1==','))
					{
						alt9 = 1;
					}


					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ActionTranslator.g3:197:26: ',' ( WS )? ARG
						{
						DebugLocation(197, 26);
						Match(','); if (state.failed) return;
						DebugLocation(197, 30);
						// Grammars\\ActionTranslator.g3:197:30: ( WS )?
						int alt8=2;
						try { DebugEnterSubRule(8);
						try { DebugEnterDecision(8, false);
						int LA8_1 = input.LA(1);

						if (((LA8_1>='\t' && LA8_1<='\n')||LA8_1=='\r'||LA8_1==' '))
						{
							alt8 = 1;
						}
						} finally { DebugExitDecision(8); }
						switch (alt8)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\ActionTranslator.g3:197:30: WS
							{
							DebugLocation(197, 30);
							mWS(); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(8); }

						DebugLocation(197, 34);
						mARG(); if (state.failed) return;

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }

				DebugLocation(197, 40);
				// Grammars\\ActionTranslator.g3:197:40: ( WS )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if (((LA10_1>='\t' && LA10_1<='\n')||LA10_1=='\r'||LA10_1==' '))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:197:40: WS
					{
					DebugLocation(197, 40);
					mWS(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(10); }


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(197, 47);
			Match(')'); if (state.failed) return;
			DebugLocation(198, 3);
			if (state.backtracking == 1)
			{
				HandleTemplateInstance(Text);
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TEMPLATE_INSTANCE", 19);
			LeaveRule("TEMPLATE_INSTANCE", 19);
			LeaveRule_TEMPLATE_INSTANCE();
		}
	}
	// $ANTLR end "TEMPLATE_INSTANCE"

	partial void EnterRule_INDIRECT_TEMPLATE_INSTANCE();
	partial void LeaveRule_INDIRECT_TEMPLATE_INSTANCE();

	// $ANTLR start "INDIRECT_TEMPLATE_INSTANCE"
	[GrammarRule("INDIRECT_TEMPLATE_INSTANCE")]
	private void mINDIRECT_TEMPLATE_INSTANCE()
	{
		EnterRule_INDIRECT_TEMPLATE_INSTANCE();
		EnterRule("INDIRECT_TEMPLATE_INSTANCE", 20);
		TraceIn("INDIRECT_TEMPLATE_INSTANCE", 20);
		try
		{
			int _type = INDIRECT_TEMPLATE_INSTANCE;
			int _channel = DefaultTokenChannel;
			// Grammars\\ActionTranslator.g3:203:2: ( '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')' )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:203:4: '%' '(' ACTION ')' '(' ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )? ')'
			{
			DebugLocation(203, 4);
			Match('%'); if (state.failed) return;
			DebugLocation(203, 8);
			Match('('); if (state.failed) return;
			DebugLocation(203, 12);
			mACTION(); if (state.failed) return;
			DebugLocation(203, 19);
			Match(')'); if (state.failed) return;
			DebugLocation(203, 23);
			Match('('); if (state.failed) return;
			DebugLocation(203, 27);
			// Grammars\\ActionTranslator.g3:203:27: ( ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )? )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if (((LA16_1>='\t' && LA16_1<='\n')||LA16_1=='\r'||LA16_1==' '||(LA16_1>='@' && LA16_1<='Z')||LA16_1=='_'||(LA16_1>='a' && LA16_1<='z')))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:203:29: ( WS )? ARG ( ',' ( WS )? ARG )* ( WS )?
				{
				DebugLocation(203, 29);
				// Grammars\\ActionTranslator.g3:203:29: ( WS )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if (((LA12_1>='\t' && LA12_1<='\n')||LA12_1=='\r'||LA12_1==' '))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:203:29: WS
					{
					DebugLocation(203, 29);
					mWS(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(203, 33);
				mARG(); if (state.failed) return;
				DebugLocation(203, 37);
				// Grammars\\ActionTranslator.g3:203:37: ( ',' ( WS )? ARG )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if ((LA14_1==','))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ActionTranslator.g3:203:38: ',' ( WS )? ARG
						{
						DebugLocation(203, 38);
						Match(','); if (state.failed) return;
						DebugLocation(203, 42);
						// Grammars\\ActionTranslator.g3:203:42: ( WS )?
						int alt13=2;
						try { DebugEnterSubRule(13);
						try { DebugEnterDecision(13, false);
						int LA13_1 = input.LA(1);

						if (((LA13_1>='\t' && LA13_1<='\n')||LA13_1=='\r'||LA13_1==' '))
						{
							alt13 = 1;
						}
						} finally { DebugExitDecision(13); }
						switch (alt13)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\ActionTranslator.g3:203:42: WS
							{
							DebugLocation(203, 42);
							mWS(); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(13); }

						DebugLocation(203, 46);
						mARG(); if (state.failed) return;

						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }

				DebugLocation(203, 52);
				// Grammars\\ActionTranslator.g3:203:52: ( WS )?
				int alt15=2;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if (((LA15_1>='\t' && LA15_1<='\n')||LA15_1=='\r'||LA15_1==' '))
				{
					alt15 = 1;
				}
				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:203:52: WS
					{
					DebugLocation(203, 52);
					mWS(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(15); }


				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(203, 59);
			Match(')'); if (state.failed) return;
			DebugLocation(204, 3);
			if (state.backtracking == 1)
			{
				HandleIndirectTemplateInstance(Text);
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INDIRECT_TEMPLATE_INSTANCE", 20);
			LeaveRule("INDIRECT_TEMPLATE_INSTANCE", 20);
			LeaveRule_INDIRECT_TEMPLATE_INSTANCE();
		}
	}
	// $ANTLR end "INDIRECT_TEMPLATE_INSTANCE"

	partial void EnterRule_ARG();
	partial void LeaveRule_ARG();

	// $ANTLR start "ARG"
	[GrammarRule("ARG")]
	private void mARG()
	{
		EnterRule_ARG();
		EnterRule("ARG", 21);
		TraceIn("ARG", 21);
		try
		{
			// Grammars\\ActionTranslator.g3:208:5: ( ID '=' ACTION )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:208:7: ID '=' ACTION
			{
			DebugLocation(208, 7);
			mID(); if (state.failed) return;
			DebugLocation(208, 10);
			Match('='); if (state.failed) return;
			DebugLocation(208, 14);
			mACTION(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ARG", 21);
			LeaveRule("ARG", 21);
			LeaveRule_ARG();
		}
	}
	// $ANTLR end "ARG"

	partial void EnterRule_SET_EXPR_ATTRIBUTE();
	partial void LeaveRule_SET_EXPR_ATTRIBUTE();

	// $ANTLR start "SET_EXPR_ATTRIBUTE"
	[GrammarRule("SET_EXPR_ATTRIBUTE")]
	private void mSET_EXPR_ATTRIBUTE()
	{
		EnterRule_SET_EXPR_ATTRIBUTE();
		EnterRule("SET_EXPR_ATTRIBUTE", 22);
		TraceIn("SET_EXPR_ATTRIBUTE", 22);
		try
		{
			int _type = SET_EXPR_ATTRIBUTE;
			int _channel = DefaultTokenChannel;
			CommonToken a = default(CommonToken);
			CommonToken expr = default(CommonToken);
			CommonToken ID7 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:213:2: ( '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:213:4: '%' a= ACTION '.' ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
			{
			DebugLocation(213, 4);
			Match('%'); if (state.failed) return;
			DebugLocation(213, 9);
			int aStart679 = CharIndex;
			int aStartLine679 = Line;
			int aStartCharPos679 = CharPositionInLine;
			mACTION(); if (state.failed) return;
			a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart679, CharIndex-1);
			a.Line = aStartLine679;
			a.CharPositionInLine = aStartCharPos679;
			DebugLocation(213, 17);
			Match('.'); if (state.failed) return;
			DebugLocation(213, 21);
			int ID7Start683 = CharIndex;
			int ID7StartLine683 = Line;
			int ID7StartCharPos683 = CharPositionInLine;
			mID(); if (state.failed) return;
			ID7 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ID7Start683, CharIndex-1);
			ID7.Line = ID7StartLine683;
			ID7.CharPositionInLine = ID7StartCharPos683;
			DebugLocation(213, 24);
			// Grammars\\ActionTranslator.g3:213:24: ( WS )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if (((LA17_1>='\t' && LA17_1<='\n')||LA17_1=='\r'||LA17_1==' '))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:213:24: WS
				{
				DebugLocation(213, 24);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(213, 28);
			Match('='); if (state.failed) return;
			DebugLocation(213, 36);
			int exprStart692 = CharIndex;
			int exprStartLine692 = Line;
			int exprStartCharPos692 = CharPositionInLine;
			mATTR_VALUE_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart692, CharIndex-1);
			expr.Line = exprStartLine692;
			expr.CharPositionInLine = exprStartCharPos692;
			DebugLocation(213, 53);
			Match(';'); if (state.failed) return;
			DebugLocation(214, 3);
			if (state.backtracking == 1)
			{
				HandleSetExpressionAttribute((a!=null?a.Text:default(string)), (ID7!=null?ID7.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_EXPR_ATTRIBUTE", 22);
			LeaveRule("SET_EXPR_ATTRIBUTE", 22);
			LeaveRule_SET_EXPR_ATTRIBUTE();
		}
	}
	// $ANTLR end "SET_EXPR_ATTRIBUTE"

	partial void EnterRule_SET_ATTRIBUTE();
	partial void LeaveRule_SET_ATTRIBUTE();

	// $ANTLR start "SET_ATTRIBUTE"
	[GrammarRule("SET_ATTRIBUTE")]
	private void mSET_ATTRIBUTE()
	{
		EnterRule_SET_ATTRIBUTE();
		EnterRule("SET_ATTRIBUTE", 23);
		TraceIn("SET_ATTRIBUTE", 23);
		try
		{
			int _type = SET_ATTRIBUTE;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);
			CommonToken expr = default(CommonToken);

			// Grammars\\ActionTranslator.g3:222:2: ( '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';' )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:222:4: '%' x= ID '.' y= ID ( WS )? '=' expr= ATTR_VALUE_EXPR ';'
			{
			DebugLocation(222, 4);
			Match('%'); if (state.failed) return;
			DebugLocation(222, 9);
			int xStart716 = CharIndex;
			int xStartLine716 = Line;
			int xStartCharPos716 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart716, CharIndex-1);
			x.Line = xStartLine716;
			x.CharPositionInLine = xStartCharPos716;
			DebugLocation(222, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(222, 18);
			int yStart722 = CharIndex;
			int yStartLine722 = Line;
			int yStartCharPos722 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart722, CharIndex-1);
			y.Line = yStartLine722;
			y.CharPositionInLine = yStartCharPos722;
			DebugLocation(222, 22);
			// Grammars\\ActionTranslator.g3:222:22: ( WS )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if (((LA18_1>='\t' && LA18_1<='\n')||LA18_1=='\r'||LA18_1==' '))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:222:22: WS
				{
				DebugLocation(222, 22);
				mWS(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(222, 26);
			Match('='); if (state.failed) return;
			DebugLocation(222, 34);
			int exprStart731 = CharIndex;
			int exprStartLine731 = Line;
			int exprStartCharPos731 = CharPositionInLine;
			mATTR_VALUE_EXPR(); if (state.failed) return;
			expr = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, exprStart731, CharIndex-1);
			expr.Line = exprStartLine731;
			expr.CharPositionInLine = exprStartCharPos731;
			DebugLocation(222, 51);
			Match(';'); if (state.failed) return;
			DebugLocation(223, 3);
			if (state.backtracking == 1)
			{
				HandleSetAttribute((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)), (expr!=null?expr.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET_ATTRIBUTE", 23);
			LeaveRule("SET_ATTRIBUTE", 23);
			LeaveRule_SET_ATTRIBUTE();
		}
	}
	// $ANTLR end "SET_ATTRIBUTE"

	partial void EnterRule_ATTR_VALUE_EXPR();
	partial void LeaveRule_ATTR_VALUE_EXPR();

	// $ANTLR start "ATTR_VALUE_EXPR"
	[GrammarRule("ATTR_VALUE_EXPR")]
	private void mATTR_VALUE_EXPR()
	{
		EnterRule_ATTR_VALUE_EXPR();
		EnterRule("ATTR_VALUE_EXPR", 24);
		TraceIn("ATTR_VALUE_EXPR", 24);
		try
		{
			// Grammars\\ActionTranslator.g3:229:2: (~ '=' (~ ';' )* )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:229:4: ~ '=' (~ ';' )*
			{
			DebugLocation(229, 4);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='<')||(input.LA(1)>='>' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(229, 9);
			// Grammars\\ActionTranslator.g3:229:9: (~ ';' )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if (((LA19_1>='\u0000' && LA19_1<=':')||(LA19_1>='<' && LA19_1<='\uFFFF')))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:
					{
					DebugLocation(229, 9);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

		}
		finally
		{
			TraceOut("ATTR_VALUE_EXPR", 24);
			LeaveRule("ATTR_VALUE_EXPR", 24);
			LeaveRule_ATTR_VALUE_EXPR();
		}
	}
	// $ANTLR end "ATTR_VALUE_EXPR"

	partial void EnterRule_TEMPLATE_EXPR();
	partial void LeaveRule_TEMPLATE_EXPR();

	// $ANTLR start "TEMPLATE_EXPR"
	[GrammarRule("TEMPLATE_EXPR")]
	private void mTEMPLATE_EXPR()
	{
		EnterRule_TEMPLATE_EXPR();
		EnterRule("TEMPLATE_EXPR", 25);
		TraceIn("TEMPLATE_EXPR", 25);
		try
		{
			int _type = TEMPLATE_EXPR;
			int _channel = DefaultTokenChannel;
			CommonToken ACTION8 = default(CommonToken);

			// Grammars\\ActionTranslator.g3:234:2: ( '%' ACTION )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:234:4: '%' ACTION
			{
			DebugLocation(234, 4);
			Match('%'); if (state.failed) return;
			DebugLocation(234, 8);
			int ACTION8Start775 = CharIndex;
			int ACTION8StartLine775 = Line;
			int ACTION8StartCharPos775 = CharPositionInLine;
			mACTION(); if (state.failed) return;
			ACTION8 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ACTION8Start775, CharIndex-1);
			ACTION8.Line = ACTION8StartLine775;
			ACTION8.CharPositionInLine = ACTION8StartCharPos775;
			DebugLocation(235, 3);
			if (state.backtracking == 1)
			{
				HandleTemplateExpression((ACTION8!=null?ACTION8.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TEMPLATE_EXPR", 25);
			LeaveRule("TEMPLATE_EXPR", 25);
			LeaveRule_TEMPLATE_EXPR();
		}
	}
	// $ANTLR end "TEMPLATE_EXPR"

	partial void EnterRule_ACTION();
	partial void LeaveRule_ACTION();

	// $ANTLR start "ACTION"
	[GrammarRule("ACTION")]
	private void mACTION()
	{
		EnterRule_ACTION();
		EnterRule("ACTION", 26);
		TraceIn("ACTION", 26);
		try
		{
			// Grammars\\ActionTranslator.g3:240:2: ( '{' ( options {greedy=false; } : . )* '}' )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:240:4: '{' ( options {greedy=false; } : . )* '}'
			{
			DebugLocation(240, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(240, 8);
			// Grammars\\ActionTranslator.g3:240:8: ( options {greedy=false; } : . )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1=='}'))
				{
					alt20 = 2;
				}
				else if (((LA20_1>='\u0000' && LA20_1<='|')||(LA20_1>='~' && LA20_1<='\uFFFF')))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:240:33: .
					{
					DebugLocation(240, 33);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(240, 37);
			Match('}'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ACTION", 26);
			LeaveRule("ACTION", 26);
			LeaveRule_ACTION();
		}
	}
	// $ANTLR end "ACTION"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	private void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 27);
		TraceIn("ESC", 27);
		try
		{
			int _type = ESC;
			int _channel = DefaultTokenChannel;
			int c = 0;

			// Grammars\\ActionTranslator.g3:244:2: ( '\\\\' c= . )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:244:4: '\\\\' c= .
			{
			DebugLocation(244, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(244, 10);

			c = input.LA(1);

			MatchAny(); if (state.failed) return;
			DebugLocation(244, 13);
			if (state.backtracking == 1)
			{
				HandleEscape((char)c);
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ESC", 27);
			LeaveRule("ESC", 27);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_ERROR_XY();
	partial void LeaveRule_ERROR_XY();

	// $ANTLR start "ERROR_XY"
	[GrammarRule("ERROR_XY")]
	private void mERROR_XY()
	{
		EnterRule_ERROR_XY();
		EnterRule("ERROR_XY", 28);
		TraceIn("ERROR_XY", 28);
		try
		{
			int _type = ERROR_XY;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);
			CommonToken y = default(CommonToken);

			// Grammars\\ActionTranslator.g3:248:2: ( '$' x= ID '.' y= ID )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:248:4: '$' x= ID '.' y= ID
			{
			DebugLocation(248, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(248, 9);
			int xStart840 = CharIndex;
			int xStartLine840 = Line;
			int xStartCharPos840 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart840, CharIndex-1);
			x.Line = xStartLine840;
			x.CharPositionInLine = xStartCharPos840;
			DebugLocation(248, 13);
			Match('.'); if (state.failed) return;
			DebugLocation(248, 18);
			int yStart846 = CharIndex;
			int yStartLine846 = Line;
			int yStartCharPos846 = CharPositionInLine;
			mID(); if (state.failed) return;
			y = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, yStart846, CharIndex-1);
			y.Line = yStartLine846;
			y.CharPositionInLine = yStartCharPos846;
			DebugLocation(249, 3);
			if (state.backtracking == 1)
			{
				HandleErrorXY((x!=null?x.Text:default(string)), (y!=null?y.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ERROR_XY", 28);
			LeaveRule("ERROR_XY", 28);
			LeaveRule_ERROR_XY();
		}
	}
	// $ANTLR end "ERROR_XY"

	partial void EnterRule_ERROR_X();
	partial void LeaveRule_ERROR_X();

	// $ANTLR start "ERROR_X"
	[GrammarRule("ERROR_X")]
	private void mERROR_X()
	{
		EnterRule_ERROR_X();
		EnterRule("ERROR_X", 29);
		TraceIn("ERROR_X", 29);
		try
		{
			int _type = ERROR_X;
			int _channel = DefaultTokenChannel;
			CommonToken x = default(CommonToken);

			// Grammars\\ActionTranslator.g3:253:2: ( '$' x= ID )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:253:4: '$' x= ID
			{
			DebugLocation(253, 4);
			Match('$'); if (state.failed) return;
			DebugLocation(253, 9);
			int xStart866 = CharIndex;
			int xStartLine866 = Line;
			int xStartCharPos866 = CharPositionInLine;
			mID(); if (state.failed) return;
			x = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, xStart866, CharIndex-1);
			x.Line = xStartLine866;
			x.CharPositionInLine = xStartCharPos866;
			DebugLocation(254, 3);
			if (state.backtracking == 1)
			{
				HandleErrorX((x!=null?x.Text:default(string)));
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ERROR_X", 29);
			LeaveRule("ERROR_X", 29);
			LeaveRule_ERROR_X();
		}
	}
	// $ANTLR end "ERROR_X"

	partial void EnterRule_UNKNOWN_SYNTAX();
	partial void LeaveRule_UNKNOWN_SYNTAX();

	// $ANTLR start "UNKNOWN_SYNTAX"
	[GrammarRule("UNKNOWN_SYNTAX")]
	private void mUNKNOWN_SYNTAX()
	{
		EnterRule_UNKNOWN_SYNTAX();
		EnterRule("UNKNOWN_SYNTAX", 30);
		TraceIn("UNKNOWN_SYNTAX", 30);
		try
		{
			int _type = UNKNOWN_SYNTAX;
			int _channel = DefaultTokenChannel;
			// Grammars\\ActionTranslator.g3:258:2: ( '$' | '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )* )
			int alt22=2;
			try { DebugEnterDecision(22, false);
			int LA22_1 = input.LA(1);

			if ((LA22_1=='$'))
			{
				alt22 = 1;
			}
			else if ((LA22_1=='%'))
			{
				alt22 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:258:4: '$'
				{
				DebugLocation(258, 4);
				Match('$'); if (state.failed) return;
				DebugLocation(259, 3);
				if (state.backtracking == 1)
				{
					HandleUnknownAttributeSyntax();
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\ActionTranslator.g3:260:4: '%' ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
				{
				DebugLocation(260, 4);
				Match('%'); if (state.failed) return;
				DebugLocation(260, 8);
				// Grammars\\ActionTranslator.g3:260:8: ( ID | '.' | '(' | ')' | ',' | '{' | '}' | '\"' )*
				try { DebugEnterSubRule(21);
				while (true)
				{
					int alt21=9;
					try { DebugEnterDecision(21, false);
					switch (input.LA(1))
					{
					case '@':
					case 'A':
					case 'B':
					case 'C':
					case 'D':
					case 'E':
					case 'F':
					case 'G':
					case 'H':
					case 'I':
					case 'J':
					case 'K':
					case 'L':
					case 'M':
					case 'N':
					case 'O':
					case 'P':
					case 'Q':
					case 'R':
					case 'S':
					case 'T':
					case 'U':
					case 'V':
					case 'W':
					case 'X':
					case 'Y':
					case 'Z':
					case '_':
					case 'a':
					case 'b':
					case 'c':
					case 'd':
					case 'e':
					case 'f':
					case 'g':
					case 'h':
					case 'i':
					case 'j':
					case 'k':
					case 'l':
					case 'm':
					case 'n':
					case 'o':
					case 'p':
					case 'q':
					case 'r':
					case 's':
					case 't':
					case 'u':
					case 'v':
					case 'w':
					case 'x':
					case 'y':
					case 'z':
						{
						alt21 = 1;
						}
						break;
					case '.':
						{
						alt21 = 2;
						}
						break;
					case '(':
						{
						alt21 = 3;
						}
						break;
					case ')':
						{
						alt21 = 4;
						}
						break;
					case ',':
						{
						alt21 = 5;
						}
						break;
					case '{':
						{
						alt21 = 6;
						}
						break;
					case '}':
						{
						alt21 = 7;
						}
						break;
					case '\"':
						{
						alt21 = 8;
						}
						break;
					}

					} finally { DebugExitDecision(21); }
					switch ( alt21 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\ActionTranslator.g3:260:9: ID
						{
						DebugLocation(260, 9);
						mID(); if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\ActionTranslator.g3:260:12: '.'
						{
						DebugLocation(260, 12);
						Match('.'); if (state.failed) return;

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Grammars\\ActionTranslator.g3:260:16: '('
						{
						DebugLocation(260, 16);
						Match('('); if (state.failed) return;

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Grammars\\ActionTranslator.g3:260:20: ')'
						{
						DebugLocation(260, 20);
						Match(')'); if (state.failed) return;

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// Grammars\\ActionTranslator.g3:260:24: ','
						{
						DebugLocation(260, 24);
						Match(','); if (state.failed) return;

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// Grammars\\ActionTranslator.g3:260:28: '{'
						{
						DebugLocation(260, 28);
						Match('{'); if (state.failed) return;

						}
						break;
					case 7:
						DebugEnterAlt(7);
						// Grammars\\ActionTranslator.g3:260:32: '}'
						{
						DebugLocation(260, 32);
						Match('}'); if (state.failed) return;

						}
						break;
					case 8:
						DebugEnterAlt(8);
						// Grammars\\ActionTranslator.g3:260:36: '\"'
						{
						DebugLocation(260, 36);
						Match('\"'); if (state.failed) return;

						}
						break;

					default:
						goto loop21;
					}
				}

				loop21:
					;

				} finally { DebugExitSubRule(21); }

				DebugLocation(261, 3);
				if (state.backtracking == 1)
				{
					HandleUnknownTemplateSyntax();
				}

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNKNOWN_SYNTAX", 30);
			LeaveRule("UNKNOWN_SYNTAX", 30);
			LeaveRule_UNKNOWN_SYNTAX();
		}
	}
	// $ANTLR end "UNKNOWN_SYNTAX"

	partial void EnterRule_TEXT();
	partial void LeaveRule_TEXT();

	// $ANTLR start "TEXT"
	[GrammarRule("TEXT")]
	private void mTEXT()
	{
		EnterRule_TEXT();
		EnterRule("TEXT", 31);
		TraceIn("TEXT", 31);
		try
		{
			int _type = TEXT;
			int _channel = DefaultTokenChannel;
			// Grammars\\ActionTranslator.g3:265:2: ( (~ ( '$' | '%' | '\\\\' ) )+ )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:265:4: (~ ( '$' | '%' | '\\\\' ) )+
			{
			DebugLocation(265, 4);
			// Grammars\\ActionTranslator.g3:265:4: (~ ( '$' | '%' | '\\\\' ) )+
			int cnt23=0;
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if (((LA23_1>='\u0000' && LA23_1<='#')||(LA23_1>='&' && LA23_1<='[')||(LA23_1>=']' && LA23_1<='\uFFFF')))
				{
					alt23 = 1;
				}


				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:
					{
					DebugLocation(265, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt23 >= 1)
						goto loop23;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee23 = new EarlyExitException( 23, input );
					DebugRecognitionException(eee23);
					throw eee23;
				}
				cnt23++;
			}
			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(265, 21);
			if (state.backtracking == 1)
			{
				HandleText();
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TEXT", 31);
			LeaveRule("TEXT", 31);
			LeaveRule_TEXT();
		}
	}
	// $ANTLR end "TEXT"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 32);
		TraceIn("ID", 32);
		try
		{
			// Grammars\\ActionTranslator.g3:270:2: ( ( '@' )? ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:270:4: ( '@' )? ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			{
			DebugLocation(270, 4);
			// Grammars\\ActionTranslator.g3:270:4: ( '@' )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1=='@'))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\ActionTranslator.g3:270:4: '@'
				{
				DebugLocation(270, 4);
				Match('@'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(270, 9);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(270, 33);
			// Grammars\\ActionTranslator.g3:270:33: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if (((LA25_1>='0' && LA25_1<='9')||(LA25_1>='A' && LA25_1<='Z')||LA25_1=='_'||(LA25_1>='a' && LA25_1<='z')))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:
					{
					DebugLocation(270, 33);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

		}
		finally
		{
			TraceOut("ID", 32);
			LeaveRule("ID", 32);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 33);
		TraceIn("INT", 33);
		try
		{
			// Grammars\\ActionTranslator.g3:275:2: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:275:4: ( '0' .. '9' )+
			{
			DebugLocation(275, 7);
			// Grammars\\ActionTranslator.g3:275:7: ( '0' .. '9' )+
			int cnt26=0;
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if (((LA26_1>='0' && LA26_1<='9')))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:
					{
					DebugLocation(275, 7);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt26 >= 1)
						goto loop26;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee26 = new EarlyExitException( 26, input );
					DebugRecognitionException(eee26);
					throw eee26;
				}
				cnt26++;
			}
			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

		}
		finally
		{
			TraceOut("INT", 33);
			LeaveRule("INT", 33);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 34);
		TraceIn("WS", 34);
		try
		{
			// Grammars\\ActionTranslator.g3:280:2: ( ( ' ' | '\\t' | '\\n' | '\\r' )+ )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:280:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
			{
			DebugLocation(280, 4);
			// Grammars\\ActionTranslator.g3:280:4: ( ' ' | '\\t' | '\\n' | '\\r' )+
			int cnt27=0;
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if (((LA27_1>='\t' && LA27_1<='\n')||LA27_1=='\r'||LA27_1==' '))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\ActionTranslator.g3:
					{
					DebugLocation(280, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt27 >= 1)
						goto loop27;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee27 = new EarlyExitException( 27, input );
					DebugRecognitionException(eee27);
					throw eee27;
				}
				cnt27++;
			}
			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

		}
		finally
		{
			TraceOut("WS", 34);
			LeaveRule("WS", 34);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// Grammars\\ActionTranslator.g3:1:39: ( SET_ENCLOSING_RULE_SCOPE_ATTR | ENCLOSING_RULE_SCOPE_ATTR | SET_TOKEN_SCOPE_ATTR | TOKEN_SCOPE_ATTR | SET_RULE_SCOPE_ATTR | RULE_SCOPE_ATTR | LABEL_REF | ISOLATED_TOKEN_REF | ISOLATED_LEXER_RULE_REF | SET_LOCAL_ATTR | LOCAL_ATTR | SET_DYNAMIC_SCOPE_ATTR | DYNAMIC_SCOPE_ATTR | ERROR_SCOPED_XY | DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR | DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR | ISOLATED_DYNAMIC_SCOPE | TEMPLATE_INSTANCE | INDIRECT_TEMPLATE_INSTANCE | SET_EXPR_ATTRIBUTE | SET_ATTRIBUTE | TEMPLATE_EXPR | ESC | ERROR_XY | ERROR_X | UNKNOWN_SYNTAX | TEXT )
		int alt28=27;
		try { DebugEnterDecision(28, false);
		int LA28_1 = input.LA(1);

		if ((LA28_1=='$'))
		{
			int LA28_2 = input.LA(2);

			if ((EvaluatePredicate(synpred1_ActionTranslator_fragment)))
			{
				alt28 = 1;
			}
			else if ((EvaluatePredicate(synpred2_ActionTranslator_fragment)))
			{
				alt28 = 2;
			}
			else if ((EvaluatePredicate(synpred3_ActionTranslator_fragment)))
			{
				alt28 = 3;
			}
			else if ((EvaluatePredicate(synpred4_ActionTranslator_fragment)))
			{
				alt28 = 4;
			}
			else if ((EvaluatePredicate(synpred5_ActionTranslator_fragment)))
			{
				alt28 = 5;
			}
			else if ((EvaluatePredicate(synpred6_ActionTranslator_fragment)))
			{
				alt28 = 6;
			}
			else if ((EvaluatePredicate(synpred7_ActionTranslator_fragment)))
			{
				alt28 = 7;
			}
			else if ((EvaluatePredicate(synpred8_ActionTranslator_fragment)))
			{
				alt28 = 8;
			}
			else if ((EvaluatePredicate(synpred9_ActionTranslator_fragment)))
			{
				alt28 = 9;
			}
			else if ((EvaluatePredicate(synpred10_ActionTranslator_fragment)))
			{
				alt28 = 10;
			}
			else if ((EvaluatePredicate(synpred11_ActionTranslator_fragment)))
			{
				alt28 = 11;
			}
			else if ((EvaluatePredicate(synpred12_ActionTranslator_fragment)))
			{
				alt28 = 12;
			}
			else if ((EvaluatePredicate(synpred13_ActionTranslator_fragment)))
			{
				alt28 = 13;
			}
			else if ((EvaluatePredicate(synpred14_ActionTranslator_fragment)))
			{
				alt28 = 14;
			}
			else if ((EvaluatePredicate(synpred15_ActionTranslator_fragment)))
			{
				alt28 = 15;
			}
			else if ((EvaluatePredicate(synpred16_ActionTranslator_fragment)))
			{
				alt28 = 16;
			}
			else if ((EvaluatePredicate(synpred17_ActionTranslator_fragment)))
			{
				alt28 = 17;
			}
			else if ((EvaluatePredicate(synpred24_ActionTranslator_fragment)))
			{
				alt28 = 24;
			}
			else if ((EvaluatePredicate(synpred25_ActionTranslator_fragment)))
			{
				alt28 = 25;
			}
			else if ((EvaluatePredicate(synpred26_ActionTranslator_fragment)))
			{
				alt28 = 26;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 28, 1, input, 2);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}
		else if ((LA28_1=='%'))
		{
			int LA28_2 = input.LA(2);

			if ((EvaluatePredicate(synpred18_ActionTranslator_fragment)))
			{
				alt28 = 18;
			}
			else if ((EvaluatePredicate(synpred19_ActionTranslator_fragment)))
			{
				alt28 = 19;
			}
			else if ((EvaluatePredicate(synpred20_ActionTranslator_fragment)))
			{
				alt28 = 20;
			}
			else if ((EvaluatePredicate(synpred21_ActionTranslator_fragment)))
			{
				alt28 = 21;
			}
			else if ((EvaluatePredicate(synpred22_ActionTranslator_fragment)))
			{
				alt28 = 22;
			}
			else if ((EvaluatePredicate(synpred26_ActionTranslator_fragment)))
			{
				alt28 = 26;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 28, 22, input, 2);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}
		else if ((LA28_1=='\\'))
		{
			alt28 = 23;
		}
		else if (((LA28_1>='\u0000' && LA28_1<='#')||(LA28_1>='&' && LA28_1<='[')||(LA28_1>=']' && LA28_1<='\uFFFF')))
		{
			alt28 = 27;
		}
		else
		{
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
			DebugRecognitionException(nvae);
			throw nvae;
		}
		} finally { DebugExitDecision(28); }
		switch (alt28)
		{
		case 1:
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
			{
			DebugLocation(1, 41);
			mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Grammars\\ActionTranslator.g3:1:71: ENCLOSING_RULE_SCOPE_ATTR
			{
			DebugLocation(1, 71);
			mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Grammars\\ActionTranslator.g3:1:97: SET_TOKEN_SCOPE_ATTR
			{
			DebugLocation(1, 97);
			mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Grammars\\ActionTranslator.g3:1:118: TOKEN_SCOPE_ATTR
			{
			DebugLocation(1, 118);
			mTOKEN_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Grammars\\ActionTranslator.g3:1:135: SET_RULE_SCOPE_ATTR
			{
			DebugLocation(1, 135);
			mSET_RULE_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Grammars\\ActionTranslator.g3:1:155: RULE_SCOPE_ATTR
			{
			DebugLocation(1, 155);
			mRULE_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Grammars\\ActionTranslator.g3:1:171: LABEL_REF
			{
			DebugLocation(1, 171);
			mLABEL_REF(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Grammars\\ActionTranslator.g3:1:181: ISOLATED_TOKEN_REF
			{
			DebugLocation(1, 181);
			mISOLATED_TOKEN_REF(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Grammars\\ActionTranslator.g3:1:200: ISOLATED_LEXER_RULE_REF
			{
			DebugLocation(1, 200);
			mISOLATED_LEXER_RULE_REF(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Grammars\\ActionTranslator.g3:1:224: SET_LOCAL_ATTR
			{
			DebugLocation(1, 224);
			mSET_LOCAL_ATTR(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Grammars\\ActionTranslator.g3:1:239: LOCAL_ATTR
			{
			DebugLocation(1, 239);
			mLOCAL_ATTR(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Grammars\\ActionTranslator.g3:1:250: SET_DYNAMIC_SCOPE_ATTR
			{
			DebugLocation(1, 250);
			mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Grammars\\ActionTranslator.g3:1:273: DYNAMIC_SCOPE_ATTR
			{
			DebugLocation(1, 273);
			mDYNAMIC_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Grammars\\ActionTranslator.g3:1:292: ERROR_SCOPED_XY
			{
			DebugLocation(1, 292);
			mERROR_SCOPED_XY(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Grammars\\ActionTranslator.g3:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
			{
			DebugLocation(1, 308);
			mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Grammars\\ActionTranslator.g3:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
			{
			DebugLocation(1, 344);
			mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Grammars\\ActionTranslator.g3:1:380: ISOLATED_DYNAMIC_SCOPE
			{
			DebugLocation(1, 380);
			mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Grammars\\ActionTranslator.g3:1:403: TEMPLATE_INSTANCE
			{
			DebugLocation(1, 403);
			mTEMPLATE_INSTANCE(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Grammars\\ActionTranslator.g3:1:421: INDIRECT_TEMPLATE_INSTANCE
			{
			DebugLocation(1, 421);
			mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Grammars\\ActionTranslator.g3:1:448: SET_EXPR_ATTRIBUTE
			{
			DebugLocation(1, 448);
			mSET_EXPR_ATTRIBUTE(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Grammars\\ActionTranslator.g3:1:467: SET_ATTRIBUTE
			{
			DebugLocation(1, 467);
			mSET_ATTRIBUTE(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Grammars\\ActionTranslator.g3:1:481: TEMPLATE_EXPR
			{
			DebugLocation(1, 481);
			mTEMPLATE_EXPR(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Grammars\\ActionTranslator.g3:1:495: ESC
			{
			DebugLocation(1, 495);
			mESC(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Grammars\\ActionTranslator.g3:1:499: ERROR_XY
			{
			DebugLocation(1, 499);
			mERROR_XY(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Grammars\\ActionTranslator.g3:1:508: ERROR_X
			{
			DebugLocation(1, 508);
			mERROR_X(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Grammars\\ActionTranslator.g3:1:516: UNKNOWN_SYNTAX
			{
			DebugLocation(1, 516);
			mUNKNOWN_SYNTAX(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Grammars\\ActionTranslator.g3:1:531: TEXT
			{
			DebugLocation(1, 531);
			mTEXT(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_ActionTranslator_fragment();
	partial void LeaveRule_synpred1_ActionTranslator_fragment();

	// $ANTLR start synpred1_ActionTranslator
	private void synpred1_ActionTranslator_fragment()
	{
		EnterRule_synpred1_ActionTranslator_fragment();
		EnterRule("synpred1_ActionTranslator_fragment", 36);
		TraceIn("synpred1_ActionTranslator_fragment", 36);
		try
		{
			// Grammars\\ActionTranslator.g3:1:41: ( SET_ENCLOSING_RULE_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:41: SET_ENCLOSING_RULE_SCOPE_ATTR
			{
			DebugLocation(1, 41);
			mSET_ENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_ActionTranslator_fragment", 36);
			LeaveRule("synpred1_ActionTranslator_fragment", 36);
			LeaveRule_synpred1_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred1_ActionTranslator

	partial void EnterRule_synpred2_ActionTranslator_fragment();
	partial void LeaveRule_synpred2_ActionTranslator_fragment();

	// $ANTLR start synpred2_ActionTranslator
	private void synpred2_ActionTranslator_fragment()
	{
		EnterRule_synpred2_ActionTranslator_fragment();
		EnterRule("synpred2_ActionTranslator_fragment", 37);
		TraceIn("synpred2_ActionTranslator_fragment", 37);
		try
		{
			// Grammars\\ActionTranslator.g3:1:71: ( ENCLOSING_RULE_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:71: ENCLOSING_RULE_SCOPE_ATTR
			{
			DebugLocation(1, 71);
			mENCLOSING_RULE_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_ActionTranslator_fragment", 37);
			LeaveRule("synpred2_ActionTranslator_fragment", 37);
			LeaveRule_synpred2_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred2_ActionTranslator

	partial void EnterRule_synpred3_ActionTranslator_fragment();
	partial void LeaveRule_synpred3_ActionTranslator_fragment();

	// $ANTLR start synpred3_ActionTranslator
	private void synpred3_ActionTranslator_fragment()
	{
		EnterRule_synpred3_ActionTranslator_fragment();
		EnterRule("synpred3_ActionTranslator_fragment", 38);
		TraceIn("synpred3_ActionTranslator_fragment", 38);
		try
		{
			// Grammars\\ActionTranslator.g3:1:97: ( SET_TOKEN_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:97: SET_TOKEN_SCOPE_ATTR
			{
			DebugLocation(1, 97);
			mSET_TOKEN_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_ActionTranslator_fragment", 38);
			LeaveRule("synpred3_ActionTranslator_fragment", 38);
			LeaveRule_synpred3_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred3_ActionTranslator

	partial void EnterRule_synpred4_ActionTranslator_fragment();
	partial void LeaveRule_synpred4_ActionTranslator_fragment();

	// $ANTLR start synpred4_ActionTranslator
	private void synpred4_ActionTranslator_fragment()
	{
		EnterRule_synpred4_ActionTranslator_fragment();
		EnterRule("synpred4_ActionTranslator_fragment", 39);
		TraceIn("synpred4_ActionTranslator_fragment", 39);
		try
		{
			// Grammars\\ActionTranslator.g3:1:118: ( TOKEN_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:118: TOKEN_SCOPE_ATTR
			{
			DebugLocation(1, 118);
			mTOKEN_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_ActionTranslator_fragment", 39);
			LeaveRule("synpred4_ActionTranslator_fragment", 39);
			LeaveRule_synpred4_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred4_ActionTranslator

	partial void EnterRule_synpred5_ActionTranslator_fragment();
	partial void LeaveRule_synpred5_ActionTranslator_fragment();

	// $ANTLR start synpred5_ActionTranslator
	private void synpred5_ActionTranslator_fragment()
	{
		EnterRule_synpred5_ActionTranslator_fragment();
		EnterRule("synpred5_ActionTranslator_fragment", 40);
		TraceIn("synpred5_ActionTranslator_fragment", 40);
		try
		{
			// Grammars\\ActionTranslator.g3:1:135: ( SET_RULE_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:135: SET_RULE_SCOPE_ATTR
			{
			DebugLocation(1, 135);
			mSET_RULE_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_ActionTranslator_fragment", 40);
			LeaveRule("synpred5_ActionTranslator_fragment", 40);
			LeaveRule_synpred5_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred5_ActionTranslator

	partial void EnterRule_synpred6_ActionTranslator_fragment();
	partial void LeaveRule_synpred6_ActionTranslator_fragment();

	// $ANTLR start synpred6_ActionTranslator
	private void synpred6_ActionTranslator_fragment()
	{
		EnterRule_synpred6_ActionTranslator_fragment();
		EnterRule("synpred6_ActionTranslator_fragment", 41);
		TraceIn("synpred6_ActionTranslator_fragment", 41);
		try
		{
			// Grammars\\ActionTranslator.g3:1:155: ( RULE_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:155: RULE_SCOPE_ATTR
			{
			DebugLocation(1, 155);
			mRULE_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_ActionTranslator_fragment", 41);
			LeaveRule("synpred6_ActionTranslator_fragment", 41);
			LeaveRule_synpred6_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred6_ActionTranslator

	partial void EnterRule_synpred7_ActionTranslator_fragment();
	partial void LeaveRule_synpred7_ActionTranslator_fragment();

	// $ANTLR start synpred7_ActionTranslator
	private void synpred7_ActionTranslator_fragment()
	{
		EnterRule_synpred7_ActionTranslator_fragment();
		EnterRule("synpred7_ActionTranslator_fragment", 42);
		TraceIn("synpred7_ActionTranslator_fragment", 42);
		try
		{
			// Grammars\\ActionTranslator.g3:1:171: ( LABEL_REF )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:171: LABEL_REF
			{
			DebugLocation(1, 171);
			mLABEL_REF(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_ActionTranslator_fragment", 42);
			LeaveRule("synpred7_ActionTranslator_fragment", 42);
			LeaveRule_synpred7_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred7_ActionTranslator

	partial void EnterRule_synpred8_ActionTranslator_fragment();
	partial void LeaveRule_synpred8_ActionTranslator_fragment();

	// $ANTLR start synpred8_ActionTranslator
	private void synpred8_ActionTranslator_fragment()
	{
		EnterRule_synpred8_ActionTranslator_fragment();
		EnterRule("synpred8_ActionTranslator_fragment", 43);
		TraceIn("synpred8_ActionTranslator_fragment", 43);
		try
		{
			// Grammars\\ActionTranslator.g3:1:181: ( ISOLATED_TOKEN_REF )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:181: ISOLATED_TOKEN_REF
			{
			DebugLocation(1, 181);
			mISOLATED_TOKEN_REF(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_ActionTranslator_fragment", 43);
			LeaveRule("synpred8_ActionTranslator_fragment", 43);
			LeaveRule_synpred8_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred8_ActionTranslator

	partial void EnterRule_synpred9_ActionTranslator_fragment();
	partial void LeaveRule_synpred9_ActionTranslator_fragment();

	// $ANTLR start synpred9_ActionTranslator
	private void synpred9_ActionTranslator_fragment()
	{
		EnterRule_synpred9_ActionTranslator_fragment();
		EnterRule("synpred9_ActionTranslator_fragment", 44);
		TraceIn("synpred9_ActionTranslator_fragment", 44);
		try
		{
			// Grammars\\ActionTranslator.g3:1:200: ( ISOLATED_LEXER_RULE_REF )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:200: ISOLATED_LEXER_RULE_REF
			{
			DebugLocation(1, 200);
			mISOLATED_LEXER_RULE_REF(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_ActionTranslator_fragment", 44);
			LeaveRule("synpred9_ActionTranslator_fragment", 44);
			LeaveRule_synpred9_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred9_ActionTranslator

	partial void EnterRule_synpred10_ActionTranslator_fragment();
	partial void LeaveRule_synpred10_ActionTranslator_fragment();

	// $ANTLR start synpred10_ActionTranslator
	private void synpred10_ActionTranslator_fragment()
	{
		EnterRule_synpred10_ActionTranslator_fragment();
		EnterRule("synpred10_ActionTranslator_fragment", 45);
		TraceIn("synpred10_ActionTranslator_fragment", 45);
		try
		{
			// Grammars\\ActionTranslator.g3:1:224: ( SET_LOCAL_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:224: SET_LOCAL_ATTR
			{
			DebugLocation(1, 224);
			mSET_LOCAL_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_ActionTranslator_fragment", 45);
			LeaveRule("synpred10_ActionTranslator_fragment", 45);
			LeaveRule_synpred10_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred10_ActionTranslator

	partial void EnterRule_synpred11_ActionTranslator_fragment();
	partial void LeaveRule_synpred11_ActionTranslator_fragment();

	// $ANTLR start synpred11_ActionTranslator
	private void synpred11_ActionTranslator_fragment()
	{
		EnterRule_synpred11_ActionTranslator_fragment();
		EnterRule("synpred11_ActionTranslator_fragment", 46);
		TraceIn("synpred11_ActionTranslator_fragment", 46);
		try
		{
			// Grammars\\ActionTranslator.g3:1:239: ( LOCAL_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:239: LOCAL_ATTR
			{
			DebugLocation(1, 239);
			mLOCAL_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_ActionTranslator_fragment", 46);
			LeaveRule("synpred11_ActionTranslator_fragment", 46);
			LeaveRule_synpred11_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred11_ActionTranslator

	partial void EnterRule_synpred12_ActionTranslator_fragment();
	partial void LeaveRule_synpred12_ActionTranslator_fragment();

	// $ANTLR start synpred12_ActionTranslator
	private void synpred12_ActionTranslator_fragment()
	{
		EnterRule_synpred12_ActionTranslator_fragment();
		EnterRule("synpred12_ActionTranslator_fragment", 47);
		TraceIn("synpred12_ActionTranslator_fragment", 47);
		try
		{
			// Grammars\\ActionTranslator.g3:1:250: ( SET_DYNAMIC_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:250: SET_DYNAMIC_SCOPE_ATTR
			{
			DebugLocation(1, 250);
			mSET_DYNAMIC_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred12_ActionTranslator_fragment", 47);
			LeaveRule("synpred12_ActionTranslator_fragment", 47);
			LeaveRule_synpred12_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred12_ActionTranslator

	partial void EnterRule_synpred13_ActionTranslator_fragment();
	partial void LeaveRule_synpred13_ActionTranslator_fragment();

	// $ANTLR start synpred13_ActionTranslator
	private void synpred13_ActionTranslator_fragment()
	{
		EnterRule_synpred13_ActionTranslator_fragment();
		EnterRule("synpred13_ActionTranslator_fragment", 48);
		TraceIn("synpred13_ActionTranslator_fragment", 48);
		try
		{
			// Grammars\\ActionTranslator.g3:1:273: ( DYNAMIC_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:273: DYNAMIC_SCOPE_ATTR
			{
			DebugLocation(1, 273);
			mDYNAMIC_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_ActionTranslator_fragment", 48);
			LeaveRule("synpred13_ActionTranslator_fragment", 48);
			LeaveRule_synpred13_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred13_ActionTranslator

	partial void EnterRule_synpred14_ActionTranslator_fragment();
	partial void LeaveRule_synpred14_ActionTranslator_fragment();

	// $ANTLR start synpred14_ActionTranslator
	private void synpred14_ActionTranslator_fragment()
	{
		EnterRule_synpred14_ActionTranslator_fragment();
		EnterRule("synpred14_ActionTranslator_fragment", 49);
		TraceIn("synpred14_ActionTranslator_fragment", 49);
		try
		{
			// Grammars\\ActionTranslator.g3:1:292: ( ERROR_SCOPED_XY )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:292: ERROR_SCOPED_XY
			{
			DebugLocation(1, 292);
			mERROR_SCOPED_XY(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred14_ActionTranslator_fragment", 49);
			LeaveRule("synpred14_ActionTranslator_fragment", 49);
			LeaveRule_synpred14_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred14_ActionTranslator

	partial void EnterRule_synpred15_ActionTranslator_fragment();
	partial void LeaveRule_synpred15_ActionTranslator_fragment();

	// $ANTLR start synpred15_ActionTranslator
	private void synpred15_ActionTranslator_fragment()
	{
		EnterRule_synpred15_ActionTranslator_fragment();
		EnterRule("synpred15_ActionTranslator_fragment", 50);
		TraceIn("synpred15_ActionTranslator_fragment", 50);
		try
		{
			// Grammars\\ActionTranslator.g3:1:308: ( DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:308: DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
			{
			DebugLocation(1, 308);
			mDYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred15_ActionTranslator_fragment", 50);
			LeaveRule("synpred15_ActionTranslator_fragment", 50);
			LeaveRule_synpred15_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred15_ActionTranslator

	partial void EnterRule_synpred16_ActionTranslator_fragment();
	partial void LeaveRule_synpred16_ActionTranslator_fragment();

	// $ANTLR start synpred16_ActionTranslator
	private void synpred16_ActionTranslator_fragment()
	{
		EnterRule_synpred16_ActionTranslator_fragment();
		EnterRule("synpred16_ActionTranslator_fragment", 51);
		TraceIn("synpred16_ActionTranslator_fragment", 51);
		try
		{
			// Grammars\\ActionTranslator.g3:1:344: ( DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:344: DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
			{
			DebugLocation(1, 344);
			mDYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_ActionTranslator_fragment", 51);
			LeaveRule("synpred16_ActionTranslator_fragment", 51);
			LeaveRule_synpred16_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred16_ActionTranslator

	partial void EnterRule_synpred17_ActionTranslator_fragment();
	partial void LeaveRule_synpred17_ActionTranslator_fragment();

	// $ANTLR start synpred17_ActionTranslator
	private void synpred17_ActionTranslator_fragment()
	{
		EnterRule_synpred17_ActionTranslator_fragment();
		EnterRule("synpred17_ActionTranslator_fragment", 52);
		TraceIn("synpred17_ActionTranslator_fragment", 52);
		try
		{
			// Grammars\\ActionTranslator.g3:1:380: ( ISOLATED_DYNAMIC_SCOPE )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:380: ISOLATED_DYNAMIC_SCOPE
			{
			DebugLocation(1, 380);
			mISOLATED_DYNAMIC_SCOPE(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred17_ActionTranslator_fragment", 52);
			LeaveRule("synpred17_ActionTranslator_fragment", 52);
			LeaveRule_synpred17_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred17_ActionTranslator

	partial void EnterRule_synpred18_ActionTranslator_fragment();
	partial void LeaveRule_synpred18_ActionTranslator_fragment();

	// $ANTLR start synpred18_ActionTranslator
	private void synpred18_ActionTranslator_fragment()
	{
		EnterRule_synpred18_ActionTranslator_fragment();
		EnterRule("synpred18_ActionTranslator_fragment", 53);
		TraceIn("synpred18_ActionTranslator_fragment", 53);
		try
		{
			// Grammars\\ActionTranslator.g3:1:403: ( TEMPLATE_INSTANCE )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:403: TEMPLATE_INSTANCE
			{
			DebugLocation(1, 403);
			mTEMPLATE_INSTANCE(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred18_ActionTranslator_fragment", 53);
			LeaveRule("synpred18_ActionTranslator_fragment", 53);
			LeaveRule_synpred18_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred18_ActionTranslator

	partial void EnterRule_synpred19_ActionTranslator_fragment();
	partial void LeaveRule_synpred19_ActionTranslator_fragment();

	// $ANTLR start synpred19_ActionTranslator
	private void synpred19_ActionTranslator_fragment()
	{
		EnterRule_synpred19_ActionTranslator_fragment();
		EnterRule("synpred19_ActionTranslator_fragment", 54);
		TraceIn("synpred19_ActionTranslator_fragment", 54);
		try
		{
			// Grammars\\ActionTranslator.g3:1:421: ( INDIRECT_TEMPLATE_INSTANCE )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:421: INDIRECT_TEMPLATE_INSTANCE
			{
			DebugLocation(1, 421);
			mINDIRECT_TEMPLATE_INSTANCE(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred19_ActionTranslator_fragment", 54);
			LeaveRule("synpred19_ActionTranslator_fragment", 54);
			LeaveRule_synpred19_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred19_ActionTranslator

	partial void EnterRule_synpred20_ActionTranslator_fragment();
	partial void LeaveRule_synpred20_ActionTranslator_fragment();

	// $ANTLR start synpred20_ActionTranslator
	private void synpred20_ActionTranslator_fragment()
	{
		EnterRule_synpred20_ActionTranslator_fragment();
		EnterRule("synpred20_ActionTranslator_fragment", 55);
		TraceIn("synpred20_ActionTranslator_fragment", 55);
		try
		{
			// Grammars\\ActionTranslator.g3:1:448: ( SET_EXPR_ATTRIBUTE )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:448: SET_EXPR_ATTRIBUTE
			{
			DebugLocation(1, 448);
			mSET_EXPR_ATTRIBUTE(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred20_ActionTranslator_fragment", 55);
			LeaveRule("synpred20_ActionTranslator_fragment", 55);
			LeaveRule_synpred20_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred20_ActionTranslator

	partial void EnterRule_synpred21_ActionTranslator_fragment();
	partial void LeaveRule_synpred21_ActionTranslator_fragment();

	// $ANTLR start synpred21_ActionTranslator
	private void synpred21_ActionTranslator_fragment()
	{
		EnterRule_synpred21_ActionTranslator_fragment();
		EnterRule("synpred21_ActionTranslator_fragment", 56);
		TraceIn("synpred21_ActionTranslator_fragment", 56);
		try
		{
			// Grammars\\ActionTranslator.g3:1:467: ( SET_ATTRIBUTE )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:467: SET_ATTRIBUTE
			{
			DebugLocation(1, 467);
			mSET_ATTRIBUTE(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred21_ActionTranslator_fragment", 56);
			LeaveRule("synpred21_ActionTranslator_fragment", 56);
			LeaveRule_synpred21_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred21_ActionTranslator

	partial void EnterRule_synpred22_ActionTranslator_fragment();
	partial void LeaveRule_synpred22_ActionTranslator_fragment();

	// $ANTLR start synpred22_ActionTranslator
	private void synpred22_ActionTranslator_fragment()
	{
		EnterRule_synpred22_ActionTranslator_fragment();
		EnterRule("synpred22_ActionTranslator_fragment", 57);
		TraceIn("synpred22_ActionTranslator_fragment", 57);
		try
		{
			// Grammars\\ActionTranslator.g3:1:481: ( TEMPLATE_EXPR )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:481: TEMPLATE_EXPR
			{
			DebugLocation(1, 481);
			mTEMPLATE_EXPR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred22_ActionTranslator_fragment", 57);
			LeaveRule("synpred22_ActionTranslator_fragment", 57);
			LeaveRule_synpred22_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred22_ActionTranslator

	partial void EnterRule_synpred24_ActionTranslator_fragment();
	partial void LeaveRule_synpred24_ActionTranslator_fragment();

	// $ANTLR start synpred24_ActionTranslator
	private void synpred24_ActionTranslator_fragment()
	{
		EnterRule_synpred24_ActionTranslator_fragment();
		EnterRule("synpred24_ActionTranslator_fragment", 59);
		TraceIn("synpred24_ActionTranslator_fragment", 59);
		try
		{
			// Grammars\\ActionTranslator.g3:1:499: ( ERROR_XY )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:499: ERROR_XY
			{
			DebugLocation(1, 499);
			mERROR_XY(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_ActionTranslator_fragment", 59);
			LeaveRule("synpred24_ActionTranslator_fragment", 59);
			LeaveRule_synpred24_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred24_ActionTranslator

	partial void EnterRule_synpred25_ActionTranslator_fragment();
	partial void LeaveRule_synpred25_ActionTranslator_fragment();

	// $ANTLR start synpred25_ActionTranslator
	private void synpred25_ActionTranslator_fragment()
	{
		EnterRule_synpred25_ActionTranslator_fragment();
		EnterRule("synpred25_ActionTranslator_fragment", 60);
		TraceIn("synpred25_ActionTranslator_fragment", 60);
		try
		{
			// Grammars\\ActionTranslator.g3:1:508: ( ERROR_X )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:508: ERROR_X
			{
			DebugLocation(1, 508);
			mERROR_X(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_ActionTranslator_fragment", 60);
			LeaveRule("synpred25_ActionTranslator_fragment", 60);
			LeaveRule_synpred25_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred25_ActionTranslator

	partial void EnterRule_synpred26_ActionTranslator_fragment();
	partial void LeaveRule_synpred26_ActionTranslator_fragment();

	// $ANTLR start synpred26_ActionTranslator
	private void synpred26_ActionTranslator_fragment()
	{
		EnterRule_synpred26_ActionTranslator_fragment();
		EnterRule("synpred26_ActionTranslator_fragment", 61);
		TraceIn("synpred26_ActionTranslator_fragment", 61);
		try
		{
			// Grammars\\ActionTranslator.g3:1:516: ( UNKNOWN_SYNTAX )
			DebugEnterAlt(1);
			// Grammars\\ActionTranslator.g3:1:516: UNKNOWN_SYNTAX
			{
			DebugLocation(1, 516);
			mUNKNOWN_SYNTAX(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred26_ActionTranslator_fragment", 61);
			LeaveRule("synpred26_ActionTranslator_fragment", 61);
			LeaveRule_synpred26_ActionTranslator_fragment();
		}
	}
	// $ANTLR end synpred26_ActionTranslator

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}

} // namespace Antlr3.Grammars
