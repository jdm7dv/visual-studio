//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\CodeGenTreeWalker.g3 2013-06-14 09:39:33

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using Antlr3.Analysis;
using Antlr3.Misc;
using Antlr3.Tool;
using Antlr3.Extensions;

using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;
using Template = Antlr4.StringTemplate.Template;
using TemplateGroup = Antlr4.StringTemplate.TemplateGroup;
using TokenWithIndex = Antlr.Runtime.CommonToken;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Antlr3.Grammars
{
/** Walk a grammar and generate code by gradually building up
 *  a bigger and bigger Template.
 *
 *  Terence Parr
 *  University of San Francisco
 *  June 15, 2004
 */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class CodeGenTreeWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", "ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", "TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
	};
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ACTION_CHAR_LITERAL=5;
	public const int ACTION_ESC=6;
	public const int ACTION_STRING_LITERAL=7;
	public const int ALT=8;
	public const int AMPERSAND=9;
	public const int ARG=10;
	public const int ARGLIST=11;
	public const int ARG_ACTION=12;
	public const int ASSIGN=13;
	public const int BACKTRACK_SEMPRED=14;
	public const int BANG=15;
	public const int BLOCK=16;
	public const int CATCH=17;
	public const int CHAR_LITERAL=18;
	public const int CHAR_RANGE=19;
	public const int CLOSE_ELEMENT_OPTION=20;
	public const int CLOSURE=21;
	public const int COLON=22;
	public const int COMBINED_GRAMMAR=23;
	public const int COMMA=24;
	public const int COMMENT=25;
	public const int DIGIT=26;
	public const int DOC_COMMENT=27;
	public const int DOLLAR=28;
	public const int DOT=29;
	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
	public const int EOA=32;
	public const int EOB=33;
	public const int EOR=34;
	public const int EPSILON=35;
	public const int ESC=36;
	public const int ETC=37;
	public const int FINALLY=38;
	public const int FORCED_ACTION=39;
	public const int FRAGMENT=40;
	public const int GATED_SEMPRED=41;
	public const int GRAMMAR=42;
	public const int ID=43;
	public const int IMPLIES=44;
	public const int IMPORT=45;
	public const int INITACTION=46;
	public const int INT=47;
	public const int LABEL=48;
	public const int LEXER=49;
	public const int LEXER_GRAMMAR=50;
	public const int LPAREN=51;
	public const int ML_COMMENT=52;
	public const int NESTED_ACTION=53;
	public const int NESTED_ARG_ACTION=54;
	public const int NOT=55;
	public const int OPEN_ELEMENT_OPTION=56;
	public const int OPTIONAL=57;
	public const int OPTIONS=58;
	public const int OR=59;
	public const int PARSER=60;
	public const int PARSER_GRAMMAR=61;
	public const int PLUS=62;
	public const int PLUS_ASSIGN=63;
	public const int POSITIVE_CLOSURE=64;
	public const int PREC_RULE=65;
	public const int PRIVATE=66;
	public const int PROTECTED=67;
	public const int PUBLIC=68;
	public const int QUESTION=69;
	public const int RANGE=70;
	public const int RCURLY=71;
	public const int RECURSIVE_RULE_REF=72;
	public const int RET=73;
	public const int RETURNS=74;
	public const int REWRITE=75;
	public const int REWRITES=76;
	public const int ROOT=77;
	public const int RPAREN=78;
	public const int RULE=79;
	public const int RULE_REF=80;
	public const int SCOPE=81;
	public const int SEMI=82;
	public const int SEMPRED=83;
	public const int SL_COMMENT=84;
	public const int SRC=85;
	public const int STAR=86;
	public const int STRAY_BRACKET=87;
	public const int STRING_LITERAL=88;
	public const int SYNPRED=89;
	public const int SYN_SEMPRED=90;
	public const int TEMPLATE=91;
	public const int THROWS=92;
	public const int TOKENS=93;
	public const int TOKEN_REF=94;
	public const int TREE=95;
	public const int TREE_BEGIN=96;
	public const int TREE_GRAMMAR=97;
	public const int WILDCARD=98;
	public const int WS=99;
	public const int WS_LOOP=100;
	public const int WS_OPT=101;
	public const int XDIGIT=102;

	public CodeGenTreeWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CodeGenTreeWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return CodeGenTreeWalker.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\CodeGenTreeWalker.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_grammar_();
	partial void LeaveRule_grammar_();
	// $ANTLR start "grammar_"
	// Grammars\\CodeGenTreeWalker.g3:66:1: public grammar_[Grammar g,\n\t\t Template recognizerST,\n\t\t Template outputFileST,\n\t\t Template headerFileST] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) ;
	[GrammarRule("grammar_")]
	public void grammar_(Grammar g, Template recognizerST, Template outputFileST, Template headerFileST)
	{
		EnterRule_grammar_();
		EnterRule("grammar_", 1);
		TraceIn("grammar_", 1);

			HandleGrammarInit(g, recognizerST, outputFileST, headerFileST);

		try { DebugEnterRule(GrammarFileName, "grammar_");
		DebugLocation(66, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:74:2: ( ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:74:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
			{
			DebugLocation(74, 4);
			// Grammars\\CodeGenTreeWalker.g3:74:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
			int alt1=4;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case LEXER_GRAMMAR:
				{
				alt1 = 1;
				}
				break;
			case PARSER_GRAMMAR:
				{
				alt1 = 2;
				}
				break;
			case TREE_GRAMMAR:
				{
				alt1 = 3;
				}
				break;
			case COMBINED_GRAMMAR:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:74:6: ^( LEXER_GRAMMAR grammarSpec )
				{
				DebugLocation(74, 6);
				DebugLocation(74, 9);
				Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_66); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(74, 23);
				PushFollow(Follow._grammarSpec_in_grammar_68);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:75:5: ^( PARSER_GRAMMAR grammarSpec )
				{
				DebugLocation(75, 5);
				DebugLocation(75, 8);
				Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_78); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(75, 23);
				PushFollow(Follow._grammarSpec_in_grammar_80);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:76:5: ^( TREE_GRAMMAR grammarSpec )
				{
				DebugLocation(76, 5);
				DebugLocation(76, 8);
				Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_90); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(76, 21);
				PushFollow(Follow._grammarSpec_in_grammar_92);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:77:5: ^( COMBINED_GRAMMAR grammarSpec )
				{
				DebugLocation(77, 5);
				DebugLocation(77, 8);
				Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_102); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(77, 25);
				PushFollow(Follow._grammarSpec_in_grammar_104);
				grammarSpec();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("grammar_", 1);
			LeaveRule("grammar_", 1);
			LeaveRule_grammar_();
		}
		DebugLocation(79, 1);
		} finally { DebugExitRule(GrammarFileName, "grammar_"); }
		return;

	}
	// $ANTLR end "grammar_"

	partial void EnterRule_attrScope();
	partial void LeaveRule_attrScope();
	// $ANTLR start "attrScope"
	// Grammars\\CodeGenTreeWalker.g3:81:1: attrScope : ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) ;
	[GrammarRule("attrScope")]
	private void attrScope()
	{
		EnterRule_attrScope();
		EnterRule("attrScope", 2);
		TraceIn("attrScope", 2);
		try { DebugEnterRule(GrammarFileName, "attrScope");
		DebugLocation(81, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:82:2: ( ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:82:4: ^( 'scope' ID ( ^( AMPERSAND ( . )* ) )* ACTION )
			{
			DebugLocation(82, 4);
			DebugLocation(82, 7);
			Match(input,SCOPE,Follow._SCOPE_in_attrScope123); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(82, 15);
			Match(input,ID,Follow._ID_in_attrScope125); if (state.failed) return;
			DebugLocation(82, 18);
			// Grammars\\CodeGenTreeWalker.g3:82:18: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==AMPERSAND))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:82:20: ^( AMPERSAND ( . )* )
					{
					DebugLocation(82, 20);
					DebugLocation(82, 22);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScope130); if (state.failed) return;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(82, 32);
						// Grammars\\CodeGenTreeWalker.g3:82:32: ( . )*
						try { DebugEnterSubRule(2);
						while (true)
						{
							int alt2=2;
							try { DebugEnterDecision(2, false);
							int LA2_1 = input.LA(1);

							if (((LA2_1>=ACTION && LA2_1<=XDIGIT)))
							{
								alt2 = 1;
							}
							else if ((LA2_1==UP))
							{
								alt2 = 2;
							}


							} finally { DebugExitDecision(2); }
							switch ( alt2 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\CodeGenTreeWalker.g3:82:32: .
								{
								DebugLocation(82, 32);
								MatchAny(input); if (state.failed) return;

								}
								break;

							default:
								goto loop2;
							}
						}

						loop2:
							;

						} finally { DebugExitSubRule(2); }


						Match(input, TokenTypes.Up, null); if (state.failed) return;
					}


					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(82, 39);
			Match(input,ACTION,Follow._ACTION_in_attrScope139); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("attrScope", 2);
			LeaveRule("attrScope", 2);
			LeaveRule_attrScope();
		}
		DebugLocation(83, 1);
		} finally { DebugExitRule(GrammarFileName, "attrScope"); }
		return;

	}
	// $ANTLR end "attrScope"

	partial void EnterRule_grammarSpec();
	partial void LeaveRule_grammarSpec();
	// $ANTLR start "grammarSpec"
	// Grammars\\CodeGenTreeWalker.g3:85:1: grammarSpec : ID (comment= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] ;
	[GrammarRule("grammarSpec")]
	private void grammarSpec()
	{
		EnterRule_grammarSpec();
		EnterRule("grammarSpec", 3);
		TraceIn("grammarSpec", 3);
		GrammarAST comment = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "grammarSpec");
		DebugLocation(85, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:86:2: ( ID (comment= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST] )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:86:6: ID (comment= DOC_COMMENT )? ( ^( OPTIONS ( . )* ) )? ( ^( IMPORT ( . )* ) )? ( ^( TOKENS ( . )* ) )? ( attrScope )* ( ^( AMPERSAND ( . )* ) )* rules[recognizerST]
			{
			DebugLocation(86, 6);
			Match(input,ID,Follow._ID_in_grammarSpec154); if (state.failed) return;
			DebugLocation(87, 3);
			// Grammars\\CodeGenTreeWalker.g3:87:3: (comment= DOC_COMMENT )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==DOC_COMMENT))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:87:5: comment= DOC_COMMENT
				{
				DebugLocation(87, 12);
				comment=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec162); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(89, 9);
			if (state.backtracking == 0)
			{
				HandleGrammarSpecAfterName(comment);
			}
			DebugLocation(90, 3);
			// Grammars\\CodeGenTreeWalker.g3:90:3: ( ^( OPTIONS ( . )* ) )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==OPTIONS))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:90:5: ^( OPTIONS ( . )* )
				{
				DebugLocation(90, 5);
				DebugLocation(90, 7);
				Match(input,OPTIONS,Follow._OPTIONS_in_grammarSpec184); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(90, 15);
					// Grammars\\CodeGenTreeWalker.g3:90:15: ( . )*
					try { DebugEnterSubRule(5);
					while (true)
					{
						int alt5=2;
						try { DebugEnterDecision(5, false);
						int LA5_1 = input.LA(1);

						if (((LA5_1>=ACTION && LA5_1<=XDIGIT)))
						{
							alt5 = 1;
						}
						else if ((LA5_1==UP))
						{
							alt5 = 2;
						}


						} finally { DebugExitDecision(5); }
						switch ( alt5 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:90:15: .
							{
							DebugLocation(90, 15);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop5;
						}
					}

					loop5:
						;

					} finally { DebugExitSubRule(5); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(91, 3);
			// Grammars\\CodeGenTreeWalker.g3:91:3: ( ^( IMPORT ( . )* ) )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==IMPORT))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:91:5: ^( IMPORT ( . )* )
				{
				DebugLocation(91, 5);
				DebugLocation(91, 7);
				Match(input,IMPORT,Follow._IMPORT_in_grammarSpec198); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(91, 14);
					// Grammars\\CodeGenTreeWalker.g3:91:14: ( . )*
					try { DebugEnterSubRule(7);
					while (true)
					{
						int alt7=2;
						try { DebugEnterDecision(7, false);
						int LA7_1 = input.LA(1);

						if (((LA7_1>=ACTION && LA7_1<=XDIGIT)))
						{
							alt7 = 1;
						}
						else if ((LA7_1==UP))
						{
							alt7 = 2;
						}


						} finally { DebugExitDecision(7); }
						switch ( alt7 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:91:14: .
							{
							DebugLocation(91, 14);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop7;
						}
					}

					loop7:
						;

					} finally { DebugExitSubRule(7); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(92, 3);
			// Grammars\\CodeGenTreeWalker.g3:92:3: ( ^( TOKENS ( . )* ) )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==TOKENS))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:92:5: ^( TOKENS ( . )* )
				{
				DebugLocation(92, 5);
				DebugLocation(92, 7);
				Match(input,TOKENS,Follow._TOKENS_in_grammarSpec212); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(92, 14);
					// Grammars\\CodeGenTreeWalker.g3:92:14: ( . )*
					try { DebugEnterSubRule(9);
					while (true)
					{
						int alt9=2;
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if (((LA9_1>=ACTION && LA9_1<=XDIGIT)))
						{
							alt9 = 1;
						}
						else if ((LA9_1==UP))
						{
							alt9 = 2;
						}


						} finally { DebugExitDecision(9); }
						switch ( alt9 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:92:14: .
							{
							DebugLocation(92, 14);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop9;
						}
					}

					loop9:
						;

					} finally { DebugExitSubRule(9); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(93, 3);
			// Grammars\\CodeGenTreeWalker.g3:93:3: ( attrScope )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==SCOPE))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:93:4: attrScope
					{
					DebugLocation(93, 4);
					PushFollow(Follow._attrScope_in_grammarSpec224);
					attrScope();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(94, 3);
			// Grammars\\CodeGenTreeWalker.g3:94:3: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if ((LA13_1==AMPERSAND))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:94:5: ^( AMPERSAND ( . )* )
					{
					DebugLocation(94, 5);
					DebugLocation(94, 7);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_grammarSpec233); if (state.failed) return;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(94, 17);
						// Grammars\\CodeGenTreeWalker.g3:94:17: ( . )*
						try { DebugEnterSubRule(12);
						while (true)
						{
							int alt12=2;
							try { DebugEnterDecision(12, false);
							int LA12_1 = input.LA(1);

							if (((LA12_1>=ACTION && LA12_1<=XDIGIT)))
							{
								alt12 = 1;
							}
							else if ((LA12_1==UP))
							{
								alt12 = 2;
							}


							} finally { DebugExitDecision(12); }
							switch ( alt12 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\CodeGenTreeWalker.g3:94:17: .
								{
								DebugLocation(94, 17);
								MatchAny(input); if (state.failed) return;

								}
								break;

							default:
								goto loop12;
							}
						}

						loop12:
							;

						} finally { DebugExitSubRule(12); }


						Match(input, TokenTypes.Up, null); if (state.failed) return;
					}


					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }

			DebugLocation(95, 3);
			PushFollow(Follow._rules_in_grammarSpec244);
			rules(recognizerST);
			PopFollow();
			if (state.failed) return;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("grammarSpec", 3);
			LeaveRule("grammarSpec", 3);
			LeaveRule_grammarSpec();
		}
		DebugLocation(96, 1);
		} finally { DebugExitRule(GrammarFileName, "grammarSpec"); }
		return;

	}
	// $ANTLR end "grammarSpec"

	partial void EnterRule_rules();
	partial void LeaveRule_rules();
	// $ANTLR start "rules"
	// Grammars\\CodeGenTreeWalker.g3:98:1: rules[Template recognizerST] : ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+ ;
	[GrammarRule("rules")]
	private TreeRuleReturnScope<GrammarAST> rules(Template recognizerST)
	{
		EnterRule_rules();
		EnterRule("rules", 4);
		TraceIn("rules", 4);
		TreeRuleReturnScope<GrammarAST> retval = new TreeRuleReturnScope<GrammarAST>();
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> rST = default(TreeRuleReturnScope<GrammarAST>);


		string ruleName;
		bool generated;
		HandleRulesInit(retval.Start, out ruleName, out generated);

		try { DebugEnterRule(GrammarFileName, "rules");
		DebugLocation(98, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:105:2: ( ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+ )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:105:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+
			{
			DebugLocation(105, 4);
			// Grammars\\CodeGenTreeWalker.g3:105:4: ( ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) ) )+
			int cnt17=0;
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==PREC_RULE||LA17_1==RULE))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:105:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) )
					{
					DebugLocation(105, 6);
					// Grammars\\CodeGenTreeWalker.g3:105:6: ( options {k=1; } :{...}? =>rST= rule | ^( RULE ( . )* ) | ^( PREC_RULE ( . )* ) )
					int alt16=3;
					try { DebugEnterSubRule(16);
					try { DebugEnterDecision(16, false);
					int LA16_1 = input.LA(1);

					if ((LA16_1==RULE))
					{
						int LA16_2 = input.LA(2);

						if (((generated)))
						{
							alt16 = 1;
						}
						else if ((true))
						{
							alt16 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 16, 1, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA16_1==PREC_RULE))
					{
						alt16 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 16, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(16); }
					switch (alt16)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:106:5: {...}? =>rST= rule
						{
						DebugLocation(106, 5);
						if (!((generated)))
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							throw new FailedPredicateException(input, "rules", "generated");
						}
						DebugLocation(107, 8);
						PushFollow(Follow._rule_in_rules289);
						rST=rule();
						PopFollow();
						if (state.failed) return retval;
						DebugLocation(107, 19);
						if (state.backtracking == 0)
						{
							HandleRulesRule((rST!=null?((CodeGenTreeWalker.rule_return)rST).code:default(Template)));
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Grammars\\CodeGenTreeWalker.g3:108:6: ^( RULE ( . )* )
						{
						DebugLocation(108, 6);
						DebugLocation(108, 8);
						Match(input,RULE,Follow._RULE_in_rules304); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(108, 13);
							// Grammars\\CodeGenTreeWalker.g3:108:13: ( . )*
							try { DebugEnterSubRule(14);
							while (true)
							{
								int alt14=2;
								try { DebugEnterDecision(14, false);
								int LA14_1 = input.LA(1);

								if (((LA14_1>=ACTION && LA14_1<=XDIGIT)))
								{
									alt14 = 1;
								}
								else if ((LA14_1==UP))
								{
									alt14 = 2;
								}


								} finally { DebugExitDecision(14); }
								switch ( alt14 )
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\CodeGenTreeWalker.g3:108:13: .
									{
									DebugLocation(108, 13);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop14;
								}
							}

							loop14:
								;

							} finally { DebugExitSubRule(14); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}


						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Grammars\\CodeGenTreeWalker.g3:109:6: ^( PREC_RULE ( . )* )
						{
						DebugLocation(109, 6);
						DebugLocation(109, 8);
						Match(input,PREC_RULE,Follow._PREC_RULE_in_rules316); if (state.failed) return retval;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(109, 18);
							// Grammars\\CodeGenTreeWalker.g3:109:18: ( . )*
							try { DebugEnterSubRule(15);
							while (true)
							{
								int alt15=2;
								try { DebugEnterDecision(15, false);
								int LA15_1 = input.LA(1);

								if (((LA15_1>=ACTION && LA15_1<=XDIGIT)))
								{
									alt15 = 1;
								}
								else if ((LA15_1==UP))
								{
									alt15 = 2;
								}


								} finally { DebugExitDecision(15); }
								switch ( alt15 )
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\CodeGenTreeWalker.g3:109:18: .
									{
									DebugLocation(109, 18);
									MatchAny(input); if (state.failed) return retval;

									}
									break;

								default:
									goto loop15;
								}
							}

							loop15:
								;

							} finally { DebugExitSubRule(15); }


							Match(input, TokenTypes.Up, null); if (state.failed) return retval;
						}


						}
						break;

					}
					} finally { DebugExitSubRule(16); }

					DebugLocation(111, 13);
					HandleRulesForcedAfterRule(ref ruleName, ref generated);

					}
					break;

				default:
					if (cnt17 >= 1)
						goto loop17;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee17 = new EarlyExitException( 17, input );
					DebugRecognitionException(eee17);
					throw eee17;
				}
				cnt17++;
			}
			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rules", 4);
			LeaveRule("rules", 4);
			LeaveRule_rules();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "rules"); }
		return retval;

	}
	// $ANTLR end "rules"

	private sealed partial class rule_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code=null;
		public rule_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_rule();
	partial void LeaveRule_rule();
	// $ANTLR start "rule"
	// Grammars\\CodeGenTreeWalker.g3:115:1: rule returns [Template code=null] : ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa, null] ( exceptionGroup[$code] )? EOR ) ;
	[GrammarRule("rule")]
	private CodeGenTreeWalker.rule_return rule()
	{
		EnterRule_rule();
		EnterRule("rule", 5);
		TraceIn("rule", 5);
		CodeGenTreeWalker.rule_return retval = new CodeGenTreeWalker.rule_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST id = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> mod = default(TreeRuleReturnScope<GrammarAST>);
		Template b = default(Template);


		string initAction;
		GrammarAST block2;
		Antlr3.Analysis.DFA dfa;
		Rule ruleDescr;
		string description;
		HandleRuleInit(retval.Start, out initAction, out block2, out dfa, out ruleDescr, out description);

		// For syn preds, we don't want any AST code etc... in there.
		// Save old templates ptr and restore later.  Base templates include Dbg.
		TemplateGroup saveGroup = templates;
		if (ruleDescr.IsSynPred && generator.Target.UseBaseTemplatesForSynPredFragments)
			templates = generator.BaseTemplates;

		try { DebugEnterRule(GrammarFileName, "rule");
		DebugLocation(115, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:131:2: ( ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa, null] ( exceptionGroup[$code] )? EOR ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:131:4: ^( RULE id= ID (mod= modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( throwsSpec )? ( ^( OPTIONS ( . )* ) )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* b= block[\"ruleBlock\", dfa, null] ( exceptionGroup[$code] )? EOR )
			{
			DebugLocation(131, 4);
			DebugLocation(131, 7);
			Match(input,RULE,Follow._RULE_in_rule367); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(131, 14);
			id=(GrammarAST)Match(input,ID,Follow._ID_in_rule371); if (state.failed) return retval;
			DebugLocation(131, 23);
			if (state.backtracking == 0)
			{
				HandleRuleAfterId(id);
			}
			DebugLocation(132, 4);
			// Grammars\\CodeGenTreeWalker.g3:132:4: (mod= modifier )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==FRAGMENT||(LA18_1>=PRIVATE && LA18_1<=PUBLIC)))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:132:5: mod= modifier
				{
				DebugLocation(132, 8);
				PushFollow(Follow._modifier_in_rule386);
				mod=modifier();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(133, 4);
			DebugLocation(133, 6);
			Match(input,ARG,Follow._ARG_in_rule394); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(133, 10);
				// Grammars\\CodeGenTreeWalker.g3:133:10: ( ARG_ACTION )?
				int alt19=2;
				try { DebugEnterSubRule(19);
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==ARG_ACTION))
				{
					alt19 = 1;
				}
				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:133:11: ARG_ACTION
					{
					DebugLocation(133, 11);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule397); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(19); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			DebugLocation(134, 4);
			DebugLocation(134, 6);
			Match(input,RET,Follow._RET_in_rule406); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(134, 10);
				// Grammars\\CodeGenTreeWalker.g3:134:10: ( ARG_ACTION )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==ARG_ACTION))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:134:11: ARG_ACTION
					{
					DebugLocation(134, 11);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule409); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(20); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			DebugLocation(135, 4);
			// Grammars\\CodeGenTreeWalker.g3:135:4: ( throwsSpec )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==THROWS))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:135:5: throwsSpec
				{
				DebugLocation(135, 5);
				PushFollow(Follow._throwsSpec_in_rule418);
				throwsSpec();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(136, 4);
			// Grammars\\CodeGenTreeWalker.g3:136:4: ( ^( OPTIONS ( . )* ) )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==OPTIONS))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:136:6: ^( OPTIONS ( . )* )
				{
				DebugLocation(136, 6);
				DebugLocation(136, 8);
				Match(input,OPTIONS,Follow._OPTIONS_in_rule428); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(136, 16);
					// Grammars\\CodeGenTreeWalker.g3:136:16: ( . )*
					try { DebugEnterSubRule(22);
					while (true)
					{
						int alt22=2;
						try { DebugEnterDecision(22, false);
						int LA22_1 = input.LA(1);

						if (((LA22_1>=ACTION && LA22_1<=XDIGIT)))
						{
							alt22 = 1;
						}
						else if ((LA22_1==UP))
						{
							alt22 = 2;
						}


						} finally { DebugExitDecision(22); }
						switch ( alt22 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:136:16: .
							{
							DebugLocation(136, 16);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop22;
						}
					}

					loop22:
						;

					} finally { DebugExitSubRule(22); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(137, 4);
			// Grammars\\CodeGenTreeWalker.g3:137:4: ( ruleScopeSpec )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==SCOPE))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:137:5: ruleScopeSpec
				{
				DebugLocation(137, 5);
				PushFollow(Follow._ruleScopeSpec_in_rule441);
				ruleScopeSpec();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(138, 4);
			// Grammars\\CodeGenTreeWalker.g3:138:4: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==AMPERSAND))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:138:6: ^( AMPERSAND ( . )* )
					{
					DebugLocation(138, 6);
					DebugLocation(138, 8);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_rule451); if (state.failed) return retval;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
						DebugLocation(138, 18);
						// Grammars\\CodeGenTreeWalker.g3:138:18: ( . )*
						try { DebugEnterSubRule(25);
						while (true)
						{
							int alt25=2;
							try { DebugEnterDecision(25, false);
							int LA25_1 = input.LA(1);

							if (((LA25_1>=ACTION && LA25_1<=XDIGIT)))
							{
								alt25 = 1;
							}
							else if ((LA25_1==UP))
							{
								alt25 = 2;
							}


							} finally { DebugExitDecision(25); }
							switch ( alt25 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\CodeGenTreeWalker.g3:138:18: .
								{
								DebugLocation(138, 18);
								MatchAny(input); if (state.failed) return retval;

								}
								break;

							default:
								goto loop25;
							}
						}

						loop25:
							;

						} finally { DebugExitSubRule(25); }


						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					}


					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }

			DebugLocation(139, 5);
			PushFollow(Follow._block_in_rule465);
			b=block("ruleBlock", dfa, null);
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(139, 37);
			if (state.backtracking == 0)
			{
				HandleRuleAfterBlock(out retval.code, retval.Start, block2, ruleDescr, description, b);
			}
			DebugLocation(141, 4);
			// Grammars\\CodeGenTreeWalker.g3:141:4: ( exceptionGroup[$code] )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_1 = input.LA(1);

			if ((LA27_1==CATCH||LA27_1==FINALLY))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:141:5: exceptionGroup[$code]
				{
				DebugLocation(141, 5);
				PushFollow(Follow._exceptionGroup_in_rule476);
				exceptionGroup(retval.code);
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(142, 4);
			Match(input,EOR,Follow._EOR_in_rule484); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;

			DebugLocation(144, 12);
			if (state.backtracking == 0)
			{
				HandleRuleEnd(retval.code, retval.Start, initAction, description, (mod!=null?((GrammarAST)mod.Start):default(GrammarAST)), b);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rule", 5);
			LeaveRule("rule", 5);
			LeaveRule_rule();
			 templates = saveGroup; 
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "rule"); }
		return retval;

	}
	// $ANTLR end "rule"

	partial void EnterRule_modifier();
	partial void LeaveRule_modifier();
	// $ANTLR start "modifier"
	// Grammars\\CodeGenTreeWalker.g3:148:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
	[GrammarRule("modifier")]
	private TreeRuleReturnScope<GrammarAST> modifier()
	{
		EnterRule_modifier();
		EnterRule("modifier", 6);
		TraceIn("modifier", 6);
		TreeRuleReturnScope<GrammarAST> retval = new TreeRuleReturnScope<GrammarAST>();
		retval.Start = (GrammarAST)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "modifier");
		DebugLocation(148, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:149:2: ( 'protected' | 'public' | 'private' | 'fragment' )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:
			{
			DebugLocation(149, 2);
			if (input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC))
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("modifier", 6);
			LeaveRule("modifier", 6);
			LeaveRule_modifier();
		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "modifier"); }
		return retval;

	}
	// $ANTLR end "modifier"

	partial void EnterRule_throwsSpec();
	partial void LeaveRule_throwsSpec();
	// $ANTLR start "throwsSpec"
	// Grammars\\CodeGenTreeWalker.g3:155:1: throwsSpec : ^( 'throws' ( ID )+ ) ;
	[GrammarRule("throwsSpec")]
	private void throwsSpec()
	{
		EnterRule_throwsSpec();
		EnterRule("throwsSpec", 7);
		TraceIn("throwsSpec", 7);
		try { DebugEnterRule(GrammarFileName, "throwsSpec");
		DebugLocation(155, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:156:2: ( ^( 'throws' ( ID )+ ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:156:4: ^( 'throws' ( ID )+ )
			{
			DebugLocation(156, 4);
			DebugLocation(156, 6);
			Match(input,THROWS,Follow._THROWS_in_throwsSpec543); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(156, 15);
			// Grammars\\CodeGenTreeWalker.g3:156:15: ( ID )+
			int cnt28=0;
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1==ID))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:156:15: ID
					{
					DebugLocation(156, 15);
					Match(input,ID,Follow._ID_in_throwsSpec545); if (state.failed) return;

					}
					break;

				default:
					if (cnt28 >= 1)
						goto loop28;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee28 = new EarlyExitException( 28, input );
					DebugRecognitionException(eee28);
					throw eee28;
				}
				cnt28++;
			}
			loop28:
				;

			} finally { DebugExitSubRule(28); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("throwsSpec", 7);
			LeaveRule("throwsSpec", 7);
			LeaveRule_throwsSpec();
		}
		DebugLocation(157, 1);
		} finally { DebugExitRule(GrammarFileName, "throwsSpec"); }
		return;

	}
	// $ANTLR end "throwsSpec"

	partial void EnterRule_ruleScopeSpec();
	partial void LeaveRule_ruleScopeSpec();
	// $ANTLR start "ruleScopeSpec"
	// Grammars\\CodeGenTreeWalker.g3:159:1: ruleScopeSpec : ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) ;
	[GrammarRule("ruleScopeSpec")]
	private void ruleScopeSpec()
	{
		EnterRule_ruleScopeSpec();
		EnterRule("ruleScopeSpec", 8);
		TraceIn("ruleScopeSpec", 8);
		try { DebugEnterRule(GrammarFileName, "ruleScopeSpec");
		DebugLocation(159, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:160:2: ( ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:160:4: ^( 'scope' ( ^( AMPERSAND ( . )* ) )* ( ACTION )? ( ID )* )
			{
			DebugLocation(160, 4);
			DebugLocation(160, 6);
			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec559); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(160, 14);
				// Grammars\\CodeGenTreeWalker.g3:160:14: ( ^( AMPERSAND ( . )* ) )*
				try { DebugEnterSubRule(30);
				while (true)
				{
					int alt30=2;
					try { DebugEnterDecision(30, false);
					int LA30_1 = input.LA(1);

					if ((LA30_1==AMPERSAND))
					{
						alt30 = 1;
					}


					} finally { DebugExitDecision(30); }
					switch ( alt30 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:160:16: ^( AMPERSAND ( . )* )
						{
						DebugLocation(160, 16);
						DebugLocation(160, 18);
						Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleScopeSpec564); if (state.failed) return;

						if (input.LA(1) == TokenTypes.Down)
						{
							Match(input, TokenTypes.Down, null); if (state.failed) return;
							DebugLocation(160, 28);
							// Grammars\\CodeGenTreeWalker.g3:160:28: ( . )*
							try { DebugEnterSubRule(29);
							while (true)
							{
								int alt29=2;
								try { DebugEnterDecision(29, false);
								int LA29_1 = input.LA(1);

								if (((LA29_1>=ACTION && LA29_1<=XDIGIT)))
								{
									alt29 = 1;
								}
								else if ((LA29_1==UP))
								{
									alt29 = 2;
								}


								} finally { DebugExitDecision(29); }
								switch ( alt29 )
								{
								case 1:
									DebugEnterAlt(1);
									// Grammars\\CodeGenTreeWalker.g3:160:28: .
									{
									DebugLocation(160, 28);
									MatchAny(input); if (state.failed) return;

									}
									break;

								default:
									goto loop29;
								}
							}

							loop29:
								;

							} finally { DebugExitSubRule(29); }


							Match(input, TokenTypes.Up, null); if (state.failed) return;
						}


						}
						break;

					default:
						goto loop30;
					}
				}

				loop30:
					;

				} finally { DebugExitSubRule(30); }

				DebugLocation(160, 35);
				// Grammars\\CodeGenTreeWalker.g3:160:35: ( ACTION )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1==ACTION))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:160:35: ACTION
					{
					DebugLocation(160, 35);
					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec573); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(31); }

				DebugLocation(160, 43);
				// Grammars\\CodeGenTreeWalker.g3:160:43: ( ID )*
				try { DebugEnterSubRule(32);
				while (true)
				{
					int alt32=2;
					try { DebugEnterDecision(32, false);
					int LA32_1 = input.LA(1);

					if ((LA32_1==ID))
					{
						alt32 = 1;
					}


					} finally { DebugExitDecision(32); }
					switch ( alt32 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:160:43: ID
						{
						DebugLocation(160, 43);
						Match(input,ID,Follow._ID_in_ruleScopeSpec576); if (state.failed) return;

						}
						break;

					default:
						goto loop32;
					}
				}

				loop32:
					;

				} finally { DebugExitSubRule(32); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ruleScopeSpec", 8);
			LeaveRule("ruleScopeSpec", 8);
			LeaveRule_ruleScopeSpec();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleScopeSpec"); }
		return;

	}
	// $ANTLR end "ruleScopeSpec"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// Grammars\\CodeGenTreeWalker.g3:163:1: block[string blockTemplateName, Antlr3.Analysis.DFA dfa, GrammarAST label] returns [Template code] options {k=1; } : ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative[$label] rew= rewrite )+ EOB ) );
	[GrammarRule("block")]
	private Template block(string blockTemplateName, Antlr3.Analysis.DFA dfa, GrammarAST label)
	{
		EnterRule_block();
		EnterRule("block", 9);
		TraceIn("block", 9);
		Template code = default(Template);


		TreeRuleReturnScope<GrammarAST> alt = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> rew = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> setBlock1 = default(TreeRuleReturnScope<GrammarAST>);


			int altNum;
			HandleBlockInit(blockTemplateName, dfa, ref code, out altNum);

		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(163, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:171:2: ({...}? => setBlock | ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative[$label] rew= rewrite )+ EOB ) )
			int alt36=2;
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==BLOCK))
			{
				int LA36_2 = input.LA(2);

				if (((((GrammarAST)input.LT(1)).SetValue != null)))
				{
					alt36 = 1;
				}
				else if ((true))
				{
					alt36 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					NoViableAltException nvae = new NoViableAltException("", 36, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return code;}
				NoViableAltException nvae = new NoViableAltException("", 36, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:171:4: {...}? => setBlock
				{
				DebugLocation(171, 4);
				if (!((((GrammarAST)input.LT(1)).SetValue != null)))
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					throw new FailedPredicateException(input, "block", "((GrammarAST)input.LT(1)).SetValue != null");
				}
				DebugLocation(171, 53);
				PushFollow(Follow._setBlock_in_block614);
				setBlock1=setBlock();
				PopFollow();
				if (state.failed) return code;
				DebugLocation(171, 63);
				if (state.backtracking == 0)
				{
					HandleBlockSetBlock(code, (setBlock1!=null?((CodeGenTreeWalker.setBlock_return)setBlock1).code:default(Template)));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:173:4: ^( BLOCK ( ^( OPTIONS ( . )* ) )? (alt= alternative[$label] rew= rewrite )+ EOB )
				{
				DebugLocation(173, 4);
				DebugLocation(173, 8);
				Match(input,BLOCK,Follow._BLOCK_in_block626); if (state.failed) return code;

				Match(input, TokenTypes.Down, null); if (state.failed) return code;
				DebugLocation(174, 4);
				// Grammars\\CodeGenTreeWalker.g3:174:4: ( ^( OPTIONS ( . )* ) )?
				int alt34=2;
				try { DebugEnterSubRule(34);
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==OPTIONS))
				{
					alt34 = 1;
				}
				} finally { DebugExitDecision(34); }
				switch (alt34)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:174:6: ^( OPTIONS ( . )* )
					{
					DebugLocation(174, 6);
					DebugLocation(174, 8);
					Match(input,OPTIONS,Follow._OPTIONS_in_block634); if (state.failed) return code;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return code;
						DebugLocation(174, 16);
						// Grammars\\CodeGenTreeWalker.g3:174:16: ( . )*
						try { DebugEnterSubRule(33);
						while (true)
						{
							int alt33=2;
							try { DebugEnterDecision(33, false);
							int LA33_1 = input.LA(1);

							if (((LA33_1>=ACTION && LA33_1<=XDIGIT)))
							{
								alt33 = 1;
							}
							else if ((LA33_1==UP))
							{
								alt33 = 2;
							}


							} finally { DebugExitDecision(33); }
							switch ( alt33 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\CodeGenTreeWalker.g3:174:16: .
								{
								DebugLocation(174, 16);
								MatchAny(input); if (state.failed) return code;

								}
								break;

							default:
								goto loop33;
							}
						}

						loop33:
							;

						} finally { DebugExitSubRule(33); }


						Match(input, TokenTypes.Up, null); if (state.failed) return code;
					}


					}
					break;

				}
				} finally { DebugExitSubRule(34); }

				DebugLocation(175, 4);
				// Grammars\\CodeGenTreeWalker.g3:175:4: (alt= alternative[$label] rew= rewrite )+
				int cnt35=0;
				try { DebugEnterSubRule(35);
				while (true)
				{
					int alt35=2;
					try { DebugEnterDecision(35, false);
					int LA35_1 = input.LA(1);

					if ((LA35_1==ALT))
					{
						alt35 = 1;
					}


					} finally { DebugExitDecision(35); }
					switch (alt35)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:175:6: alt= alternative[$label] rew= rewrite
						{
						DebugLocation(175, 9);
						PushFollow(Follow._alternative_in_block651);
						alt=alternative(label);
						PopFollow();
						if (state.failed) return code;
						DebugLocation(175, 33);
						PushFollow(Follow._rewrite_in_block656);
						rew=rewrite();
						PopFollow();
						if (state.failed) return code;
						DebugLocation(175, 49);
						if (state.backtracking == 0)
						{
							HandleBlockAlternative(code, ref altNum, (alt!=null?((CodeGenTreeWalker.alternative_return)alt).code:default(Template)), (rew!=null?((GrammarAST)rew.Start):default(GrammarAST)), (rew!=null?((CodeGenTreeWalker.rewrite_return)rew).code:default(Template)));
						}

						}
						break;

					default:
						if (cnt35 >= 1)
							goto loop35;

						if (state.backtracking>0) {state.failed=true; return code;}
						EarlyExitException eee35 = new EarlyExitException( 35, input );
						DebugRecognitionException(eee35);
						throw eee35;
					}
					cnt35++;
				}
				loop35:
					;

				} finally { DebugExitSubRule(35); }

				DebugLocation(177, 4);
				Match(input,EOB,Follow._EOB_in_block676); if (state.failed) return code;

				Match(input, TokenTypes.Up, null); if (state.failed) return code;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("block", 9);
			LeaveRule("block", 9);
			LeaveRule_block();
			HandleBlockFinally();
		}
		DebugLocation(179, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return code;

	}
	// $ANTLR end "block"

	private sealed partial class setBlock_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public setBlock_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_setBlock();
	partial void LeaveRule_setBlock();
	// $ANTLR start "setBlock"
	// Grammars\\CodeGenTreeWalker.g3:182:1: setBlock returns [Template code] : ^(s= BLOCK ( . )* ) ;
	[GrammarRule("setBlock")]
	private CodeGenTreeWalker.setBlock_return setBlock()
	{
		EnterRule_setBlock();
		EnterRule("setBlock", 10);
		TraceIn("setBlock", 10);
		CodeGenTreeWalker.setBlock_return retval = new CodeGenTreeWalker.setBlock_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST s = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "setBlock");
		DebugLocation(182, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:183:2: ( ^(s= BLOCK ( . )* ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:183:4: ^(s= BLOCK ( . )* )
			{
			DebugLocation(183, 4);
			DebugLocation(183, 7);
			s=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_setBlock703); if (state.failed) return retval;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(183, 14);
				// Grammars\\CodeGenTreeWalker.g3:183:14: ( . )*
				try { DebugEnterSubRule(37);
				while (true)
				{
					int alt37=2;
					try { DebugEnterDecision(37, false);
					int LA37_1 = input.LA(1);

					if (((LA37_1>=ACTION && LA37_1<=XDIGIT)))
					{
						alt37 = 1;
					}
					else if ((LA37_1==UP))
					{
						alt37 = 2;
					}


					} finally { DebugExitDecision(37); }
					switch ( alt37 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:183:14: .
						{
						DebugLocation(183, 14);
						MatchAny(input); if (state.failed) return retval;

						}
						break;

					default:
						goto loop37;
					}
				}

				loop37:
					;

				} finally { DebugExitSubRule(37); }


				Match(input, TokenTypes.Up, null); if (state.failed) return retval;
			}

			DebugLocation(183, 24);
			if (state.backtracking == 0)
			{
				HandleSetBlock(out retval.code, retval.Start, s);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("setBlock", 10);
			LeaveRule("setBlock", 10);
			LeaveRule_setBlock();
		}
		DebugLocation(184, 1);
		} finally { DebugExitRule(GrammarFileName, "setBlock"); }
		return retval;

	}
	// $ANTLR end "setBlock"

	partial void EnterRule_setAlternative();
	partial void LeaveRule_setAlternative();
	// $ANTLR start "setAlternative"
	// Grammars\\CodeGenTreeWalker.g3:186:1: setAlternative : ^( ALT ( setElement )+ EOA ) ;
	[GrammarRule("setAlternative")]
	private void setAlternative()
	{
		EnterRule_setAlternative();
		EnterRule("setAlternative", 11);
		TraceIn("setAlternative", 11);
		try { DebugEnterRule(GrammarFileName, "setAlternative");
		DebugLocation(186, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:187:2: ( ^( ALT ( setElement )+ EOA ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:187:4: ^( ALT ( setElement )+ EOA )
			{
			DebugLocation(187, 4);
			DebugLocation(187, 6);
			Match(input,ALT,Follow._ALT_in_setAlternative727); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(187, 10);
			// Grammars\\CodeGenTreeWalker.g3:187:10: ( setElement )+
			int cnt38=0;
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if (((LA38_1>=CHAR_LITERAL && LA38_1<=CHAR_RANGE)||LA38_1==STRING_LITERAL||LA38_1==TOKEN_REF))
				{
					alt38 = 1;
				}


				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:187:10: setElement
					{
					DebugLocation(187, 10);
					PushFollow(Follow._setElement_in_setAlternative729);
					setElement();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					if (cnt38 >= 1)
						goto loop38;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee38 = new EarlyExitException( 38, input );
					DebugRecognitionException(eee38);
					throw eee38;
				}
				cnt38++;
			}
			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(187, 22);
			Match(input,EOA,Follow._EOA_in_setAlternative732); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("setAlternative", 11);
			LeaveRule("setAlternative", 11);
			LeaveRule_setAlternative();
		}
		DebugLocation(188, 1);
		} finally { DebugExitRule(GrammarFileName, "setAlternative"); }
		return;

	}
	// $ANTLR end "setAlternative"

	partial void EnterRule_exceptionGroup();
	partial void LeaveRule_exceptionGroup();
	// $ANTLR start "exceptionGroup"
	// Grammars\\CodeGenTreeWalker.g3:190:1: exceptionGroup[Template ruleST] : ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] );
	[GrammarRule("exceptionGroup")]
	private void exceptionGroup(Template ruleST)
	{
		EnterRule_exceptionGroup();
		EnterRule("exceptionGroup", 12);
		TraceIn("exceptionGroup", 12);
		try { DebugEnterRule(GrammarFileName, "exceptionGroup");
		DebugLocation(190, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:191:2: ( ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )? | finallyClause[$ruleST] )
			int alt41=2;
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==CATCH))
			{
				alt41 = 1;
			}
			else if ((LA41_1==FINALLY))
			{
				alt41 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:191:4: ( exceptionHandler[$ruleST] )+ ( finallyClause[$ruleST] )?
				{
				DebugLocation(191, 4);
				// Grammars\\CodeGenTreeWalker.g3:191:4: ( exceptionHandler[$ruleST] )+
				int cnt39=0;
				try { DebugEnterSubRule(39);
				while (true)
				{
					int alt39=2;
					try { DebugEnterDecision(39, false);
					int LA39_1 = input.LA(1);

					if ((LA39_1==CATCH))
					{
						alt39 = 1;
					}


					} finally { DebugExitDecision(39); }
					switch (alt39)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:191:4: exceptionHandler[$ruleST]
						{
						DebugLocation(191, 4);
						PushFollow(Follow._exceptionHandler_in_exceptionGroup745);
						exceptionHandler(ruleST);
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						if (cnt39 >= 1)
							goto loop39;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee39 = new EarlyExitException( 39, input );
						DebugRecognitionException(eee39);
						throw eee39;
					}
					cnt39++;
				}
				loop39:
					;

				} finally { DebugExitSubRule(39); }

				DebugLocation(191, 31);
				// Grammars\\CodeGenTreeWalker.g3:191:31: ( finallyClause[$ruleST] )?
				int alt40=2;
				try { DebugEnterSubRule(40);
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==FINALLY))
				{
					alt40 = 1;
				}
				} finally { DebugExitDecision(40); }
				switch (alt40)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:191:31: finallyClause[$ruleST]
					{
					DebugLocation(191, 31);
					PushFollow(Follow._finallyClause_in_exceptionGroup749);
					finallyClause(ruleST);
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(40); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:192:4: finallyClause[$ruleST]
				{
				DebugLocation(192, 4);
				PushFollow(Follow._finallyClause_in_exceptionGroup756);
				finallyClause(ruleST);
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionGroup", 12);
			LeaveRule("exceptionGroup", 12);
			LeaveRule_exceptionGroup();
		}
		DebugLocation(193, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionGroup"); }
		return;

	}
	// $ANTLR end "exceptionGroup"

	partial void EnterRule_exceptionHandler();
	partial void LeaveRule_exceptionHandler();
	// $ANTLR start "exceptionHandler"
	// Grammars\\CodeGenTreeWalker.g3:195:1: exceptionHandler[Template ruleST] : ^( 'catch' ARG_ACTION ACTION ) ;
	[GrammarRule("exceptionHandler")]
	private void exceptionHandler(Template ruleST)
	{
		EnterRule_exceptionHandler();
		EnterRule("exceptionHandler", 13);
		TraceIn("exceptionHandler", 13);
		GrammarAST ARG_ACTION2 = default(GrammarAST);
		GrammarAST ACTION3 = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "exceptionHandler");
		DebugLocation(195, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:196:2: ( ^( 'catch' ARG_ACTION ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:196:4: ^( 'catch' ARG_ACTION ACTION )
			{
			DebugLocation(196, 4);
			DebugLocation(196, 6);
			Match(input,CATCH,Follow._CATCH_in_exceptionHandler770); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(196, 14);
			ARG_ACTION2=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler772); if (state.failed) return;
			DebugLocation(196, 25);
			ACTION3=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_exceptionHandler774); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(196, 35);
			if (state.backtracking == 0)
			{
				HandleExceptionHandler(ruleST, ARG_ACTION2, ACTION3);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionHandler", 13);
			LeaveRule("exceptionHandler", 13);
			LeaveRule_exceptionHandler();
		}
		DebugLocation(197, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionHandler"); }
		return;

	}
	// $ANTLR end "exceptionHandler"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// Grammars\\CodeGenTreeWalker.g3:199:1: finallyClause[Template ruleST] : ^( 'finally' ACTION ) ;
	[GrammarRule("finallyClause")]
	private void finallyClause(Template ruleST)
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 14);
		TraceIn("finallyClause", 14);
		GrammarAST ACTION4 = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(199, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:200:2: ( ^( 'finally' ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:200:4: ^( 'finally' ACTION )
			{
			DebugLocation(200, 4);
			DebugLocation(200, 6);
			Match(input,FINALLY,Follow._FINALLY_in_finallyClause792); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(200, 16);
			ACTION4=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_finallyClause794); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(200, 29);
			if (state.backtracking == 0)
			{
				HandleFinallyClause(ruleST, ACTION4);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("finallyClause", 14);
			LeaveRule("finallyClause", 14);
			LeaveRule_finallyClause();
		}
		DebugLocation(201, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return;

	}
	// $ANTLR end "finallyClause"

	private sealed partial class alternative_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public alternative_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_alternative();
	partial void LeaveRule_alternative();
	// $ANTLR start "alternative"
	// Grammars\\CodeGenTreeWalker.g3:203:1: alternative[GrammarAST label] returns [Template code] : ^( ALT (e= element[$label,null] )+ EOA ) ;
	[GrammarRule("alternative")]
	private CodeGenTreeWalker.alternative_return alternative(GrammarAST label)
	{
		EnterRule_alternative();
		EnterRule("alternative", 15);
		TraceIn("alternative", 15);
		CodeGenTreeWalker.alternative_return retval = new CodeGenTreeWalker.alternative_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> e = default(TreeRuleReturnScope<GrammarAST>);


		HandleAlternativeInit(out retval.code, retval.Start);

		try { DebugEnterRule(GrammarFileName, "alternative");
		DebugLocation(203, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:208:2: ( ^( ALT (e= element[$label,null] )+ EOA ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:208:4: ^( ALT (e= element[$label,null] )+ EOA )
			{
			DebugLocation(208, 4);
			DebugLocation(208, 7);
			Match(input,ALT,Follow._ALT_in_alternative825); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(209, 4);
			// Grammars\\CodeGenTreeWalker.g3:209:4: (e= element[$label,null] )+
			int cnt42=0;
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==ACTION||(LA42_1>=ASSIGN && LA42_1<=BLOCK)||(LA42_1>=CHAR_LITERAL && LA42_1<=CHAR_RANGE)||LA42_1==CLOSURE||LA42_1==DOT||LA42_1==EPSILON||LA42_1==FORCED_ACTION||LA42_1==GATED_SEMPRED||LA42_1==NOT||LA42_1==OPTIONAL||(LA42_1>=PLUS_ASSIGN && LA42_1<=POSITIVE_CLOSURE)||LA42_1==ROOT||LA42_1==RULE_REF||LA42_1==SEMPRED||(LA42_1>=STRING_LITERAL && LA42_1<=SYN_SEMPRED)||LA42_1==TOKEN_REF||LA42_1==TREE_BEGIN||LA42_1==WILDCARD))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:209:6: e= element[$label,null]
					{
					DebugLocation(209, 7);
					PushFollow(Follow._element_in_alternative834);
					e=element(label, null);
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(209, 31);
					if (state.backtracking == 0)
					{
						HandleAlternativeElement(retval.code, (e!=null?((GrammarAST)e.Start):default(GrammarAST)), (e!=null?((CodeGenTreeWalker.element_return)e).code:default(Template)));
					}

					}
					break;

				default:
					if (cnt42 >= 1)
						goto loop42;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee42 = new EarlyExitException( 42, input );
					DebugRecognitionException(eee42);
					throw eee42;
				}
				cnt42++;
			}
			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(211, 4);
			Match(input,EOA,Follow._EOA_in_alternative850); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("alternative", 15);
			LeaveRule("alternative", 15);
			LeaveRule_alternative();
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "alternative"); }
		return retval;

	}
	// $ANTLR end "alternative"

	private sealed partial class element_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public element_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// Grammars\\CodeGenTreeWalker.g3:215:1: element[GrammarAST label, GrammarAST astSuffix] returns [Template code] options {k=1; } : ( ^( ROOT e= element[$label,$ROOT] ) | ^( BANG e= element[$label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |{...}? ebnf[$label] | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON );
	[GrammarRule("element")]
	private CodeGenTreeWalker.element_return element(GrammarAST label, GrammarAST astSuffix)
	{
		EnterRule_element();
		EnterRule("element", 16);
		TraceIn("element", 16);
		CodeGenTreeWalker.element_return retval = new CodeGenTreeWalker.element_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST n = default(GrammarAST);
		GrammarAST alabel = default(GrammarAST);
		GrammarAST label2 = default(GrammarAST);
		GrammarAST a = default(GrammarAST);
		GrammarAST b = default(GrammarAST);
		GrammarAST sp = default(GrammarAST);
		GrammarAST ROOT5 = default(GrammarAST);
		GrammarAST BANG6 = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> e = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> notElement7 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> ebnf8 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> atom9 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> tree_10 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> element_action11 = default(TreeRuleReturnScope<GrammarAST>);

		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(215, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:217:2: ( ^( ROOT e= element[$label,$ROOT] ) | ^( BANG e= element[$label,$BANG] ) | ^(n= NOT notElement[$n, $label, $astSuffix] ) | ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] ) | ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] ) | ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL ) |{...}? ebnf[$label] | atom[null, $label, $astSuffix] | tree_ | element_action | (sp= SEMPRED |sp= GATED_SEMPRED ) | SYN_SEMPRED | ^( SYNPRED ( . )* ) | ^( BACKTRACK_SEMPRED ( . )* ) | EPSILON )
			int alt46=15;
			try { DebugEnterDecision(46, false);
			switch (input.LA(1))
			{
			case ROOT:
				{
				alt46 = 1;
				}
				break;
			case BANG:
				{
				alt46 = 2;
				}
				break;
			case NOT:
				{
				alt46 = 3;
				}
				break;
			case ASSIGN:
				{
				alt46 = 4;
				}
				break;
			case PLUS_ASSIGN:
				{
				alt46 = 5;
				}
				break;
			case CHAR_RANGE:
				{
				alt46 = 6;
				}
				break;
			case BLOCK:
				{
				int LA46_2 = input.LA(2);

				if (((retval.Start.SetValue == null)))
				{
					alt46 = 7;
				}
				else if ((true))
				{
					alt46 = 8;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 46, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CLOSURE:
			case OPTIONAL:
			case POSITIVE_CLOSURE:
				{
				alt46 = 7;
				}
				break;
			case CHAR_LITERAL:
			case DOT:
			case RULE_REF:
			case STRING_LITERAL:
			case TOKEN_REF:
			case WILDCARD:
				{
				alt46 = 8;
				}
				break;
			case TREE_BEGIN:
				{
				alt46 = 9;
				}
				break;
			case ACTION:
			case FORCED_ACTION:
				{
				alt46 = 10;
				}
				break;
			case GATED_SEMPRED:
			case SEMPRED:
				{
				alt46 = 11;
				}
				break;
			case SYN_SEMPRED:
				{
				alt46 = 12;
				}
				break;
			case SYNPRED:
				{
				alt46 = 13;
				}
				break;
			case BACKTRACK_SEMPRED:
				{
				alt46 = 14;
				}
				break;
			case EPSILON:
				{
				alt46 = 15;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:217:4: ^( ROOT e= element[$label,$ROOT] )
				{
				DebugLocation(217, 4);
				DebugLocation(217, 6);
				ROOT5=(GrammarAST)Match(input,ROOT,Follow._ROOT_in_element880); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(217, 12);
				PushFollow(Follow._element_in_element884);
				e=element(label, ROOT5);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(217, 42);
				if (state.backtracking == 0)
				{
					retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:default(Template));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:218:4: ^( BANG e= element[$label,$BANG] )
				{
				DebugLocation(218, 4);
				DebugLocation(218, 6);
				BANG6=(GrammarAST)Match(input,BANG,Follow._BANG_in_element900); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(218, 12);
				PushFollow(Follow._element_in_element904);
				e=element(label, BANG6);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(218, 42);
				if (state.backtracking == 0)
				{
					retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:default(Template));
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:219:4: ^(n= NOT notElement[$n, $label, $astSuffix] )
				{
				DebugLocation(219, 4);
				DebugLocation(219, 7);
				n=(GrammarAST)Match(input,NOT,Follow._NOT_in_element922); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(219, 12);
				PushFollow(Follow._notElement_in_element924);
				notElement7=notElement(n, label, astSuffix);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(219, 51);
				if (state.backtracking == 0)
				{
					retval.code = (notElement7!=null?((CodeGenTreeWalker.notElement_return)notElement7).code:default(Template));
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:220:4: ^( ASSIGN alabel= ID e= element[$alabel,$astSuffix] )
				{
				DebugLocation(220, 4);
				DebugLocation(220, 6);
				Match(input,ASSIGN,Follow._ASSIGN_in_element937); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(220, 19);
				alabel=(GrammarAST)Match(input,ID,Follow._ID_in_element941); if (state.failed) return retval;
				DebugLocation(220, 24);
				PushFollow(Follow._element_in_element945);
				e=element(alabel, astSuffix);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(220, 55);
				if (state.backtracking == 0)
				{
					retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:default(Template));
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\CodeGenTreeWalker.g3:221:4: ^( PLUS_ASSIGN label2= ID e= element[$label2,$astSuffix] )
				{
				DebugLocation(221, 4);
				DebugLocation(221, 6);
				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element956); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(221, 24);
				label2=(GrammarAST)Match(input,ID,Follow._ID_in_element960); if (state.failed) return retval;
				DebugLocation(221, 29);
				PushFollow(Follow._element_in_element964);
				e=element(label2, astSuffix);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(221, 59);
				if (state.backtracking == 0)
				{
					retval.code = (e!=null?((CodeGenTreeWalker.element_return)e).code:default(Template));
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\CodeGenTreeWalker.g3:222:4: ^( CHAR_RANGE a= CHAR_LITERAL b= CHAR_LITERAL )
				{
				DebugLocation(222, 4);
				DebugLocation(222, 6);
				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element974); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(222, 18);
				a=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element978); if (state.failed) return retval;
				DebugLocation(222, 33);
				b=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_element982); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(222, 51);
				if (state.backtracking == 0)
				{
					HandleElementCharRange(label, out retval.code, a, b);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\CodeGenTreeWalker.g3:223:4: {...}? ebnf[$label]
				{
				DebugLocation(223, 4);
				if (!((retval.Start.SetValue == null)))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "element", "$start.SetValue == null");
				}
				DebugLocation(223, 31);
				PushFollow(Follow._ebnf_in_element995);
				ebnf8=ebnf(label);
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(223, 48);
				if (state.backtracking == 0)
				{
					retval.code = (ebnf8!=null?((CodeGenTreeWalker.ebnf_return)ebnf8).code:default(Template));
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\CodeGenTreeWalker.g3:224:4: atom[null, $label, $astSuffix]
				{
				DebugLocation(224, 4);
				PushFollow(Follow._atom_in_element1007);
				atom9=atom(null, label, astSuffix);
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(224, 41);
				if (state.backtracking == 0)
				{
					retval.code = (atom9!=null?((CodeGenTreeWalker.atom_return)atom9).code:default(Template));
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\CodeGenTreeWalker.g3:225:4: tree_
				{
				DebugLocation(225, 4);
				PushFollow(Follow._tree__in_element1021);
				tree_10=tree_();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(225, 22);
				if (state.backtracking == 0)
				{
					retval.code = (tree_10!=null?((CodeGenTreeWalker.tree__return)tree_10).code:default(Template));
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\CodeGenTreeWalker.g3:226:4: element_action
				{
				DebugLocation(226, 4);
				PushFollow(Follow._element_action_in_element1040);
				element_action11=element_action();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(226, 29);
				if (state.backtracking == 0)
				{
					retval.code = (element_action11!=null?((CodeGenTreeWalker.element_action_return)element_action11).code:default(Template));
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammars\\CodeGenTreeWalker.g3:227:4: (sp= SEMPRED |sp= GATED_SEMPRED )
				{
				DebugLocation(227, 4);
				// Grammars\\CodeGenTreeWalker.g3:227:4: (sp= SEMPRED |sp= GATED_SEMPRED )
				int alt43=2;
				try { DebugEnterSubRule(43);
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==SEMPRED))
				{
					alt43 = 1;
				}
				else if ((LA43_1==GATED_SEMPRED))
				{
					alt43 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:227:5: sp= SEMPRED
					{
					DebugLocation(227, 7);
					sp=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1060); if (state.failed) return retval;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\CodeGenTreeWalker.g3:227:18: sp= GATED_SEMPRED
					{
					DebugLocation(227, 20);
					sp=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1066); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(43); }

				DebugLocation(227, 42);
				if (state.backtracking == 0)
				{
					HandleElementSemanticPredicate(out retval.code, sp);
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammars\\CodeGenTreeWalker.g3:228:4: SYN_SEMPRED
				{
				DebugLocation(228, 4);
				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1080); if (state.failed) return retval;

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Grammars\\CodeGenTreeWalker.g3:229:4: ^( SYNPRED ( . )* )
				{
				DebugLocation(229, 4);
				DebugLocation(229, 6);
				Match(input,SYNPRED,Follow._SYNPRED_in_element1087); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(229, 14);
					// Grammars\\CodeGenTreeWalker.g3:229:14: ( . )*
					try { DebugEnterSubRule(44);
					while (true)
					{
						int alt44=2;
						try { DebugEnterDecision(44, false);
						int LA44_1 = input.LA(1);

						if (((LA44_1>=ACTION && LA44_1<=XDIGIT)))
						{
							alt44 = 1;
						}
						else if ((LA44_1==UP))
						{
							alt44 = 2;
						}


						} finally { DebugExitDecision(44); }
						switch ( alt44 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:229:14: .
							{
							DebugLocation(229, 14);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop44;
						}
					}

					loop44:
						;

					} finally { DebugExitSubRule(44); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Grammars\\CodeGenTreeWalker.g3:230:4: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(230, 4);
				DebugLocation(230, 6);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1097); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(230, 24);
					// Grammars\\CodeGenTreeWalker.g3:230:24: ( . )*
					try { DebugEnterSubRule(45);
					while (true)
					{
						int alt45=2;
						try { DebugEnterDecision(45, false);
						int LA45_1 = input.LA(1);

						if (((LA45_1>=ACTION && LA45_1<=XDIGIT)))
						{
							alt45 = 1;
						}
						else if ((LA45_1==UP))
						{
							alt45 = 2;
						}


						} finally { DebugExitDecision(45); }
						switch ( alt45 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:230:24: .
							{
							DebugLocation(230, 24);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop45;
						}
					}

					loop45:
						;

					} finally { DebugExitSubRule(45); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 15:
				DebugEnterAlt(15);
				// Grammars\\CodeGenTreeWalker.g3:231:4: EPSILON
				{
				DebugLocation(231, 4);
				Match(input,EPSILON,Follow._EPSILON_in_element1106); if (state.failed) return retval;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("element", 16);
			LeaveRule("element", 16);
			LeaveRule_element();
		}
		DebugLocation(232, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return retval;

	}
	// $ANTLR end "element"

	private sealed partial class element_action_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public element_action_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_element_action();
	partial void LeaveRule_element_action();
	// $ANTLR start "element_action"
	// Grammars\\CodeGenTreeWalker.g3:234:1: element_action returns [Template code] : (action= ACTION |action= FORCED_ACTION );
	[GrammarRule("element_action")]
	private CodeGenTreeWalker.element_action_return element_action()
	{
		EnterRule_element_action();
		EnterRule("element_action", 17);
		TraceIn("element_action", 17);
		CodeGenTreeWalker.element_action_return retval = new CodeGenTreeWalker.element_action_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST action = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "element_action");
		DebugLocation(234, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:235:2: (action= ACTION |action= FORCED_ACTION )
			int alt47=2;
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1==ACTION))
			{
				alt47 = 1;
			}
			else if ((LA47_1==FORCED_ACTION))
			{
				alt47 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 47, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:235:4: action= ACTION
				{
				DebugLocation(235, 10);
				action=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element_action1123); if (state.failed) return retval;
				DebugLocation(235, 20);
				if (state.backtracking == 0)
				{
					HandleElementAction(out retval.code, action, false);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:236:4: action= FORCED_ACTION
				{
				DebugLocation(236, 10);
				action=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element_action1134); if (state.failed) return retval;
				DebugLocation(236, 25);
				if (state.backtracking == 0)
				{
					HandleElementAction(out retval.code, action, true);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("element_action", 17);
			LeaveRule("element_action", 17);
			LeaveRule_element_action();
		}
		DebugLocation(237, 1);
		} finally { DebugExitRule(GrammarFileName, "element_action"); }
		return retval;

	}
	// $ANTLR end "element_action"

	private sealed partial class notElement_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public notElement_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_notElement();
	partial void LeaveRule_notElement();
	// $ANTLR start "notElement"
	// Grammars\\CodeGenTreeWalker.g3:239:1: notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [Template code] : (t= CHAR_LITERAL |t= STRING_LITERAL |t= TOKEN_REF | ^(t= BLOCK ( . )* ) ) ;
	[GrammarRule("notElement")]
	private CodeGenTreeWalker.notElement_return notElement(GrammarAST n, GrammarAST label, GrammarAST astSuffix)
	{
		EnterRule_notElement();
		EnterRule("notElement", 18);
		TraceIn("notElement", 18);
		CodeGenTreeWalker.notElement_return retval = new CodeGenTreeWalker.notElement_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST t = default(GrammarAST);


			IIntSet elements = null;

		try { DebugEnterRule(GrammarFileName, "notElement");
		DebugLocation(239, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:244:2: ( (t= CHAR_LITERAL |t= STRING_LITERAL |t= TOKEN_REF | ^(t= BLOCK ( . )* ) ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:244:4: (t= CHAR_LITERAL |t= STRING_LITERAL |t= TOKEN_REF | ^(t= BLOCK ( . )* ) )
			{
			DebugLocation(244, 4);
			// Grammars\\CodeGenTreeWalker.g3:244:4: (t= CHAR_LITERAL |t= STRING_LITERAL |t= TOKEN_REF | ^(t= BLOCK ( . )* ) )
			int alt49=4;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				alt49 = 1;
				}
				break;
			case STRING_LITERAL:
				{
				alt49 = 2;
				}
				break;
			case TOKEN_REF:
				{
				alt49 = 3;
				}
				break;
			case BLOCK:
				{
				alt49 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:244:6: t= CHAR_LITERAL
				{
				DebugLocation(244, 7);
				t=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_notElement1161); if (state.failed) return retval;
				DebugLocation(244, 22);
				if (state.backtracking == 0)
				{
					HandleNotElementCharLiteral(out elements, t);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:245:5: t= STRING_LITERAL
				{
				DebugLocation(245, 6);
				t=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_notElement1172); if (state.failed) return retval;
				DebugLocation(245, 22);
				if (state.backtracking == 0)
				{
					HandleNotElementStringLiteral(out elements, t);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:246:5: t= TOKEN_REF
				{
				DebugLocation(246, 6);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_notElement1182); if (state.failed) return retval;
				DebugLocation(246, 19);
				if (state.backtracking == 0)
				{
					HandleNotElementTokenReference(out elements, t);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:247:5: ^(t= BLOCK ( . )* )
				{
				DebugLocation(247, 5);
				DebugLocation(247, 8);
				t=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_notElement1195); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(247, 15);
					// Grammars\\CodeGenTreeWalker.g3:247:15: ( . )*
					try { DebugEnterSubRule(48);
					while (true)
					{
						int alt48=2;
						try { DebugEnterDecision(48, false);
						int LA48_1 = input.LA(1);

						if (((LA48_1>=ACTION && LA48_1<=XDIGIT)))
						{
							alt48 = 1;
						}
						else if ((LA48_1==UP))
						{
							alt48 = 2;
						}


						} finally { DebugExitDecision(48); }
						switch ( alt48 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:247:15: .
							{
							DebugLocation(247, 15);
							MatchAny(input); if (state.failed) return retval;

							}
							break;

						default:
							goto loop48;
						}
					}

					loop48:
						;

					} finally { DebugExitSubRule(48); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(247, 20);
				if (state.backtracking == 0)
				{
					HandleNotElementBlock(out elements, t);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(49); }

			DebugLocation(249, 9);
			if (state.backtracking == 0)
			{
				HandleNotElementEnd(n, label, astSuffix, out retval.code, elements, retval.Start);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("notElement", 18);
			LeaveRule("notElement", 18);
			LeaveRule_notElement();
		}
		DebugLocation(250, 1);
		} finally { DebugExitRule(GrammarFileName, "notElement"); }
		return retval;

	}
	// $ANTLR end "notElement"

	private sealed partial class ebnf_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code=null;
		public ebnf_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_ebnf();
	partial void LeaveRule_ebnf();
	// $ANTLR start "ebnf"
	// Grammars\\CodeGenTreeWalker.g3:252:1: ebnf[GrammarAST label] returns [Template code=null] : (blk= block[\"block\", $start.LookaheadDFA, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", $start.LookaheadDFA, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", eob.LookaheadDFA, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", eob.LookaheadDFA, $label] ) ) ;
	[GrammarRule("ebnf")]
	private CodeGenTreeWalker.ebnf_return ebnf(GrammarAST label)
	{
		EnterRule_ebnf();
		EnterRule("ebnf", 19);
		TraceIn("ebnf", 19);
		CodeGenTreeWalker.ebnf_return retval = new CodeGenTreeWalker.ebnf_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		Template blk = default(Template);


			GrammarAST b = (GrammarAST)retval.Start.GetChild(0);
			GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA

		try { DebugEnterRule(GrammarFileName, "ebnf");
		DebugLocation(252, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:258:2: ( (blk= block[\"block\", $start.LookaheadDFA, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", $start.LookaheadDFA, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", eob.LookaheadDFA, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", eob.LookaheadDFA, $label] ) ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:258:4: (blk= block[\"block\", $start.LookaheadDFA, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", $start.LookaheadDFA, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", eob.LookaheadDFA, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", eob.LookaheadDFA, $label] ) )
			{
			DebugLocation(258, 4);
			// Grammars\\CodeGenTreeWalker.g3:258:4: (blk= block[\"block\", $start.LookaheadDFA, $label] | ^( OPTIONAL blk= block[\"optionalBlock\", $start.LookaheadDFA, $label] ) | ^( CLOSURE blk= block[\"closureBlock\", eob.LookaheadDFA, $label] ) | ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", eob.LookaheadDFA, $label] ) )
			int alt50=4;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			switch (input.LA(1))
			{
			case BLOCK:
				{
				alt50 = 1;
				}
				break;
			case OPTIONAL:
				{
				alt50 = 2;
				}
				break;
			case CLOSURE:
				{
				alt50 = 3;
				}
				break;
			case POSITIVE_CLOSURE:
				{
				alt50 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:258:6: blk= block[\"block\", $start.LookaheadDFA, $label]
				{
				DebugLocation(258, 9);
				PushFollow(Follow._block_in_ebnf1241);
				blk=block("block", retval.Start.LookaheadDFA, label);
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(258, 63);
				if (state.backtracking == 0)
				{
					retval.code = blk;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:259:5: ^( OPTIONAL blk= block[\"optionalBlock\", $start.LookaheadDFA, $label] )
				{
				DebugLocation(259, 5);
				DebugLocation(259, 7);
				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1260); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(259, 19);
				PushFollow(Follow._block_in_ebnf1264);
				blk=block("optionalBlock", retval.Start.LookaheadDFA, label);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(259, 77);
				if (state.backtracking == 0)
				{
					retval.code = blk;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:260:5: ^( CLOSURE blk= block[\"closureBlock\", eob.LookaheadDFA, $label] )
				{
				DebugLocation(260, 5);
				DebugLocation(260, 7);
				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1279); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(260, 18);
				PushFollow(Follow._block_in_ebnf1283);
				blk=block("closureBlock", eob.LookaheadDFA, label);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(260, 73);
				if (state.backtracking == 0)
				{
					retval.code = blk;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:261:5: ^( POSITIVE_CLOSURE blk= block[\"positiveClosureBlock\", eob.LookaheadDFA, $label] )
				{
				DebugLocation(261, 5);
				DebugLocation(261, 7);
				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1299); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(261, 27);
				PushFollow(Follow._block_in_ebnf1303);
				blk=block("positiveClosureBlock", eob.LookaheadDFA, label);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(261, 86);
				if (state.backtracking == 0)
				{
					retval.code = blk;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(50); }

			DebugLocation(263, 3);
			if (state.backtracking == 0)
			{

							string description = grammar.GrammarTreeToString(retval.Start, false);
							description = generator.Target.GetTargetStringLiteralFromString(description);
							retval.code.SetAttribute("description", description);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ebnf", 19);
			LeaveRule("ebnf", 19);
			LeaveRule_ebnf();
		}
		DebugLocation(268, 1);
		} finally { DebugExitRule(GrammarFileName, "ebnf"); }
		return retval;

	}
	// $ANTLR end "ebnf"

	private sealed partial class tree__return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public tree__return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_tree_();
	partial void LeaveRule_tree_();
	// $ANTLR start "tree_"
	// Grammars\\CodeGenTreeWalker.g3:270:1: tree_ returns [Template code] : ^( TREE_BEGIN el= element[null,rootSuffix] ( ( element_action )=>act= element_action )* (el= element[null,null] )* ) ;
	[GrammarRule("tree_")]
	private CodeGenTreeWalker.tree__return tree_()
	{
		EnterRule_tree_();
		EnterRule("tree_", 20);
		TraceIn("tree_", 20);
		CodeGenTreeWalker.tree__return retval = new CodeGenTreeWalker.tree__return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> el = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> act = default(TreeRuleReturnScope<GrammarAST>);


			rewriteTreeNestingLevel++;
			GrammarAST rootSuffix = null;
			if ( state.backtracking == 0 )
			{
				retval.code = templates.GetInstanceOf("tree");
				NFAState afterDOWN = (NFAState)retval.Start.NFATreeDownState.GetTransition(0).Target;
				LookaheadSet s = grammar.Look(afterDOWN);
				if ( s.Member(Label.UP) ) {
					// nullable child list if we can see the UP as the next token
					// we need an "if ( input.LA(1)==Token.DOWN )" gate around
					// the child list.
					retval.code.SetAttribute("nullableChildList", "true");
				}
				retval.code.SetAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
				retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
				Rule r = grammar.GetRule(currentRuleName);
				if ( grammar.BuildAST && !r.HasRewrite(outerAltNum) ) {
					rootSuffix = new GrammarAST(ROOT,"ROOT");
				}
			}

		try { DebugEnterRule(GrammarFileName, "tree_");
		DebugLocation(270, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:294:2: ( ^( TREE_BEGIN el= element[null,rootSuffix] ( ( element_action )=>act= element_action )* (el= element[null,null] )* ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:294:4: ^( TREE_BEGIN el= element[null,rootSuffix] ( ( element_action )=>act= element_action )* (el= element[null,null] )* )
			{
			DebugLocation(294, 4);
			DebugLocation(294, 7);
			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1338); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(295, 6);
			PushFollow(Follow._element_in_tree_1345);
			el=element(null, rootSuffix);
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(296, 4);
			if (state.backtracking == 0)
			{

								retval.code.SetAttribute("root.{el,line,pos}",
												  (el!=null?((CodeGenTreeWalker.element_return)el).code:default(Template)),
												  (el!=null?((GrammarAST)el.Start):default(GrammarAST)).Line,
												  (el!=null?((GrammarAST)el.Start):default(GrammarAST)).CharPositionInLine + 1
												  );
							
			}
			DebugLocation(306, 4);
			// Grammars\\CodeGenTreeWalker.g3:306:4: ( ( element_action )=>act= element_action )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==ACTION))
				{
					int LA51_2 = input.LA(2);

					if ((EvaluatePredicate(synpred1_CodeGenTreeWalker_fragment)))
					{
						alt51 = 1;
					}


				}
				else if ((LA51_1==FORCED_ACTION))
				{
					int LA51_2 = input.LA(2);

					if ((EvaluatePredicate(synpred1_CodeGenTreeWalker_fragment)))
					{
						alt51 = 1;
					}


				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:306:6: ( element_action )=>act= element_action
					{
					DebugLocation(307, 8);
					PushFollow(Follow._element_action_in_tree_1382);
					act=element_action();
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(308, 5);
					if (state.backtracking == 0)
					{

											retval.code.SetAttribute("actionsAfterRoot.{el,line,pos}",
															  (act!=null?((CodeGenTreeWalker.element_action_return)act).code:default(Template)),
															  (act!=null?((GrammarAST)act.Start):default(GrammarAST)).Line,
															  (act!=null?((GrammarAST)act.Start):default(GrammarAST)).CharPositionInLine + 1
															);
										
					}

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }

			DebugLocation(316, 4);
			// Grammars\\CodeGenTreeWalker.g3:316:4: (el= element[null,null] )*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, false);
				int LA52_1 = input.LA(1);

				if ((LA52_1==ACTION||(LA52_1>=ASSIGN && LA52_1<=BLOCK)||(LA52_1>=CHAR_LITERAL && LA52_1<=CHAR_RANGE)||LA52_1==CLOSURE||LA52_1==DOT||LA52_1==EPSILON||LA52_1==FORCED_ACTION||LA52_1==GATED_SEMPRED||LA52_1==NOT||LA52_1==OPTIONAL||(LA52_1>=PLUS_ASSIGN && LA52_1<=POSITIVE_CLOSURE)||LA52_1==ROOT||LA52_1==RULE_REF||LA52_1==SEMPRED||(LA52_1>=STRING_LITERAL && LA52_1<=SYN_SEMPRED)||LA52_1==TOKEN_REF||LA52_1==TREE_BEGIN||LA52_1==WILDCARD))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:316:7: el= element[null,null]
					{
					DebugLocation(316, 9);
					PushFollow(Follow._element_in_tree_1404);
					el=element(null, null);
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(317, 6);
					if (state.backtracking == 0)
					{

										 retval.code.SetAttribute("children.{el,line,pos}",
														  (el!=null?((CodeGenTreeWalker.element_return)el).code:default(Template)),
														  (el!=null?((GrammarAST)el.Start):default(GrammarAST)).Line,
														  (el!=null?((GrammarAST)el.Start):default(GrammarAST)).CharPositionInLine + 1
														  );
										 
					}

					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }


			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tree_", 20);
			LeaveRule("tree_", 20);
			LeaveRule_tree_();
			 rewriteTreeNestingLevel--; 
		}
		DebugLocation(326, 1);
		} finally { DebugExitRule(GrammarFileName, "tree_"); }
		return retval;

	}
	// $ANTLR end "tree_"

	private sealed partial class atom_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public atom_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\CodeGenTreeWalker.g3:329:1: atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix] returns [Template code] : ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, $label, $astSuffix] ) | set[$label, $astSuffix] );
	[GrammarRule("atom")]
	private CodeGenTreeWalker.atom_return atom(GrammarAST scope, GrammarAST label, GrammarAST astSuffix)
	{
		EnterRule_atom();
		EnterRule("atom", 21);
		TraceIn("atom", 21);
		CodeGenTreeWalker.atom_return retval = new CodeGenTreeWalker.atom_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST r = default(GrammarAST);
		GrammarAST rarg = default(GrammarAST);
		GrammarAST t = default(GrammarAST);
		GrammarAST targ = default(GrammarAST);
		GrammarAST c = default(GrammarAST);
		GrammarAST s = default(GrammarAST);
		GrammarAST w = default(GrammarAST);
		GrammarAST ID12 = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> a = default(TreeRuleReturnScope<GrammarAST>);
		Template set13 = default(Template);


			string labelText;
			HandleAtomInit(retval.Start, label, ref astSuffix, out labelText);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(329, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:336:2: ( ^(r= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL |w= WILDCARD | ^( DOT ID a= atom[$ID, $label, $astSuffix] ) | set[$label, $astSuffix] )
			int alt55=7;
			try { DebugEnterDecision(55, false);
			switch (input.LA(1))
			{
			case RULE_REF:
				{
				alt55 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt55 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt55 = 3;
				}
				break;
			case STRING_LITERAL:
				{
				alt55 = 4;
				}
				break;
			case WILDCARD:
				{
				alt55 = 5;
				}
				break;
			case DOT:
				{
				alt55 = 6;
				}
				break;
			case BLOCK:
				{
				alt55 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 55, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:336:6: ^(r= RULE_REF (rarg= ARG_ACTION )? )
				{
				DebugLocation(336, 6);
				DebugLocation(336, 10);
				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1455); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(336, 20);
					// Grammars\\CodeGenTreeWalker.g3:336:20: (rarg= ARG_ACTION )?
					int alt53=2;
					try { DebugEnterSubRule(53);
					try { DebugEnterDecision(53, false);
					int LA53_1 = input.LA(1);

					if ((LA53_1==ARG_ACTION))
					{
						alt53 = 1;
					}
					} finally { DebugExitDecision(53); }
					switch (alt53)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:336:21: rarg= ARG_ACTION
						{
						DebugLocation(336, 25);
						rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1460); if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(53); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(336, 42);
				if (state.backtracking == 0)
				{
					HandleAtomRuleReference(scope, label, astSuffix, out retval.code, labelText, r, rarg);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:337:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
				{
				DebugLocation(337, 4);
				DebugLocation(337, 8);
				t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1476); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(337, 19);
					// Grammars\\CodeGenTreeWalker.g3:337:19: (targ= ARG_ACTION )?
					int alt54=2;
					try { DebugEnterSubRule(54);
					try { DebugEnterDecision(54, false);
					int LA54_1 = input.LA(1);

					if ((LA54_1==ARG_ACTION))
					{
						alt54 = 1;
					}
					} finally { DebugExitDecision(54); }
					switch (alt54)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:337:20: targ= ARG_ACTION
						{
						DebugLocation(337, 24);
						targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1481); if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(54); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}

				DebugLocation(337, 41);
				if (state.backtracking == 0)
				{
					HandleAtomTokenReference(scope, label, astSuffix, out retval.code, labelText, t, targ);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:338:4: c= CHAR_LITERAL
				{
				DebugLocation(338, 5);
				c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1495); if (state.failed) return retval;
				DebugLocation(338, 25);
				if (state.backtracking == 0)
				{
					HandleAtomCharLiteral(label, astSuffix, out retval.code, labelText, c);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:339:4: s= STRING_LITERAL
				{
				DebugLocation(339, 5);
				s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1510); if (state.failed) return retval;
				DebugLocation(339, 26);
				if (state.backtracking == 0)
				{
					HandleAtomStringLiteral(label, astSuffix, out retval.code, labelText, s);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\CodeGenTreeWalker.g3:340:4: w= WILDCARD
				{
				DebugLocation(340, 5);
				w=(GrammarAST)Match(input,WILDCARD,Follow._WILDCARD_in_atom1524); if (state.failed) return retval;
				DebugLocation(340, 22);
				if (state.backtracking == 0)
				{
					HandleAtomWildcard(astSuffix, out retval.code, labelText, w);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\CodeGenTreeWalker.g3:341:4: ^( DOT ID a= atom[$ID, $label, $astSuffix] )
				{
				DebugLocation(341, 4);
				DebugLocation(341, 6);
				Match(input,DOT,Follow._DOT_in_atom1539); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(341, 10);
				ID12=(GrammarAST)Match(input,ID,Follow._ID_in_atom1541); if (state.failed) return retval;
				DebugLocation(341, 14);
				PushFollow(Follow._atom_in_atom1545);
				a=atom(ID12, label, astSuffix);
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(342, 13);
				if (state.backtracking == 0)
				{
					 retval.code = (a!=null?((CodeGenTreeWalker.atom_return)a).code:default(Template)); 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\CodeGenTreeWalker.g3:343:4: set[$label, $astSuffix]
				{
				DebugLocation(343, 4);
				PushFollow(Follow._set_in_atom1567);
				set13=set(label, astSuffix);
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(343, 32);
				if (state.backtracking == 0)
				{
					 retval.code = set13; 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 21);
			LeaveRule("atom", 21);
			LeaveRule_atom();
		}
		DebugLocation(344, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_ast_suffix();
	partial void LeaveRule_ast_suffix();
	// $ANTLR start "ast_suffix"
	// Grammars\\CodeGenTreeWalker.g3:346:1: ast_suffix : ( ROOT | BANG );
	[GrammarRule("ast_suffix")]
	private void ast_suffix()
	{
		EnterRule_ast_suffix();
		EnterRule("ast_suffix", 22);
		TraceIn("ast_suffix", 22);
		try { DebugEnterRule(GrammarFileName, "ast_suffix");
		DebugLocation(346, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:347:2: ( ROOT | BANG )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:
			{
			DebugLocation(347, 2);
			if (input.LA(1)==BANG||input.LA(1)==ROOT)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ast_suffix", 22);
			LeaveRule("ast_suffix", 22);
			LeaveRule_ast_suffix();
		}
		DebugLocation(349, 1);
		} finally { DebugExitRule(GrammarFileName, "ast_suffix"); }
		return;

	}
	// $ANTLR end "ast_suffix"

	partial void EnterRule_set();
	partial void LeaveRule_set();
	// $ANTLR start "set"
	// Grammars\\CodeGenTreeWalker.g3:351:1: set[GrammarAST label, GrammarAST astSuffix] returns [Template code] : ^(s= BLOCK ( . )* ) ;
	[GrammarRule("set")]
	private Template set(GrammarAST label, GrammarAST astSuffix)
	{
		EnterRule_set();
		EnterRule("set", 23);
		TraceIn("set", 23);
		Template code = default(Template);


		GrammarAST s = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "set");
		DebugLocation(351, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:352:2: ( ^(s= BLOCK ( . )* ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:353:3: ^(s= BLOCK ( . )* )
			{
			DebugLocation(353, 3);
			DebugLocation(353, 6);
			s=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_set1612); if (state.failed) return code;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return code;
				DebugLocation(353, 13);
				// Grammars\\CodeGenTreeWalker.g3:353:13: ( . )*
				try { DebugEnterSubRule(56);
				while (true)
				{
					int alt56=2;
					try { DebugEnterDecision(56, false);
					int LA56_1 = input.LA(1);

					if (((LA56_1>=ACTION && LA56_1<=XDIGIT)))
					{
						alt56 = 1;
					}
					else if ((LA56_1==UP))
					{
						alt56 = 2;
					}


					} finally { DebugExitDecision(56); }
					switch ( alt56 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\CodeGenTreeWalker.g3:353:13: .
						{
						DebugLocation(353, 13);
						MatchAny(input); if (state.failed) return code;

						}
						break;

					default:
						goto loop56;
					}
				}

				loop56:
					;

				} finally { DebugExitSubRule(56); }


				Match(input, TokenTypes.Up, null); if (state.failed) return code;
			}

			DebugLocation(353, 23);
			if (state.backtracking == 0)
			{
				HandleSet(label, astSuffix, out code, s);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("set", 23);
			LeaveRule("set", 23);
			LeaveRule_set();
		}
		DebugLocation(354, 1);
		} finally { DebugExitRule(GrammarFileName, "set"); }
		return code;

	}
	// $ANTLR end "set"

	partial void EnterRule_setElement();
	partial void LeaveRule_setElement();
	// $ANTLR start "setElement"
	// Grammars\\CodeGenTreeWalker.g3:356:1: setElement : ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) );
	[GrammarRule("setElement")]
	private void setElement()
	{
		EnterRule_setElement();
		EnterRule("setElement", 24);
		TraceIn("setElement", 24);
		try { DebugEnterRule(GrammarFileName, "setElement");
		DebugLocation(356, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:357:2: ( CHAR_LITERAL | TOKEN_REF | STRING_LITERAL | ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL ) )
			int alt57=4;
			try { DebugEnterDecision(57, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				alt57 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt57 = 2;
				}
				break;
			case STRING_LITERAL:
				{
				alt57 = 3;
				}
				break;
			case CHAR_RANGE:
				{
				alt57 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:357:4: CHAR_LITERAL
				{
				DebugLocation(357, 4);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1635); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:358:4: TOKEN_REF
				{
				DebugLocation(358, 4);
				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_setElement1640); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:359:4: STRING_LITERAL
				{
				DebugLocation(359, 4);
				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_setElement1645); if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:360:4: ^( CHAR_RANGE CHAR_LITERAL CHAR_LITERAL )
				{
				DebugLocation(360, 4);
				DebugLocation(360, 6);
				Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_setElement1651); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(360, 17);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1653); if (state.failed) return;
				DebugLocation(360, 30);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_setElement1655); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("setElement", 24);
			LeaveRule("setElement", 24);
			LeaveRule_setElement();
		}
		DebugLocation(361, 1);
		} finally { DebugExitRule(GrammarFileName, "setElement"); }
		return;

	}
	// $ANTLR end "setElement"

	private sealed partial class rewrite_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public rewrite_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_rewrite();
	partial void LeaveRule_rewrite();
	// $ANTLR start "rewrite"
	// Grammars\\CodeGenTreeWalker.g3:365:1: rewrite returns [Template code] : ( ^( REWRITES ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* ) |);
	[GrammarRule("rewrite")]
	private CodeGenTreeWalker.rewrite_return rewrite()
	{
		EnterRule_rewrite();
		EnterRule("rewrite", 25);
		TraceIn("rewrite", 25);
		CodeGenTreeWalker.rewrite_return retval = new CodeGenTreeWalker.rewrite_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST r = default(GrammarAST);
		GrammarAST pred = default(GrammarAST);
		Template alt = default(Template);


		HandleRewriteInit(out retval.code, retval.Start);

		try { DebugEnterRule(GrammarFileName, "rewrite");
		DebugLocation(365, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:370:2: ( ^( REWRITES ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* ) |)
			int alt60=2;
			try { DebugEnterDecision(60, false);
			int LA60_1 = input.LA(1);

			if ((LA60_1==REWRITES))
			{
				alt60 = 1;
			}
			else if ((LA60_1==ALT||LA60_1==EOB))
			{
				alt60 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 60, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:370:4: ^( REWRITES ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )* )
				{
				DebugLocation(370, 4);
				DebugLocation(370, 7);
				Match(input,REWRITES,Follow._REWRITES_in_rewrite1680); if (state.failed) return retval;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return retval;
					DebugLocation(371, 4);
					// Grammars\\CodeGenTreeWalker.g3:371:4: ( ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative ) )*
					try { DebugEnterSubRule(59);
					while (true)
					{
						int alt59=2;
						try { DebugEnterDecision(59, false);
						int LA59_1 = input.LA(1);

						if ((LA59_1==REWRITE))
						{
							alt59 = 1;
						}


						} finally { DebugExitDecision(59); }
						switch ( alt59 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:372:19: ^(r= REWRITE (pred= SEMPRED )? alt= rewrite_alternative )
							{
							DebugLocation(372, 19);
							if (state.backtracking == 0)
							{
								HandleRewriteBeforeRewrite();
							}
							DebugLocation(373, 5);
							DebugLocation(373, 9);
							r=(GrammarAST)Match(input,REWRITE,Follow._REWRITE_in_rewrite1715); if (state.failed) return retval;

							Match(input, TokenTypes.Down, null); if (state.failed) return retval;
							DebugLocation(373, 18);
							// Grammars\\CodeGenTreeWalker.g3:373:18: (pred= SEMPRED )?
							int alt58=2;
							try { DebugEnterSubRule(58);
							try { DebugEnterDecision(58, false);
							int LA58_1 = input.LA(1);

							if ((LA58_1==SEMPRED))
							{
								alt58 = 1;
							}
							} finally { DebugExitDecision(58); }
							switch (alt58)
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\CodeGenTreeWalker.g3:373:19: pred= SEMPRED
								{
								DebugLocation(373, 23);
								pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1720); if (state.failed) return retval;

								}
								break;

							}
							} finally { DebugExitSubRule(58); }

							DebugLocation(373, 37);
							PushFollow(Follow._rewrite_alternative_in_rewrite1726);
							alt=rewrite_alternative();
							PopFollow();
							if (state.failed) return retval;

							Match(input, TokenTypes.Up, null); if (state.failed) return retval;

							DebugLocation(373, 59);
							if (state.backtracking == 0)
							{
								HandleRewriteAfterRewrite(retval.code, r, ref pred, alt);
							}

							}
							break;

						default:
							goto loop59;
						}
					}

					loop59:
						;

					} finally { DebugExitSubRule(59); }


					Match(input, TokenTypes.Up, null); if (state.failed) return retval;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:377:2: 
				{
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite", 25);
			LeaveRule("rewrite", 25);
			LeaveRule_rewrite();
		}
		DebugLocation(377, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite"); }
		return retval;

	}
	// $ANTLR end "rewrite"

	partial void EnterRule_rewrite_block();
	partial void LeaveRule_rewrite_block();
	// $ANTLR start "rewrite_block"
	// Grammars\\CodeGenTreeWalker.g3:379:1: rewrite_block[string blockTemplateName] returns [Template code] : ^( BLOCK alt= rewrite_alternative EOB ) ;
	[GrammarRule("rewrite_block")]
	private Template rewrite_block(string blockTemplateName)
	{
		EnterRule_rewrite_block();
		EnterRule("rewrite_block", 26);
		TraceIn("rewrite_block", 26);
		Template code = default(Template);


		GrammarAST BLOCK14 = default(GrammarAST);
		Template alt = default(Template);


			rewriteBlockNestingLevel++;
			Template save_currentBlockST = currentBlockST;
			if ( state.backtracking == 0 )
			{
				code = templates.GetInstanceOf(blockTemplateName);
				currentBlockST = code;
				code.SetAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
			}

		try { DebugEnterRule(GrammarFileName, "rewrite_block");
		DebugLocation(379, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:391:2: ( ^( BLOCK alt= rewrite_alternative EOB ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:391:4: ^( BLOCK alt= rewrite_alternative EOB )
			{
			DebugLocation(391, 4);
			DebugLocation(391, 7);
			BLOCK14=(GrammarAST)Match(input,BLOCK,Follow._BLOCK_in_rewrite_block1765); if (state.failed) return code;

			DebugLocation(392, 4);
			if (state.backtracking == 0)
			{

								currentBlockST.SetAttribute("referencedElementsDeep",
									GetTokenTypesAsTargetLabels(BLOCK14.rewriteRefsDeep));
								currentBlockST.SetAttribute("referencedElements",
									GetTokenTypesAsTargetLabels(BLOCK14.rewriteRefsShallow));
							
			}

			Match(input, TokenTypes.Down, null); if (state.failed) return code;
			DebugLocation(398, 7);
			PushFollow(Follow._rewrite_alternative_in_rewrite_block1777);
			alt=rewrite_alternative();
			PopFollow();
			if (state.failed) return code;
			DebugLocation(399, 4);
			Match(input,EOB,Follow._EOB_in_rewrite_block1782); if (state.failed) return code;

			Match(input, TokenTypes.Up, null); if (state.failed) return code;

			DebugLocation(401, 3);
			if (state.backtracking == 0)
			{

							code.SetAttribute("alt", alt);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_block", 26);
			LeaveRule("rewrite_block", 26);
			LeaveRule_rewrite_block();
			 rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; 
		}
		DebugLocation(404, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_block"); }
		return code;

	}
	// $ANTLR end "rewrite_block"

	partial void EnterRule_rewrite_alternative();
	partial void LeaveRule_rewrite_alternative();
	// $ANTLR start "rewrite_alternative"
	// Grammars\\CodeGenTreeWalker.g3:407:1: rewrite_alternative returns [Template code] : ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC );
	[GrammarRule("rewrite_alternative")]
	private Template rewrite_alternative()
	{
		EnterRule_rewrite_alternative();
		EnterRule("rewrite_alternative", 27);
		TraceIn("rewrite_alternative", 27);
		Template code = default(Template);


		GrammarAST a = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> el = default(TreeRuleReturnScope<GrammarAST>);
		Template rewrite_template15 = default(Template);

		try { DebugEnterRule(GrammarFileName, "rewrite_alternative");
		DebugLocation(407, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:408:2: ({...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA ) |{...}? rewrite_template | ETC )
			int alt63=3;
			try { DebugEnterDecision(63, false);
			switch (input.LA(1))
			{
			case ALT:
				{
				int LA63_2 = input.LA(2);

				if ((LA63_2==DOWN))
				{
					int LA63_3 = input.LA(3);

					if ((LA63_3==EPSILON))
					{
						int LA63_4 = input.LA(4);

						if ((LA63_4==EOA))
						{
							int LA63_5 = input.LA(5);

							if ((LA63_5==UP))
							{
								int LA63_6 = input.LA(6);

								if (((generator.Grammar.BuildAST)))
								{
									alt63 = 1;
								}
								else if (((generator.Grammar.BuildTemplate)))
								{
									alt63 = 2;
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return code;}
									NoViableAltException nvae = new NoViableAltException("", 63, 8, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return code;}
								NoViableAltException nvae = new NoViableAltException("", 63, 7, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return code;}
							NoViableAltException nvae = new NoViableAltException("", 63, 5, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA63_3==ACTION||LA63_3==CHAR_LITERAL||LA63_3==CLOSURE||LA63_3==LABEL||LA63_3==OPTIONAL||LA63_3==POSITIVE_CLOSURE||LA63_3==RULE_REF||LA63_3==STRING_LITERAL||LA63_3==TOKEN_REF||LA63_3==TREE_BEGIN))
					{
						alt63 = 1;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return code;}
						NoViableAltException nvae = new NoViableAltException("", 63, 4, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					NoViableAltException nvae = new NoViableAltException("", 63, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case ACTION:
			case TEMPLATE:
				{
				alt63 = 2;
				}
				break;
			case ETC:
				{
				alt63 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					NoViableAltException nvae = new NoViableAltException("", 63, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:408:4: {...}? ^(a= ALT ( (el= rewrite_element )+ | EPSILON ) EOA )
				{
				DebugLocation(408, 4);
				if (!((generator.Grammar.BuildAST)))
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					throw new FailedPredicateException(input, "rewrite_alternative", "generator.Grammar.BuildAST");
				}
				DebugLocation(409, 3);
				DebugLocation(409, 7);
				a=(GrammarAST)Match(input,ALT,Follow._ALT_in_rewrite_alternative1817); if (state.failed) return code;

				DebugLocation(409, 12);
				if (state.backtracking == 0)
				{
					code =templates.GetInstanceOf("rewriteElementList");
				}

				Match(input, TokenTypes.Down, null); if (state.failed) return code;
				DebugLocation(410, 4);
				// Grammars\\CodeGenTreeWalker.g3:410:4: ( (el= rewrite_element )+ | EPSILON )
				int alt62=2;
				try { DebugEnterSubRule(62);
				try { DebugEnterDecision(62, false);
				int LA62_1 = input.LA(1);

				if ((LA62_1==ACTION||LA62_1==CHAR_LITERAL||LA62_1==CLOSURE||LA62_1==LABEL||LA62_1==OPTIONAL||LA62_1==POSITIVE_CLOSURE||LA62_1==RULE_REF||LA62_1==STRING_LITERAL||LA62_1==TOKEN_REF||LA62_1==TREE_BEGIN))
				{
					alt62 = 1;
				}
				else if ((LA62_1==EPSILON))
				{
					alt62 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					NoViableAltException nvae = new NoViableAltException("", 62, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(62); }
				switch (alt62)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:410:6: (el= rewrite_element )+
					{
					DebugLocation(410, 6);
					// Grammars\\CodeGenTreeWalker.g3:410:6: (el= rewrite_element )+
					int cnt61=0;
					try { DebugEnterSubRule(61);
					while (true)
					{
						int alt61=2;
						try { DebugEnterDecision(61, false);
						int LA61_1 = input.LA(1);

						if ((LA61_1==ACTION||LA61_1==CHAR_LITERAL||LA61_1==CLOSURE||LA61_1==LABEL||LA61_1==OPTIONAL||LA61_1==POSITIVE_CLOSURE||LA61_1==RULE_REF||LA61_1==STRING_LITERAL||LA61_1==TOKEN_REF||LA61_1==TREE_BEGIN))
						{
							alt61 = 1;
						}


						} finally { DebugExitDecision(61); }
						switch (alt61)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:411:6: el= rewrite_element
							{
							DebugLocation(411, 8);
							PushFollow(Follow._rewrite_element_in_rewrite_alternative1835);
							el=rewrite_element();
							PopFollow();
							if (state.failed) return code;
							DebugLocation(412, 6);
							if (state.backtracking == 0)
							{
								code.SetAttribute("elements.{el,line,pos}",
																		(el!=null?((CodeGenTreeWalker.rewrite_element_return)el).code:default(Template)),
																		(el!=null?((GrammarAST)el.Start):default(GrammarAST)).Line,
																		(el!=null?((GrammarAST)el.Start):default(GrammarAST)).CharPositionInLine + 1
																		);
													
							}

							}
							break;

						default:
							if (cnt61 >= 1)
								goto loop61;

							if (state.backtracking>0) {state.failed=true; return code;}
							EarlyExitException eee61 = new EarlyExitException( 61, input );
							DebugRecognitionException(eee61);
							throw eee61;
						}
						cnt61++;
					}
					loop61:
						;

					} finally { DebugExitSubRule(61); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\CodeGenTreeWalker.g3:419:6: EPSILON
					{
					DebugLocation(419, 6);
					Match(input,EPSILON,Follow._EPSILON_in_rewrite_alternative1856); if (state.failed) return code;
					DebugLocation(420, 5);
					if (state.backtracking == 0)
					{
						code.SetAttribute("elements.{el,line,pos}",
														   templates.GetInstanceOf("rewriteEmptyAlt"),
														   a.Line,
														   a.CharPositionInLine + 1
														   );
										
					}

					}
					break;

				}
				} finally { DebugExitSubRule(62); }

				DebugLocation(427, 4);
				Match(input,EOA,Follow._EOA_in_rewrite_alternative1872); if (state.failed) return code;

				Match(input, TokenTypes.Up, null); if (state.failed) return code;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:430:4: {...}? rewrite_template
				{
				DebugLocation(430, 4);
				if (!((generator.Grammar.BuildTemplate)))
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					throw new FailedPredicateException(input, "rewrite_alternative", "generator.Grammar.BuildTemplate");
				}
				DebugLocation(430, 39);
				PushFollow(Follow._rewrite_template_in_rewrite_alternative1885);
				rewrite_template15=rewrite_template();
				PopFollow();
				if (state.failed) return code;
				DebugLocation(431, 3);
				if (state.backtracking == 0)
				{
					 code = rewrite_template15; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:434:3: ETC
				{
				DebugLocation(434, 3);
				Match(input,ETC,Follow._ETC_in_rewrite_alternative1898); if (state.failed) return code;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_alternative", 27);
			LeaveRule("rewrite_alternative", 27);
			LeaveRule_rewrite_alternative();
		}
		DebugLocation(435, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_alternative"); }
		return code;

	}
	// $ANTLR end "rewrite_alternative"

	private sealed partial class rewrite_element_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public rewrite_element_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_rewrite_element();
	partial void LeaveRule_rewrite_element();
	// $ANTLR start "rewrite_element"
	// Grammars\\CodeGenTreeWalker.g3:437:1: rewrite_element returns [Template code] : ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree );
	[GrammarRule("rewrite_element")]
	private CodeGenTreeWalker.rewrite_element_return rewrite_element()
	{
		EnterRule_rewrite_element();
		EnterRule("rewrite_element", 28);
		TraceIn("rewrite_element", 28);
		CodeGenTreeWalker.rewrite_element_return retval = new CodeGenTreeWalker.rewrite_element_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> rewrite_atom16 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> rewrite_ebnf17 = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> rewrite_tree18 = default(TreeRuleReturnScope<GrammarAST>);


			IIntSet elements=null;
			GrammarAST ast = null;

		try { DebugEnterRule(GrammarFileName, "rewrite_element");
		DebugLocation(437, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:443:2: ( rewrite_atom[false] | rewrite_ebnf | rewrite_tree )
			int alt64=3;
			try { DebugEnterDecision(64, false);
			switch (input.LA(1))
			{
			case ACTION:
			case CHAR_LITERAL:
			case LABEL:
			case RULE_REF:
			case STRING_LITERAL:
			case TOKEN_REF:
				{
				alt64 = 1;
				}
				break;
			case CLOSURE:
			case OPTIONAL:
			case POSITIVE_CLOSURE:
				{
				alt64 = 2;
				}
				break;
			case TREE_BEGIN:
				{
				alt64 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 64, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:443:4: rewrite_atom[false]
				{
				DebugLocation(443, 4);
				PushFollow(Follow._rewrite_atom_in_rewrite_element1918);
				rewrite_atom16=rewrite_atom(false);
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(443, 25);
				if (state.backtracking == 0)
				{
					 retval.code = (rewrite_atom16!=null?((CodeGenTreeWalker.rewrite_atom_return)rewrite_atom16).code:default(Template)); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:444:4: rewrite_ebnf
				{
				DebugLocation(444, 4);
				PushFollow(Follow._rewrite_ebnf_in_rewrite_element1927);
				rewrite_ebnf17=rewrite_ebnf();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(444, 19);
				if (state.backtracking == 0)
				{
					 retval.code = (rewrite_ebnf17!=null?((CodeGenTreeWalker.rewrite_ebnf_return)rewrite_ebnf17).code:default(Template)); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:445:4: rewrite_tree
				{
				DebugLocation(445, 4);
				PushFollow(Follow._rewrite_tree_in_rewrite_element1936);
				rewrite_tree18=rewrite_tree();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(445, 19);
				if (state.backtracking == 0)
				{
					 retval.code = (rewrite_tree18!=null?((CodeGenTreeWalker.rewrite_tree_return)rewrite_tree18).code:default(Template)); 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_element", 28);
			LeaveRule("rewrite_element", 28);
			LeaveRule_rewrite_element();
		}
		DebugLocation(446, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_element"); }
		return retval;

	}
	// $ANTLR end "rewrite_element"

	private sealed partial class rewrite_ebnf_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public rewrite_ebnf_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_rewrite_ebnf();
	partial void LeaveRule_rewrite_ebnf();
	// $ANTLR start "rewrite_ebnf"
	// Grammars\\CodeGenTreeWalker.g3:448:1: rewrite_ebnf returns [Template code] : ( ^( OPTIONAL b= rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE b= rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE b= rewrite_block[\"rewritePositiveClosureBlock\"] ) ) ;
	[GrammarRule("rewrite_ebnf")]
	private CodeGenTreeWalker.rewrite_ebnf_return rewrite_ebnf()
	{
		EnterRule_rewrite_ebnf();
		EnterRule("rewrite_ebnf", 29);
		TraceIn("rewrite_ebnf", 29);
		CodeGenTreeWalker.rewrite_ebnf_return retval = new CodeGenTreeWalker.rewrite_ebnf_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		Template b = default(Template);

		try { DebugEnterRule(GrammarFileName, "rewrite_ebnf");
		DebugLocation(448, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:449:2: ( ( ^( OPTIONAL b= rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE b= rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE b= rewrite_block[\"rewritePositiveClosureBlock\"] ) ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:449:4: ( ^( OPTIONAL b= rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE b= rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE b= rewrite_block[\"rewritePositiveClosureBlock\"] ) )
			{
			DebugLocation(449, 4);
			// Grammars\\CodeGenTreeWalker.g3:449:4: ( ^( OPTIONAL b= rewrite_block[\"rewriteOptionalBlock\"] ) | ^( CLOSURE b= rewrite_block[\"rewriteClosureBlock\"] ) | ^( POSITIVE_CLOSURE b= rewrite_block[\"rewritePositiveClosureBlock\"] ) )
			int alt65=3;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			switch (input.LA(1))
			{
			case OPTIONAL:
				{
				alt65 = 1;
				}
				break;
			case CLOSURE:
				{
				alt65 = 2;
				}
				break;
			case POSITIVE_CLOSURE:
				{
				alt65 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 65, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:449:6: ^( OPTIONAL b= rewrite_block[\"rewriteOptionalBlock\"] )
				{
				DebugLocation(449, 6);
				DebugLocation(449, 8);
				Match(input,OPTIONAL,Follow._OPTIONAL_in_rewrite_ebnf1958); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(449, 18);
				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1962);
				b=rewrite_block("rewriteOptionalBlock");
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:450:5: ^( CLOSURE b= rewrite_block[\"rewriteClosureBlock\"] )
				{
				DebugLocation(450, 5);
				DebugLocation(450, 7);
				Match(input,CLOSURE,Follow._CLOSURE_in_rewrite_ebnf1971); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(450, 16);
				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1975);
				b=rewrite_block("rewriteClosureBlock");
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:451:5: ^( POSITIVE_CLOSURE b= rewrite_block[\"rewritePositiveClosureBlock\"] )
				{
				DebugLocation(451, 5);
				DebugLocation(451, 7);
				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_rewrite_ebnf1984); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(451, 25);
				PushFollow(Follow._rewrite_block_in_rewrite_ebnf1988);
				b=rewrite_block("rewritePositiveClosureBlock");
				PopFollow();
				if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;


				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(453, 3);
			if (state.backtracking == 0)
			{
				HandleRewriteEbnf(out retval.code, retval.Start, b);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_ebnf", 29);
			LeaveRule("rewrite_ebnf", 29);
			LeaveRule_rewrite_ebnf();
		}
		DebugLocation(454, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_ebnf"); }
		return retval;

	}
	// $ANTLR end "rewrite_ebnf"

	private sealed partial class rewrite_tree_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public rewrite_tree_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_rewrite_tree();
	partial void LeaveRule_rewrite_tree();
	// $ANTLR start "rewrite_tree"
	// Grammars\\CodeGenTreeWalker.g3:456:1: rewrite_tree returns [Template code] : ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) ;
	[GrammarRule("rewrite_tree")]
	private CodeGenTreeWalker.rewrite_tree_return rewrite_tree()
	{
		EnterRule_rewrite_tree();
		EnterRule("rewrite_tree", 30);
		TraceIn("rewrite_tree", 30);
		CodeGenTreeWalker.rewrite_tree_return retval = new CodeGenTreeWalker.rewrite_tree_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> r = default(TreeRuleReturnScope<GrammarAST>);
		TreeRuleReturnScope<GrammarAST> el = default(TreeRuleReturnScope<GrammarAST>);


			rewriteTreeNestingLevel++;
			if ( state.backtracking == 0 )
			{
				retval.code = templates.GetInstanceOf("rewriteTree");
				retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
				retval.code.SetAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
			}

		try { DebugEnterRule(GrammarFileName, "rewrite_tree");
		DebugLocation(456, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:467:2: ( ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* ) )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:467:4: ^( TREE_BEGIN r= rewrite_atom[true] (el= rewrite_element )* )
			{
			DebugLocation(467, 4);
			DebugLocation(467, 7);
			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree2020); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(468, 5);
			PushFollow(Follow._rewrite_atom_in_rewrite_tree2027);
			r=rewrite_atom(true);
			PopFollow();
			if (state.failed) return retval;
			DebugLocation(469, 4);
			if (state.backtracking == 0)
			{

								retval.code.SetAttribute("root.{el,line,pos}",
												   (r!=null?((CodeGenTreeWalker.rewrite_atom_return)r).code:default(Template)),
												   (r!=null?((GrammarAST)r.Start):default(GrammarAST)).Line,
												   (r!=null?((GrammarAST)r.Start):default(GrammarAST)).CharPositionInLine + 1
												  );
							
			}
			DebugLocation(476, 4);
			// Grammars\\CodeGenTreeWalker.g3:476:4: (el= rewrite_element )*
			try { DebugEnterSubRule(66);
			while (true)
			{
				int alt66=2;
				try { DebugEnterDecision(66, false);
				int LA66_1 = input.LA(1);

				if ((LA66_1==ACTION||LA66_1==CHAR_LITERAL||LA66_1==CLOSURE||LA66_1==LABEL||LA66_1==OPTIONAL||LA66_1==POSITIVE_CLOSURE||LA66_1==RULE_REF||LA66_1==STRING_LITERAL||LA66_1==TOKEN_REF||LA66_1==TREE_BEGIN))
				{
					alt66 = 1;
				}


				} finally { DebugExitDecision(66); }
				switch ( alt66 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:477:6: el= rewrite_element
					{
					DebugLocation(477, 8);
					PushFollow(Follow._rewrite_element_in_rewrite_tree2047);
					el=rewrite_element();
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(478, 6);
					if (state.backtracking == 0)
					{

										retval.code.SetAttribute("children.{el,line,pos}",
															(el!=null?((CodeGenTreeWalker.rewrite_element_return)el).code:default(Template)),
															(el!=null?((GrammarAST)el.Start):default(GrammarAST)).Line,
															(el!=null?((GrammarAST)el.Start):default(GrammarAST)).CharPositionInLine + 1
															);
									  
					}

					}
					break;

				default:
					goto loop66;
				}
			}

			loop66:
				;

			} finally { DebugExitSubRule(66); }


			Match(input, TokenTypes.Up, null); if (state.failed) return retval;

			DebugLocation(487, 3);
			if (state.backtracking == 0)
			{

							string description = grammar.GrammarTreeToString(retval.Start, false);
							description = generator.Target.GetTargetStringLiteralFromString(description);
							retval.code.SetAttribute("description", description);
						
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_tree", 30);
			LeaveRule("rewrite_tree", 30);
			LeaveRule_rewrite_tree();
			 rewriteTreeNestingLevel--; 
		}
		DebugLocation(492, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_tree"); }
		return retval;

	}
	// $ANTLR end "rewrite_tree"

	private sealed partial class rewrite_atom_return : TreeRuleReturnScope<GrammarAST>
	{
		public Template code;
		public rewrite_atom_return(CodeGenTreeWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(CodeGenTreeWalker grammar);
	}

	partial void EnterRule_rewrite_atom();
	partial void LeaveRule_rewrite_atom();
	// $ANTLR start "rewrite_atom"
	// Grammars\\CodeGenTreeWalker.g3:495:1: rewrite_atom[bool isRoot] returns [Template code] : (r= RULE_REF | ( ^(term= TOKEN_REF (arg= ARG_ACTION )? ) |term= CHAR_LITERAL |term= STRING_LITERAL ) | LABEL | ACTION );
	[GrammarRule("rewrite_atom")]
	private CodeGenTreeWalker.rewrite_atom_return rewrite_atom(bool isRoot)
	{
		EnterRule_rewrite_atom();
		EnterRule("rewrite_atom", 31);
		TraceIn("rewrite_atom", 31);
		CodeGenTreeWalker.rewrite_atom_return retval = new CodeGenTreeWalker.rewrite_atom_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		GrammarAST r = default(GrammarAST);
		GrammarAST term = default(GrammarAST);
		GrammarAST arg = default(GrammarAST);
		GrammarAST LABEL19 = default(GrammarAST);
		GrammarAST ACTION20 = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "rewrite_atom");
		DebugLocation(495, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:496:2: (r= RULE_REF | ( ^(term= TOKEN_REF (arg= ARG_ACTION )? ) |term= CHAR_LITERAL |term= STRING_LITERAL ) | LABEL | ACTION )
			int alt69=4;
			try { DebugEnterDecision(69, false);
			switch (input.LA(1))
			{
			case RULE_REF:
				{
				alt69 = 1;
				}
				break;
			case CHAR_LITERAL:
			case STRING_LITERAL:
			case TOKEN_REF:
				{
				alt69 = 2;
				}
				break;
			case LABEL:
				{
				alt69 = 3;
				}
				break;
			case ACTION:
				{
				alt69 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 69, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:496:6: r= RULE_REF
				{
				DebugLocation(496, 7);
				r=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom2092); if (state.failed) return retval;
				DebugLocation(496, 24);
				if (state.backtracking == 0)
				{
					HandleRewriteAtomRuleReference(isRoot, out retval.code, r);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:497:4: ( ^(term= TOKEN_REF (arg= ARG_ACTION )? ) |term= CHAR_LITERAL |term= STRING_LITERAL )
				{
				DebugLocation(497, 4);
				// Grammars\\CodeGenTreeWalker.g3:497:4: ( ^(term= TOKEN_REF (arg= ARG_ACTION )? ) |term= CHAR_LITERAL |term= STRING_LITERAL )
				int alt68=3;
				try { DebugEnterSubRule(68);
				try { DebugEnterDecision(68, false);
				switch (input.LA(1))
				{
				case TOKEN_REF:
					{
					alt68 = 1;
					}
					break;
				case CHAR_LITERAL:
					{
					alt68 = 2;
					}
					break;
				case STRING_LITERAL:
					{
					alt68 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 68, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(68); }
				switch (alt68)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:497:6: ^(term= TOKEN_REF (arg= ARG_ACTION )? )
					{
					DebugLocation(497, 6);
					DebugLocation(497, 12);
					term=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom2111); if (state.failed) return retval;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return retval;
						DebugLocation(497, 23);
						// Grammars\\CodeGenTreeWalker.g3:497:23: (arg= ARG_ACTION )?
						int alt67=2;
						try { DebugEnterSubRule(67);
						try { DebugEnterDecision(67, false);
						int LA67_1 = input.LA(1);

						if ((LA67_1==ARG_ACTION))
						{
							alt67 = 1;
						}
						} finally { DebugExitDecision(67); }
						switch (alt67)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:497:24: arg= ARG_ACTION
							{
							DebugLocation(497, 27);
							arg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom2116); if (state.failed) return retval;

							}
							break;

						}
						} finally { DebugExitSubRule(67); }


						Match(input, TokenTypes.Up, null); if (state.failed) return retval;
					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\CodeGenTreeWalker.g3:498:5: term= CHAR_LITERAL
					{
					DebugLocation(498, 9);
					term=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom2127); if (state.failed) return retval;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Grammars\\CodeGenTreeWalker.g3:499:5: term= STRING_LITERAL
					{
					DebugLocation(499, 9);
					term=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom2135); if (state.failed) return retval;

					}
					break;

				}
				} finally { DebugExitSubRule(68); }

				DebugLocation(500, 14);
				if (state.backtracking == 0)
				{
					HandleRewriteAtomTokenReference(isRoot, out retval.code, retval.Start, term, arg);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:501:4: LABEL
				{
				DebugLocation(501, 4);
				LABEL19=(GrammarAST)Match(input,LABEL,Follow._LABEL_in_rewrite_atom2155); if (state.failed) return retval;
				DebugLocation(501, 18);
				if (state.backtracking == 0)
				{
					HandleRewriteAtomLabel(isRoot, out retval.code, LABEL19);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\CodeGenTreeWalker.g3:502:4: ACTION
				{
				DebugLocation(502, 4);
				ACTION20=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_atom2170); if (state.failed) return retval;
				DebugLocation(502, 19);
				if (state.backtracking == 0)
				{
					HandleRewriteAtomAction(isRoot, out retval.code, ACTION20);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_atom", 31);
			LeaveRule("rewrite_atom", 31);
			LeaveRule_rewrite_atom();
		}
		DebugLocation(503, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_atom"); }
		return retval;

	}
	// $ANTLR end "rewrite_atom"

	partial void EnterRule_rewrite_template();
	partial void LeaveRule_rewrite_template();
	// $ANTLR start "rewrite_template"
	// Grammars\\CodeGenTreeWalker.g3:506:1: public rewrite_template returns [Template code] : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
	[GrammarRule("rewrite_template")]
	public Template rewrite_template()
	{
		EnterRule_rewrite_template();
		EnterRule("rewrite_template", 32);
		TraceIn("rewrite_template", 32);
		Template code = default(Template);


		GrammarAST id = default(GrammarAST);
		GrammarAST ind = default(GrammarAST);
		GrammarAST arg = default(GrammarAST);
		GrammarAST a = default(GrammarAST);
		GrammarAST act = default(GrammarAST);
		GrammarAST DOUBLE_QUOTE_STRING_LITERAL21 = default(GrammarAST);
		GrammarAST DOUBLE_ANGLE_STRING_LITERAL22 = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "rewrite_template");
		DebugLocation(506, 1);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:507:2: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
			int alt73=3;
			try { DebugEnterDecision(73, false);
			switch (input.LA(1))
			{
			case ALT:
				{
				alt73 = 1;
				}
				break;
			case TEMPLATE:
				{
				alt73 = 2;
				}
				break;
			case ACTION:
				{
				alt73 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					NoViableAltException nvae = new NoViableAltException("", 73, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\CodeGenTreeWalker.g3:507:4: ^( ALT EPSILON EOA )
				{
				DebugLocation(507, 4);
				DebugLocation(507, 6);
				Match(input,ALT,Follow._ALT_in_rewrite_template2198); if (state.failed) return code;

				Match(input, TokenTypes.Down, null); if (state.failed) return code;
				DebugLocation(507, 10);
				Match(input,EPSILON,Follow._EPSILON_in_rewrite_template2200); if (state.failed) return code;
				DebugLocation(507, 18);
				Match(input,EOA,Follow._EOA_in_rewrite_template2202); if (state.failed) return code;

				Match(input, TokenTypes.Up, null); if (state.failed) return code;

				DebugLocation(507, 27);
				if (state.backtracking == 0)
				{
					HandleRewriteTemplateAlt(out code);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\CodeGenTreeWalker.g3:508:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
				{
				DebugLocation(508, 4);
				DebugLocation(508, 7);
				Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template2216); if (state.failed) return code;

				Match(input, TokenTypes.Down, null); if (state.failed) return code;
				DebugLocation(508, 16);
				// Grammars\\CodeGenTreeWalker.g3:508:16: (id= ID |ind= ACTION )
				int alt70=2;
				try { DebugEnterSubRule(70);
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==ID))
				{
					alt70 = 1;
				}
				else if ((LA70_1==ACTION))
				{
					alt70 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return code;}
					NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(70); }
				switch (alt70)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:508:17: id= ID
					{
					DebugLocation(508, 19);
					id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template2221); if (state.failed) return code;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\CodeGenTreeWalker.g3:508:23: ind= ACTION
					{
					DebugLocation(508, 26);
					ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2225); if (state.failed) return code;

					}
					break;

				}
				} finally { DebugExitSubRule(70); }

				DebugLocation(508, 36);
				if (state.backtracking == 0)
				{
					HandleRewriteTemplateAfterId(out code, id, ind);
				}
				DebugLocation(509, 4);
				DebugLocation(509, 7);
				Match(input,ARGLIST,Follow._ARGLIST_in_rewrite_template2236); if (state.failed) return code;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return code;
					DebugLocation(510, 5);
					// Grammars\\CodeGenTreeWalker.g3:510:5: ( ^( ARG arg= ID a= ACTION ) )*
					try { DebugEnterSubRule(71);
					while (true)
					{
						int alt71=2;
						try { DebugEnterDecision(71, false);
						int LA71_1 = input.LA(1);

						if ((LA71_1==ARG))
						{
							alt71 = 1;
						}


						} finally { DebugExitDecision(71); }
						switch ( alt71 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\CodeGenTreeWalker.g3:510:7: ^( ARG arg= ID a= ACTION )
							{
							DebugLocation(510, 7);
							DebugLocation(510, 9);
							Match(input,ARG,Follow._ARG_in_rewrite_template2245); if (state.failed) return code;

							Match(input, TokenTypes.Down, null); if (state.failed) return code;
							DebugLocation(510, 16);
							arg=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template2249); if (state.failed) return code;
							DebugLocation(510, 21);
							a=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2253); if (state.failed) return code;

							Match(input, TokenTypes.Up, null); if (state.failed) return code;

							DebugLocation(510, 30);
							if (state.backtracking == 0)
							{
								HandleRewriteTemplateArg(code, arg, a);
							}

							}
							break;

						default:
							goto loop71;
						}
					}

					loop71:
						;

					} finally { DebugExitSubRule(71); }


					Match(input, TokenTypes.Up, null); if (state.failed) return code;
				}

				DebugLocation(513, 4);
				// Grammars\\CodeGenTreeWalker.g3:513:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
				int alt72=3;
				try { DebugEnterSubRule(72);
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==DOUBLE_QUOTE_STRING_LITERAL))
				{
					alt72 = 1;
				}
				else if ((LA72_1==DOUBLE_ANGLE_STRING_LITERAL))
				{
					alt72 = 2;
				}
				} finally { DebugExitDecision(72); }
				switch (alt72)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\CodeGenTreeWalker.g3:513:6: DOUBLE_QUOTE_STRING_LITERAL
					{
					DebugLocation(513, 6);
					DOUBLE_QUOTE_STRING_LITERAL21=(GrammarAST)Match(input,DOUBLE_QUOTE_STRING_LITERAL,Follow._DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2275); if (state.failed) return code;
					DebugLocation(513, 34);
					if (state.backtracking == 0)
					{
						HandleRewriteTemplateLiteral(code, DOUBLE_QUOTE_STRING_LITERAL21, 1);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Grammars\\CodeGenTreeWalker.g3:514:6: DOUBLE_ANGLE_STRING_LITERAL
					{
					DebugLocation(514, 6);
					DOUBLE_ANGLE_STRING_LITERAL22=(GrammarAST)Match(input,DOUBLE_ANGLE_STRING_LITERAL,Follow._DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2284); if (state.failed) return code;
					DebugLocation(514, 34);
					if (state.backtracking == 0)
					{
						HandleRewriteTemplateLiteral(code, DOUBLE_ANGLE_STRING_LITERAL22, 2);
					}

					}
					break;

				}
				} finally { DebugExitSubRule(72); }


				Match(input, TokenTypes.Up, null); if (state.failed) return code;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\CodeGenTreeWalker.g3:518:4: act= ACTION
				{
				DebugLocation(518, 7);
				act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template2304); if (state.failed) return code;
				DebugLocation(518, 21);
				if (state.backtracking == 0)
				{
					HandleRewriteTemplateAction(out code, act);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite_template", 32);
			LeaveRule("rewrite_template", 32);
			LeaveRule_rewrite_template();
		}
		DebugLocation(519, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite_template"); }
		return code;

	}
	// $ANTLR end "rewrite_template"

	partial void EnterRule_synpred1_CodeGenTreeWalker_fragment();
	partial void LeaveRule_synpred1_CodeGenTreeWalker_fragment();

	// $ANTLR start synpred1_CodeGenTreeWalker
	private void synpred1_CodeGenTreeWalker_fragment()
	{
		EnterRule_synpred1_CodeGenTreeWalker_fragment();
		EnterRule("synpred1_CodeGenTreeWalker_fragment", 33);
		TraceIn("synpred1_CodeGenTreeWalker_fragment", 33);
		try
		{
			// Grammars\\CodeGenTreeWalker.g3:306:6: ( element_action )
			DebugEnterAlt(1);
			// Grammars\\CodeGenTreeWalker.g3:306:7: element_action
			{
			DebugLocation(306, 7);
			PushFollow(Follow._element_action_in_synpred1_CodeGenTreeWalker1371);
			element_action();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_CodeGenTreeWalker_fragment", 33);
			LeaveRule("synpred1_CodeGenTreeWalker_fragment", 33);
			LeaveRule_synpred1_CodeGenTreeWalker_fragment();
		}
	}
	// $ANTLR end synpred1_CodeGenTreeWalker
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LEXER_GRAMMAR_in_grammar_66 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_68 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PARSER_GRAMMAR_in_grammar_78 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_80 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_GRAMMAR_in_grammar_90 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_92 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _COMBINED_GRAMMAR_in_grammar_102 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _grammarSpec_in_grammar_104 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SCOPE_in_attrScope123 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_attrScope125 = new BitSet(new ulong[]{0x210UL});
		public static readonly BitSet _AMPERSAND_in_attrScope130 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_attrScope139 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ID_in_grammarSpec154 = new BitSet(new ulong[]{0x400200008000200UL,0x20028002UL});
		public static readonly BitSet _DOC_COMMENT_in_grammarSpec162 = new BitSet(new ulong[]{0x400200000000200UL,0x20028002UL});
		public static readonly BitSet _OPTIONS_in_grammarSpec184 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IMPORT_in_grammarSpec198 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TOKENS_in_grammarSpec212 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _attrScope_in_grammarSpec224 = new BitSet(new ulong[]{0x200UL,0x28002UL});
		public static readonly BitSet _AMPERSAND_in_grammarSpec233 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rules_in_grammarSpec244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rule_in_rules289 = new BitSet(new ulong[]{0x2UL,0x8002UL});
		public static readonly BitSet _RULE_in_rules304 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _PREC_RULE_in_rules316 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _RULE_in_rule367 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rule371 = new BitSet(new ulong[]{0x10000000400UL,0x1CUL});
		public static readonly BitSet _modifier_in_rule386 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ARG_in_rule394 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rule397 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RET_in_rule406 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rule409 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _throwsSpec_in_rule418 = new BitSet(new ulong[]{0x400000000010200UL,0x20000UL});
		public static readonly BitSet _OPTIONS_in_rule428 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleScopeSpec_in_rule441 = new BitSet(new ulong[]{0x10200UL});
		public static readonly BitSet _AMPERSAND_in_rule451 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_rule465 = new BitSet(new ulong[]{0x4400020000UL});
		public static readonly BitSet _exceptionGroup_in_rule476 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _EOR_in_rule484 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _THROWS_in_throwsSpec543 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_throwsSpec545 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _SCOPE_in_ruleScopeSpec559 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _AMPERSAND_in_ruleScopeSpec564 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_ruleScopeSpec573 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _ID_in_ruleScopeSpec576 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _setBlock_in_block614 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_in_block626 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _OPTIONS_in_block634 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _alternative_in_block651 = new BitSet(new ulong[]{0x200000100UL,0x1000UL});
		public static readonly BitSet _rewrite_in_block656 = new BitSet(new ulong[]{0x200000100UL});
		public static readonly BitSet _EOB_in_block676 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BLOCK_in_setBlock703 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALT_in_setAlternative727 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _setElement_in_setAlternative729 = new BitSet(new ulong[]{0x1000C0000UL,0x41000000UL});
		public static readonly BitSet _EOA_in_setAlternative732 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _exceptionHandler_in_exceptionGroup745 = new BitSet(new ulong[]{0x4000020002UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup756 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_exceptionHandler770 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_exceptionHandler772 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_exceptionHandler774 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FINALLY_in_finallyClause792 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_finallyClause794 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_alternative825 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_alternative834 = new BitSet(new ulong[]{0x82800289202DE010UL,0x547092001UL});
		public static readonly BitSet _EOA_in_alternative850 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ROOT_in_element880 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element884 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BANG_in_element900 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element904 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _NOT_in_element922 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _notElement_in_element924 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_element937 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element941 = new BitSet(new ulong[]{0x82800288202DE010UL,0x547092001UL});
		public static readonly BitSet _element_in_element945 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PLUS_ASSIGN_in_element956 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element960 = new BitSet(new ulong[]{0x82800288202DE010UL,0x547092001UL});
		public static readonly BitSet _element_in_element964 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_RANGE_in_element974 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_element978 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_element982 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ebnf_in_element995 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_element1007 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tree__in_element1021 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _element_action_in_element1040 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMPRED_in_element1060 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GATED_SEMPRED_in_element1066 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYN_SEMPRED_in_element1080 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYNPRED_in_element1087 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1097 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EPSILON_in_element1106 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_element_action1123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FORCED_ACTION_in_element_action1134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_LITERAL_in_notElement1161 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_notElement1172 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_notElement1182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_in_notElement1195 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1241 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPTIONAL_in_ebnf1260 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1264 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CLOSURE_in_ebnf1279 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1283 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1299 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1303 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_BEGIN_in_tree_1338 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_tree_1345 = new BitSet(new ulong[]{0x82800288202DE018UL,0x547092001UL});
		public static readonly BitSet _element_action_in_tree_1382 = new BitSet(new ulong[]{0x82800288202DE018UL,0x547092001UL});
		public static readonly BitSet _element_in_tree_1404 = new BitSet(new ulong[]{0x82800288202DE018UL,0x547092001UL});
		public static readonly BitSet _RULE_REF_in_atom1455 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1460 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TOKEN_REF_in_atom1476 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1481 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_atom1495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_atom1510 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WILDCARD_in_atom1524 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_atom1539 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_atom1541 = new BitSet(new ulong[]{0x20050000UL,0x441010000UL});
		public static readonly BitSet _atom_in_atom1545 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _set_in_atom1567 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BLOCK_in_set1612 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_setElement1635 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_setElement1640 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_setElement1645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_RANGE_in_setElement1651 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_setElement1653 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_setElement1655 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _REWRITES_in_rewrite1680 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _REWRITE_in_rewrite1715 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SEMPRED_in_rewrite1720 = new BitSet(new ulong[]{0x2000000110UL,0x8000000UL});
		public static readonly BitSet _rewrite_alternative_in_rewrite1726 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BLOCK_in_rewrite_block1765 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rewrite_alternative_in_rewrite_block1777 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _EOB_in_rewrite_block1782 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_rewrite_alternative1817 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rewrite_element_in_rewrite_alternative1835 = new BitSet(new ulong[]{0x201000100240010UL,0x141010001UL});
		public static readonly BitSet _EPSILON_in_rewrite_alternative1856 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_rewrite_alternative1872 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _rewrite_template_in_rewrite_alternative1885 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ETC_in_rewrite_alternative1898 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_atom_in_rewrite_element1918 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_ebnf_in_rewrite_element1927 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _rewrite_tree_in_rewrite_element1936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPTIONAL_in_rewrite_ebnf1958 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1962 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CLOSURE_in_rewrite_ebnf1971 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1975 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POSITIVE_CLOSURE_in_rewrite_ebnf1984 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rewrite_block_in_rewrite_ebnf1988 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_BEGIN_in_rewrite_tree2020 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _rewrite_atom_in_rewrite_tree2027 = new BitSet(new ulong[]{0x201000000240018UL,0x141010001UL});
		public static readonly BitSet _rewrite_element_in_rewrite_tree2047 = new BitSet(new ulong[]{0x201000000240018UL,0x141010001UL});
		public static readonly BitSet _RULE_REF_in_rewrite_atom2092 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_rewrite_atom2111 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rewrite_atom2116 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_rewrite_atom2127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_rewrite_atom2135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LABEL_in_rewrite_atom2155 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_rewrite_atom2170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALT_in_rewrite_template2198 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _EPSILON_in_rewrite_template2200 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_rewrite_template2202 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TEMPLATE_in_rewrite_template2216 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rewrite_template2221 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _ACTION_in_rewrite_template2225 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _ARGLIST_in_rewrite_template2236 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_in_rewrite_template2245 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rewrite_template2249 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_rewrite_template2253 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DOUBLE_QUOTE_STRING_LITERAL_in_rewrite_template2275 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DOUBLE_ANGLE_STRING_LITERAL_in_rewrite_template2284 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ACTION_in_rewrite_template2304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _element_action_in_synpred1_CodeGenTreeWalker1371 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.Grammars
