//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Grammars\\LeftRecursiveRuleWalker.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using Antlr3.Analysis;
using Antlr3.Misc;
using Antlr3.Tool;
using Antlr3.Extensions;
using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Antlr3.Grammars
{
/** Find left-recursive rules */
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class LeftRecursiveRuleWalker : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARGLIST", "ARG_ACTION", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PREC_RULE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RECURSIVE_RULE_REF", "RET", "RETURNS", "REWRITE", "REWRITES", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYNPRED", "SYN_SEMPRED", "TEMPLATE", "THROWS", "TOKENS", "TOKEN_REF", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
	};
	public const int EOF=-1;
	public const int ACTION=4;
	public const int ACTION_CHAR_LITERAL=5;
	public const int ACTION_ESC=6;
	public const int ACTION_STRING_LITERAL=7;
	public const int ALT=8;
	public const int AMPERSAND=9;
	public const int ARG=10;
	public const int ARGLIST=11;
	public const int ARG_ACTION=12;
	public const int ASSIGN=13;
	public const int BACKTRACK_SEMPRED=14;
	public const int BANG=15;
	public const int BLOCK=16;
	public const int CATCH=17;
	public const int CHAR_LITERAL=18;
	public const int CHAR_RANGE=19;
	public const int CLOSE_ELEMENT_OPTION=20;
	public const int CLOSURE=21;
	public const int COLON=22;
	public const int COMBINED_GRAMMAR=23;
	public const int COMMA=24;
	public const int COMMENT=25;
	public const int DIGIT=26;
	public const int DOC_COMMENT=27;
	public const int DOLLAR=28;
	public const int DOT=29;
	public const int DOUBLE_ANGLE_STRING_LITERAL=30;
	public const int DOUBLE_QUOTE_STRING_LITERAL=31;
	public const int EOA=32;
	public const int EOB=33;
	public const int EOR=34;
	public const int EPSILON=35;
	public const int ESC=36;
	public const int ETC=37;
	public const int FINALLY=38;
	public const int FORCED_ACTION=39;
	public const int FRAGMENT=40;
	public const int GATED_SEMPRED=41;
	public const int GRAMMAR=42;
	public const int ID=43;
	public const int IMPLIES=44;
	public const int IMPORT=45;
	public const int INITACTION=46;
	public const int INT=47;
	public const int LABEL=48;
	public const int LEXER=49;
	public const int LEXER_GRAMMAR=50;
	public const int LPAREN=51;
	public const int ML_COMMENT=52;
	public const int NESTED_ACTION=53;
	public const int NESTED_ARG_ACTION=54;
	public const int NOT=55;
	public const int OPEN_ELEMENT_OPTION=56;
	public const int OPTIONAL=57;
	public const int OPTIONS=58;
	public const int OR=59;
	public const int PARSER=60;
	public const int PARSER_GRAMMAR=61;
	public const int PLUS=62;
	public const int PLUS_ASSIGN=63;
	public const int POSITIVE_CLOSURE=64;
	public const int PREC_RULE=65;
	public const int PRIVATE=66;
	public const int PROTECTED=67;
	public const int PUBLIC=68;
	public const int QUESTION=69;
	public const int RANGE=70;
	public const int RCURLY=71;
	public const int RECURSIVE_RULE_REF=72;
	public const int RET=73;
	public const int RETURNS=74;
	public const int REWRITE=75;
	public const int REWRITES=76;
	public const int ROOT=77;
	public const int RPAREN=78;
	public const int RULE=79;
	public const int RULE_REF=80;
	public const int SCOPE=81;
	public const int SEMI=82;
	public const int SEMPRED=83;
	public const int SL_COMMENT=84;
	public const int SRC=85;
	public const int STAR=86;
	public const int STRAY_BRACKET=87;
	public const int STRING_LITERAL=88;
	public const int SYNPRED=89;
	public const int SYN_SEMPRED=90;
	public const int TEMPLATE=91;
	public const int THROWS=92;
	public const int TOKENS=93;
	public const int TOKEN_REF=94;
	public const int TREE=95;
	public const int TREE_BEGIN=96;
	public const int TREE_GRAMMAR=97;
	public const int WILDCARD=98;
	public const int WS=99;
	public const int WS_LOOP=100;
	public const int WS_OPT=101;
	public const int XDIGIT=102;

	public LeftRecursiveRuleWalker(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public LeftRecursiveRuleWalker(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return LeftRecursiveRuleWalker.tokenNames; } }
	public override string GrammarFileName { get { return "Grammars\\LeftRecursiveRuleWalker.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_optionsSpec();
	partial void LeaveRule_optionsSpec();
	// $ANTLR start "optionsSpec"
	// Grammars\\LeftRecursiveRuleWalker.g3:54:1: optionsSpec : ^( OPTIONS ( option )* ) ;
	[GrammarRule("optionsSpec")]
	private void optionsSpec()
	{
		EnterRule_optionsSpec();
		EnterRule("optionsSpec", 1);
		TraceIn("optionsSpec", 1);
		try { DebugEnterRule(GrammarFileName, "optionsSpec");
		DebugLocation(54, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:55:2: ( ^( OPTIONS ( option )* ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:55:4: ^( OPTIONS ( option )* )
			{
			DebugLocation(55, 4);
			DebugLocation(55, 6);
			Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec59); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(55, 14);
				// Grammars\\LeftRecursiveRuleWalker.g3:55:14: ( option )*
				try { DebugEnterSubRule(1);
				while (true)
				{
					int alt1=2;
					try { DebugEnterDecision(1, false);
					int LA1_1 = input.LA(1);

					if ((LA1_1==ASSIGN))
					{
						alt1 = 1;
					}


					} finally { DebugExitDecision(1); }
					switch ( alt1 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:55:14: option
						{
						DebugLocation(55, 14);
						PushFollow(Follow._option_in_optionsSpec61);
						option();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						goto loop1;
					}
				}

				loop1:
					;

				} finally { DebugExitSubRule(1); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("optionsSpec", 1);
			LeaveRule("optionsSpec", 1);
			LeaveRule_optionsSpec();
		}
		DebugLocation(56, 1);
		} finally { DebugExitRule(GrammarFileName, "optionsSpec"); }
		return;

	}
	// $ANTLR end "optionsSpec"

	partial void EnterRule_option();
	partial void LeaveRule_option();
	// $ANTLR start "option"
	// Grammars\\LeftRecursiveRuleWalker.g3:58:1: option : ^( ASSIGN ID optionValue ) ;
	[GrammarRule("option")]
	private void option()
	{
		EnterRule_option();
		EnterRule("option", 2);
		TraceIn("option", 2);
		try { DebugEnterRule(GrammarFileName, "option");
		DebugLocation(58, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:59:2: ( ^( ASSIGN ID optionValue ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:59:4: ^( ASSIGN ID optionValue )
			{
			DebugLocation(59, 4);
			DebugLocation(59, 6);
			Match(input,ASSIGN,Follow._ASSIGN_in_option75); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(59, 13);
			Match(input,ID,Follow._ID_in_option77); if (state.failed) return;
			DebugLocation(59, 16);
			PushFollow(Follow._optionValue_in_option79);
			optionValue();
			PopFollow();
			if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("option", 2);
			LeaveRule("option", 2);
			LeaveRule_option();
		}
		DebugLocation(60, 1);
		} finally { DebugExitRule(GrammarFileName, "option"); }
		return;

	}
	// $ANTLR end "option"

	partial void EnterRule_optionValue();
	partial void LeaveRule_optionValue();
	// $ANTLR start "optionValue"
	// Grammars\\LeftRecursiveRuleWalker.g3:62:1: optionValue : ( ID | STRING_LITERAL | CHAR_LITERAL | INT );
	[GrammarRule("optionValue")]
	private void optionValue()
	{
		EnterRule_optionValue();
		EnterRule("optionValue", 3);
		TraceIn("optionValue", 3);
		try { DebugEnterRule(GrammarFileName, "optionValue");
		DebugLocation(62, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:63:2: ( ID | STRING_LITERAL | CHAR_LITERAL | INT )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:
			{
			DebugLocation(63, 2);
			if (input.LA(1)==CHAR_LITERAL||input.LA(1)==ID||input.LA(1)==INT||input.LA(1)==STRING_LITERAL)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("optionValue", 3);
			LeaveRule("optionValue", 3);
			LeaveRule_optionValue();
		}
		DebugLocation(67, 1);
		} finally { DebugExitRule(GrammarFileName, "optionValue"); }
		return;

	}
	// $ANTLR end "optionValue"

	partial void EnterRule_charSetElement();
	partial void LeaveRule_charSetElement();
	// $ANTLR start "charSetElement"
	// Grammars\\LeftRecursiveRuleWalker.g3:69:1: charSetElement : ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) );
	[GrammarRule("charSetElement")]
	private void charSetElement()
	{
		EnterRule_charSetElement();
		EnterRule("charSetElement", 4);
		TraceIn("charSetElement", 4);
		try { DebugEnterRule(GrammarFileName, "charSetElement");
		DebugLocation(69, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:70:2: ( CHAR_LITERAL | ^( OR CHAR_LITERAL CHAR_LITERAL ) | ^( RANGE CHAR_LITERAL CHAR_LITERAL ) )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case CHAR_LITERAL:
				{
				alt2 = 1;
				}
				break;
			case OR:
				{
				alt2 = 2;
				}
				break;
			case RANGE:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:70:4: CHAR_LITERAL
				{
				DebugLocation(70, 4);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement117); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:71:4: ^( OR CHAR_LITERAL CHAR_LITERAL )
				{
				DebugLocation(71, 4);
				DebugLocation(71, 6);
				Match(input,OR,Follow._OR_in_charSetElement123); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(71, 9);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement125); if (state.failed) return;
				DebugLocation(71, 22);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement127); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:72:4: ^( RANGE CHAR_LITERAL CHAR_LITERAL )
				{
				DebugLocation(72, 4);
				DebugLocation(72, 6);
				Match(input,RANGE,Follow._RANGE_in_charSetElement134); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(72, 12);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement136); if (state.failed) return;
				DebugLocation(72, 25);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_charSetElement138); if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("charSetElement", 4);
			LeaveRule("charSetElement", 4);
			LeaveRule_charSetElement();
		}
		DebugLocation(73, 1);
		} finally { DebugExitRule(GrammarFileName, "charSetElement"); }
		return;

	}
	// $ANTLR end "charSetElement"

	partial void EnterRule_rec_rule();
	partial void LeaveRule_rec_rule();
	// $ANTLR start "rec_rule"
	// Grammars\\LeftRecursiveRuleWalker.g3:76:1: public rec_rule[Grammar g] returns [bool isLeftRec] : ^(r= RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ruleBlock ( exceptionGroup )? EOR ) ;
	[GrammarRule("rec_rule")]
	public bool rec_rule(Grammar g)
	{
		EnterRule_rec_rule();
		EnterRule("rec_rule", 5);
		TraceIn("rec_rule", 5);
		bool isLeftRec = default(bool);


		GrammarAST r = default(GrammarAST);
		GrammarAST id = default(GrammarAST);
		TreeRuleReturnScope<GrammarAST> ruleBlock1 = default(TreeRuleReturnScope<GrammarAST>);


			grammar = g;
			outerAlt = 1;

		try { DebugEnterRule(GrammarFileName, "rec_rule");
		DebugLocation(76, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:82:2: ( ^(r= RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ruleBlock ( exceptionGroup )? EOR ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:82:4: ^(r= RULE id= ID ( modifier )? ^( ARG ( ARG_ACTION )? ) ^( RET ( ARG_ACTION )? ) ( optionsSpec )? ( ruleScopeSpec )? ( ^( AMPERSAND ( . )* ) )* ruleBlock ( exceptionGroup )? EOR )
			{
			DebugLocation(82, 4);
			DebugLocation(82, 8);
			r=(GrammarAST)Match(input,RULE,Follow._RULE_in_rec_rule166); if (state.failed) return isLeftRec;

			Match(input, TokenTypes.Down, null); if (state.failed) return isLeftRec;
			DebugLocation(82, 16);
			id=(GrammarAST)Match(input,ID,Follow._ID_in_rec_rule170); if (state.failed) return isLeftRec;
			DebugLocation(82, 20);
			if (state.backtracking == 0)
			{
				ruleName=id.Text;
			}
			DebugLocation(83, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:83:4: ( modifier )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==FRAGMENT||(LA3_1>=PRIVATE && LA3_1<=PUBLIC)))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:83:4: modifier
				{
				DebugLocation(83, 4);
				PushFollow(Follow._modifier_in_rec_rule177);
				modifier();
				PopFollow();
				if (state.failed) return isLeftRec;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(84, 4);
			DebugLocation(84, 6);
			Match(input,ARG,Follow._ARG_in_rec_rule184); if (state.failed) return isLeftRec;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return isLeftRec;
				DebugLocation(84, 10);
				// Grammars\\LeftRecursiveRuleWalker.g3:84:10: ( ARG_ACTION )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==ARG_ACTION))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:84:10: ARG_ACTION
					{
					DebugLocation(84, 10);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rec_rule186); if (state.failed) return isLeftRec;

					}
					break;

				}
				} finally { DebugExitSubRule(4); }


				Match(input, TokenTypes.Up, null); if (state.failed) return isLeftRec;
			}

			DebugLocation(85, 4);
			DebugLocation(85, 6);
			Match(input,RET,Follow._RET_in_rec_rule194); if (state.failed) return isLeftRec;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return isLeftRec;
				DebugLocation(85, 10);
				// Grammars\\LeftRecursiveRuleWalker.g3:85:10: ( ARG_ACTION )?
				int alt5=2;
				try { DebugEnterSubRule(5);
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==ARG_ACTION))
				{
					alt5 = 1;
				}
				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:85:10: ARG_ACTION
					{
					DebugLocation(85, 10);
					Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rec_rule196); if (state.failed) return isLeftRec;

					}
					break;

				}
				} finally { DebugExitSubRule(5); }


				Match(input, TokenTypes.Up, null); if (state.failed) return isLeftRec;
			}

			DebugLocation(86, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:86:4: ( optionsSpec )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==OPTIONS))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:86:4: optionsSpec
				{
				DebugLocation(86, 4);
				PushFollow(Follow._optionsSpec_in_rec_rule203);
				optionsSpec();
				PopFollow();
				if (state.failed) return isLeftRec;

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(87, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:87:4: ( ruleScopeSpec )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==SCOPE))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:87:4: ruleScopeSpec
				{
				DebugLocation(87, 4);
				PushFollow(Follow._ruleScopeSpec_in_rec_rule209);
				ruleScopeSpec();
				PopFollow();
				if (state.failed) return isLeftRec;

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(88, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:88:4: ( ^( AMPERSAND ( . )* ) )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==AMPERSAND))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:88:5: ^( AMPERSAND ( . )* )
					{
					DebugLocation(88, 5);
					DebugLocation(88, 7);
					Match(input,AMPERSAND,Follow._AMPERSAND_in_rec_rule217); if (state.failed) return isLeftRec;

					if (input.LA(1) == TokenTypes.Down)
					{
						Match(input, TokenTypes.Down, null); if (state.failed) return isLeftRec;
						DebugLocation(88, 17);
						// Grammars\\LeftRecursiveRuleWalker.g3:88:17: ( . )*
						try { DebugEnterSubRule(8);
						while (true)
						{
							int alt8=2;
							try { DebugEnterDecision(8, false);
							int LA8_1 = input.LA(1);

							if (((LA8_1>=ACTION && LA8_1<=XDIGIT)))
							{
								alt8 = 1;
							}
							else if ((LA8_1==UP))
							{
								alt8 = 2;
							}


							} finally { DebugExitDecision(8); }
							switch ( alt8 )
							{
							case 1:
								DebugEnterAlt(1);
								// Grammars\\LeftRecursiveRuleWalker.g3:88:17: .
								{
								DebugLocation(88, 17);
								MatchAny(input); if (state.failed) return isLeftRec;

								}
								break;

							default:
								goto loop8;
							}
						}

						loop8:
							;

						} finally { DebugExitSubRule(8); }


						Match(input, TokenTypes.Up, null); if (state.failed) return isLeftRec;
					}


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(89, 4);
			PushFollow(Follow._ruleBlock_in_rec_rule228);
			ruleBlock1=ruleBlock();
			PopFollow();
			if (state.failed) return isLeftRec;
			DebugLocation(89, 14);
			if (state.backtracking == 0)
			{
				isLeftRec = (ruleBlock1!=null?((LeftRecursiveRuleWalker.ruleBlock_return)ruleBlock1).isLeftRec:default(bool));
			}
			DebugLocation(90, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:90:4: ( exceptionGroup )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==CATCH||LA10_1==FINALLY))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:90:4: exceptionGroup
				{
				DebugLocation(90, 4);
				PushFollow(Follow._exceptionGroup_in_rec_rule235);
				exceptionGroup();
				PopFollow();
				if (state.failed) return isLeftRec;

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(91, 4);
			Match(input,EOR,Follow._EOR_in_rec_rule241); if (state.failed) return isLeftRec;

			Match(input, TokenTypes.Up, null); if (state.failed) return isLeftRec;

			DebugLocation(93, 3);
			if (state.backtracking == 0)
			{
				if ((ruleBlock1!=null?((LeftRecursiveRuleWalker.ruleBlock_return)ruleBlock1).isLeftRec:default(bool))) r.Type = PREC_RULE;
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rec_rule", 5);
			LeaveRule("rec_rule", 5);
			LeaveRule_rec_rule();
		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "rec_rule"); }
		return isLeftRec;

	}
	// $ANTLR end "rec_rule"

	partial void EnterRule_modifier();
	partial void LeaveRule_modifier();
	// $ANTLR start "modifier"
	// Grammars\\LeftRecursiveRuleWalker.g3:96:1: modifier : ( 'protected' | 'public' | 'private' | 'fragment' );
	[GrammarRule("modifier")]
	private void modifier()
	{
		EnterRule_modifier();
		EnterRule("modifier", 6);
		TraceIn("modifier", 6);
		try { DebugEnterRule(GrammarFileName, "modifier");
		DebugLocation(96, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:97:2: ( 'protected' | 'public' | 'private' | 'fragment' )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:
			{
			DebugLocation(97, 2);
			if (input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC))
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("modifier", 6);
			LeaveRule("modifier", 6);
			LeaveRule_modifier();
		}
		DebugLocation(101, 1);
		} finally { DebugExitRule(GrammarFileName, "modifier"); }
		return;

	}
	// $ANTLR end "modifier"

	partial void EnterRule_ruleScopeSpec();
	partial void LeaveRule_ruleScopeSpec();
	// $ANTLR start "ruleScopeSpec"
	// Grammars\\LeftRecursiveRuleWalker.g3:103:1: ruleScopeSpec : ^( 'scope' ( ACTION )? ( ID )* ) ;
	[GrammarRule("ruleScopeSpec")]
	private void ruleScopeSpec()
	{
		EnterRule_ruleScopeSpec();
		EnterRule("ruleScopeSpec", 7);
		TraceIn("ruleScopeSpec", 7);
		try { DebugEnterRule(GrammarFileName, "ruleScopeSpec");
		DebugLocation(103, 2);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:104:3: ( ^( 'scope' ( ACTION )? ( ID )* ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:104:5: ^( 'scope' ( ACTION )? ( ID )* )
			{
			DebugLocation(104, 5);
			DebugLocation(104, 7);
			Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec288); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(104, 15);
				// Grammars\\LeftRecursiveRuleWalker.g3:104:15: ( ACTION )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==ACTION))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:104:15: ACTION
					{
					DebugLocation(104, 15);
					Match(input,ACTION,Follow._ACTION_in_ruleScopeSpec290); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(11); }

				DebugLocation(104, 23);
				// Grammars\\LeftRecursiveRuleWalker.g3:104:23: ( ID )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if ((LA12_1==ID))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:104:23: ID
						{
						DebugLocation(104, 23);
						Match(input,ID,Follow._ID_in_ruleScopeSpec293); if (state.failed) return;

						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ruleScopeSpec", 7);
			LeaveRule("ruleScopeSpec", 7);
			LeaveRule_ruleScopeSpec();
		}
		DebugLocation(105, 2);
		} finally { DebugExitRule(GrammarFileName, "ruleScopeSpec"); }
		return;

	}
	// $ANTLR end "ruleScopeSpec"

	private sealed partial class ruleBlock_return : TreeRuleReturnScope<GrammarAST>
	{
		public bool isLeftRec;
		public ruleBlock_return(LeftRecursiveRuleWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(LeftRecursiveRuleWalker grammar);
	}

	partial void EnterRule_ruleBlock();
	partial void LeaveRule_ruleBlock();
	// $ANTLR start "ruleBlock"
	// Grammars\\LeftRecursiveRuleWalker.g3:107:1: ruleBlock returns [bool isLeftRec] : ^( BLOCK ( optionsSpec )? ( outerAlternative ( rewrite )? )+ EOB ) ;
	[GrammarRule("ruleBlock")]
	private LeftRecursiveRuleWalker.ruleBlock_return ruleBlock()
	{
		EnterRule_ruleBlock();
		EnterRule("ruleBlock", 8);
		TraceIn("ruleBlock", 8);
		LeftRecursiveRuleWalker.ruleBlock_return retval = new LeftRecursiveRuleWalker.ruleBlock_return(this);
		retval.Start = (GrammarAST)input.LT(1);

		TreeRuleReturnScope<GrammarAST> outerAlternative2 = default(TreeRuleReturnScope<GrammarAST>);

		bool lr=false; this.numAlts = retval.Start.ChildCount;
		try { DebugEnterRule(GrammarFileName, "ruleBlock");
		DebugLocation(107, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:109:2: ( ^( BLOCK ( optionsSpec )? ( outerAlternative ( rewrite )? )+ EOB ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:109:4: ^( BLOCK ( optionsSpec )? ( outerAlternative ( rewrite )? )+ EOB )
			{
			DebugLocation(109, 4);
			DebugLocation(109, 7);
			Match(input,BLOCK,Follow._BLOCK_in_ruleBlock317); if (state.failed) return retval;

			Match(input, TokenTypes.Down, null); if (state.failed) return retval;
			DebugLocation(110, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:110:4: ( optionsSpec )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==OPTIONS))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:110:4: optionsSpec
				{
				DebugLocation(110, 4);
				PushFollow(Follow._optionsSpec_in_ruleBlock322);
				optionsSpec();
				PopFollow();
				if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(111, 4);
			// Grammars\\LeftRecursiveRuleWalker.g3:111:4: ( outerAlternative ( rewrite )? )+
			int cnt15=0;
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==ALT))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:111:6: outerAlternative ( rewrite )?
					{
					DebugLocation(111, 6);
					PushFollow(Follow._outerAlternative_in_ruleBlock330);
					outerAlternative2=outerAlternative();
					PopFollow();
					if (state.failed) return retval;
					DebugLocation(112, 5);
					if (state.backtracking == 0)
					{
						if ((outerAlternative2!=null?((LeftRecursiveRuleWalker.outerAlternative_return)outerAlternative2).isLeftRec:default(bool))) retval.isLeftRec = true;
					}
					DebugLocation(113, 5);
					// Grammars\\LeftRecursiveRuleWalker.g3:113:5: ( rewrite )?
					int alt14=2;
					try { DebugEnterSubRule(14);
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if ((LA14_1==REWRITES))
					{
						alt14 = 1;
					}
					} finally { DebugExitDecision(14); }
					switch (alt14)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:113:5: rewrite
						{
						DebugLocation(113, 5);
						PushFollow(Follow._rewrite_in_ruleBlock342);
						rewrite();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					}
					} finally { DebugExitSubRule(14); }

					DebugLocation(114, 5);
					if (state.backtracking == 0)
					{
						outerAlt++;
					}

					}
					break;

				default:
					if (cnt15 >= 1)
						goto loop15;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee15 = new EarlyExitException( 15, input );
					DebugRecognitionException(eee15);
					throw eee15;
				}
				cnt15++;
			}
			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(116, 4);
			Match(input,EOB,Follow._EOB_in_ruleBlock360); if (state.failed) return retval;

			Match(input, TokenTypes.Up, null); if (state.failed) return retval;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ruleBlock", 8);
			LeaveRule("ruleBlock", 8);
			LeaveRule_ruleBlock();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "ruleBlock"); }
		return retval;

	}
	// $ANTLR end "ruleBlock"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// Grammars\\LeftRecursiveRuleWalker.g3:120:1: block : ^( BLOCK ( optionsSpec )? ( ^( ALT ( element )+ EOA ) ( rewrite )? )+ EOB ) ;
	[GrammarRule("block")]
	private void block()
	{
		EnterRule_block();
		EnterRule("block", 9);
		TraceIn("block", 9);
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(120, 4);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:121:5: ( ^( BLOCK ( optionsSpec )? ( ^( ALT ( element )+ EOA ) ( rewrite )? )+ EOB ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:121:9: ^( BLOCK ( optionsSpec )? ( ^( ALT ( element )+ EOA ) ( rewrite )? )+ EOB )
			{
			DebugLocation(121, 9);
			DebugLocation(121, 13);
			Match(input,BLOCK,Follow._BLOCK_in_block383); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(122, 13);
			// Grammars\\LeftRecursiveRuleWalker.g3:122:13: ( optionsSpec )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==OPTIONS))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:122:13: optionsSpec
				{
				DebugLocation(122, 13);
				PushFollow(Follow._optionsSpec_in_block397);
				optionsSpec();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(123, 13);
			// Grammars\\LeftRecursiveRuleWalker.g3:123:13: ( ^( ALT ( element )+ EOA ) ( rewrite )? )+
			int cnt19=0;
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==ALT))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:123:15: ^( ALT ( element )+ EOA ) ( rewrite )?
					{
					DebugLocation(123, 15);
					DebugLocation(123, 17);
					Match(input,ALT,Follow._ALT_in_block415); if (state.failed) return;

					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(123, 21);
					// Grammars\\LeftRecursiveRuleWalker.g3:123:21: ( element )+
					int cnt17=0;
					try { DebugEnterSubRule(17);
					while (true)
					{
						int alt17=2;
						try { DebugEnterDecision(17, false);
						int LA17_1 = input.LA(1);

						if ((LA17_1==ACTION||(LA17_1>=ASSIGN && LA17_1<=BLOCK)||LA17_1==CHAR_LITERAL||LA17_1==CLOSURE||LA17_1==DOT||LA17_1==EPSILON||LA17_1==FORCED_ACTION||LA17_1==GATED_SEMPRED||LA17_1==NOT||LA17_1==OPTIONAL||(LA17_1>=PLUS_ASSIGN && LA17_1<=POSITIVE_CLOSURE)||LA17_1==RANGE||LA17_1==ROOT||LA17_1==RULE_REF||LA17_1==SEMPRED||(LA17_1>=STRING_LITERAL && LA17_1<=SYN_SEMPRED)||LA17_1==TOKEN_REF||LA17_1==TREE_BEGIN||LA17_1==WILDCARD))
						{
							alt17 = 1;
						}


						} finally { DebugExitDecision(17); }
						switch (alt17)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:123:21: element
							{
							DebugLocation(123, 21);
							PushFollow(Follow._element_in_block417);
							element();
							PopFollow();
							if (state.failed) return;

							}
							break;

						default:
							if (cnt17 >= 1)
								goto loop17;

							if (state.backtracking>0) {state.failed=true; return;}
							EarlyExitException eee17 = new EarlyExitException( 17, input );
							DebugRecognitionException(eee17);
							throw eee17;
						}
						cnt17++;
					}
					loop17:
						;

					} finally { DebugExitSubRule(17); }

					DebugLocation(123, 30);
					Match(input,EOA,Follow._EOA_in_block420); if (state.failed) return;

					Match(input, TokenTypes.Up, null); if (state.failed) return;

					DebugLocation(123, 35);
					// Grammars\\LeftRecursiveRuleWalker.g3:123:35: ( rewrite )?
					int alt18=2;
					try { DebugEnterSubRule(18);
					try { DebugEnterDecision(18, false);
					int LA18_1 = input.LA(1);

					if ((LA18_1==REWRITES))
					{
						alt18 = 1;
					}
					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:123:35: rewrite
						{
						DebugLocation(123, 35);
						PushFollow(Follow._rewrite_in_block423);
						rewrite();
						PopFollow();
						if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(18); }


					}
					break;

				default:
					if (cnt19 >= 1)
						goto loop19;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee19 = new EarlyExitException( 19, input );
					DebugRecognitionException(eee19);
					throw eee19;
				}
				cnt19++;
			}
			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(124, 13);
			Match(input,EOB,Follow._EOB_in_block441); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("block", 9);
			LeaveRule("block", 9);
			LeaveRule_block();
		}
		DebugLocation(126, 4);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return;

	}
	// $ANTLR end "block"

	private sealed partial class outerAlternative_return : TreeRuleReturnScope<GrammarAST>
	{
		public bool isLeftRec;
		public outerAlternative_return(LeftRecursiveRuleWalker grammar) {OnCreated(grammar);}
		partial void OnCreated(LeftRecursiveRuleWalker grammar);
	}

	partial void EnterRule_outerAlternative();
	partial void LeaveRule_outerAlternative();
	// $ANTLR start "outerAlternative"
	// Grammars\\LeftRecursiveRuleWalker.g3:129:1: outerAlternative returns [bool isLeftRec] : ( ( binaryMultipleOp )=> binaryMultipleOp | ( binary )=> binary | ( ternary )=> ternary | ( prefix )=> prefix | ( suffix )=> suffix | ^( ALT ( element )+ EOA ) );
	[GrammarRule("outerAlternative")]
	private LeftRecursiveRuleWalker.outerAlternative_return outerAlternative()
	{
		EnterRule_outerAlternative();
		EnterRule("outerAlternative", 10);
		TraceIn("outerAlternative", 10);
		LeftRecursiveRuleWalker.outerAlternative_return retval = new LeftRecursiveRuleWalker.outerAlternative_return(this);
		retval.Start = (GrammarAST)input.LT(1);


		GrammarAST rew=(GrammarAST)retval.Start.Parent.GetChild( retval.Start.ChildIndex + 1 );
		if (rew.Type != REWRITES)
			rew = null;

		try { DebugEnterRule(GrammarFileName, "outerAlternative");
		DebugLocation(129, 4);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:136:5: ( ( binaryMultipleOp )=> binaryMultipleOp | ( binary )=> binary | ( ternary )=> ternary | ( prefix )=> prefix | ( suffix )=> suffix | ^( ALT ( element )+ EOA ) )
			int alt21=6;
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==ALT))
			{
				int LA21_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_LeftRecursiveRuleWalker_fragment)))
				{
					alt21 = 1;
				}
				else if ((EvaluatePredicate(synpred2_LeftRecursiveRuleWalker_fragment)))
				{
					alt21 = 2;
				}
				else if ((EvaluatePredicate(synpred3_LeftRecursiveRuleWalker_fragment)))
				{
					alt21 = 3;
				}
				else if ((EvaluatePredicate(synpred4_LeftRecursiveRuleWalker_fragment)))
				{
					alt21 = 4;
				}
				else if ((EvaluatePredicate(synpred5_LeftRecursiveRuleWalker_fragment)))
				{
					alt21 = 5;
				}
				else if ((true))
				{
					alt21 = 6;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:136:9: ( binaryMultipleOp )=> binaryMultipleOp
				{
				DebugLocation(136, 30);
				PushFollow(Follow._binaryMultipleOp_in_outerAlternative490);
				binaryMultipleOp();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(137, 30);
				if (state.backtracking == 0)
				{
					BinaryAlt(retval.Start, rew, outerAlt); retval.isLeftRec =true;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:138:9: ( binary )=> binary
				{
				DebugLocation(138, 30);
				PushFollow(Follow._binary_in_outerAlternative546);
				binary();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(139, 30);
				if (state.backtracking == 0)
				{
					BinaryAlt(retval.Start, rew, outerAlt); retval.isLeftRec =true;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:140:9: ( ternary )=> ternary
				{
				DebugLocation(140, 30);
				PushFollow(Follow._ternary_in_outerAlternative608);
				ternary();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(141, 30);
				if (state.backtracking == 0)
				{
					TernaryAlt(retval.Start, rew, outerAlt); retval.isLeftRec =true;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LeftRecursiveRuleWalker.g3:142:9: ( prefix )=> prefix
				{
				DebugLocation(142, 30);
				PushFollow(Follow._prefix_in_outerAlternative664);
				prefix();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(143, 30);
				if (state.backtracking == 0)
				{
					PrefixAlt(retval.Start, rew, outerAlt);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LeftRecursiveRuleWalker.g3:144:9: ( suffix )=> suffix
				{
				DebugLocation(144, 30);
				PushFollow(Follow._suffix_in_outerAlternative720);
				suffix();
				PopFollow();
				if (state.failed) return retval;
				DebugLocation(145, 30);
				if (state.backtracking == 0)
				{
					SuffixAlt(retval.Start, rew, outerAlt); retval.isLeftRec =true;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LeftRecursiveRuleWalker.g3:146:9: ^( ALT ( element )+ EOA )
				{
				DebugLocation(146, 9);
				DebugLocation(146, 11);
				Match(input,ALT,Follow._ALT_in_outerAlternative762); if (state.failed) return retval;

				Match(input, TokenTypes.Down, null); if (state.failed) return retval;
				DebugLocation(146, 15);
				// Grammars\\LeftRecursiveRuleWalker.g3:146:15: ( element )+
				int cnt20=0;
				try { DebugEnterSubRule(20);
				while (true)
				{
					int alt20=2;
					try { DebugEnterDecision(20, false);
					int LA20_1 = input.LA(1);

					if ((LA20_1==ACTION||(LA20_1>=ASSIGN && LA20_1<=BLOCK)||LA20_1==CHAR_LITERAL||LA20_1==CLOSURE||LA20_1==DOT||LA20_1==EPSILON||LA20_1==FORCED_ACTION||LA20_1==GATED_SEMPRED||LA20_1==NOT||LA20_1==OPTIONAL||(LA20_1>=PLUS_ASSIGN && LA20_1<=POSITIVE_CLOSURE)||LA20_1==RANGE||LA20_1==ROOT||LA20_1==RULE_REF||LA20_1==SEMPRED||(LA20_1>=STRING_LITERAL && LA20_1<=SYN_SEMPRED)||LA20_1==TOKEN_REF||LA20_1==TREE_BEGIN||LA20_1==WILDCARD))
					{
						alt20 = 1;
					}


					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:146:15: element
						{
						DebugLocation(146, 15);
						PushFollow(Follow._element_in_outerAlternative764);
						element();
						PopFollow();
						if (state.failed) return retval;

						}
						break;

					default:
						if (cnt20 >= 1)
							goto loop20;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee20 = new EarlyExitException( 20, input );
						DebugRecognitionException(eee20);
						throw eee20;
					}
					cnt20++;
				}
				loop20:
					;

				} finally { DebugExitSubRule(20); }

				DebugLocation(146, 24);
				Match(input,EOA,Follow._EOA_in_outerAlternative767); if (state.failed) return retval;

				Match(input, TokenTypes.Up, null); if (state.failed) return retval;

				DebugLocation(147, 30);
				if (state.backtracking == 0)
				{
					OtherAlt(retval.Start, rew, outerAlt);
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("outerAlternative", 10);
			LeaveRule("outerAlternative", 10);
			LeaveRule_outerAlternative();
		}
		DebugLocation(148, 4);
		} finally { DebugExitRule(GrammarFileName, "outerAlternative"); }
		return retval;

	}
	// $ANTLR end "outerAlternative"

	partial void EnterRule_binary();
	partial void LeaveRule_binary();
	// $ANTLR start "binary"
	// Grammars\\LeftRecursiveRuleWalker.g3:150:1: binary : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse EOA ) ;
	[GrammarRule("binary")]
	private void binary()
	{
		EnterRule_binary();
		EnterRule("binary", 11);
		TraceIn("binary", 11);
		GrammarAST op = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "binary");
		DebugLocation(150, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:151:2: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse EOA ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:151:4: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse EOA )
			{
			DebugLocation(151, 4);
			DebugLocation(151, 7);
			Match(input,ALT,Follow._ALT_in_binary816); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(151, 11);
			// Grammars\\LeftRecursiveRuleWalker.g3:151:11: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==BACKTRACK_SEMPRED))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:151:12: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(151, 12);
				DebugLocation(151, 14);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_binary820); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(151, 32);
					// Grammars\\LeftRecursiveRuleWalker.g3:151:32: ( . )*
					try { DebugEnterSubRule(22);
					while (true)
					{
						int alt22=2;
						try { DebugEnterDecision(22, false);
						int LA22_1 = input.LA(1);

						if (((LA22_1>=ACTION && LA22_1<=XDIGIT)))
						{
							alt22 = 1;
						}
						else if ((LA22_1==UP))
						{
							alt22 = 2;
						}


						} finally { DebugExitDecision(22); }
						switch ( alt22 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:151:32: .
							{
							DebugLocation(151, 32);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop22;
						}
					}

					loop22:
						;

					} finally { DebugExitSubRule(22); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(151, 38);
			PushFollow(Follow._recurseNoLabel_in_binary828);
			recurseNoLabel();
			PopFollow();
			if (state.failed) return;
			DebugLocation(151, 55);
			PushFollow(Follow._token_in_binary832);
			op=token();
			PopFollow();
			if (state.failed) return;
			DebugLocation(151, 62);
			PushFollow(Follow._recurse_in_binary834);
			recurse();
			PopFollow();
			if (state.failed) return;
			DebugLocation(151, 70);
			Match(input,EOA,Follow._EOA_in_binary836); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(151, 76);
			if (state.backtracking == 0)
			{
				SetTokenPrec(op, outerAlt);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("binary", 11);
			LeaveRule("binary", 11);
			LeaveRule_binary();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "binary"); }
		return;

	}
	// $ANTLR end "binary"

	partial void EnterRule_binaryMultipleOp();
	partial void LeaveRule_binaryMultipleOp();
	// $ANTLR start "binaryMultipleOp"
	// Grammars\\LeftRecursiveRuleWalker.g3:154:1: binaryMultipleOp : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ^( BLOCK ( ^( ALT op= token EOA ) )+ EOB ) recurse EOA ) ;
	[GrammarRule("binaryMultipleOp")]
	private void binaryMultipleOp()
	{
		EnterRule_binaryMultipleOp();
		EnterRule("binaryMultipleOp", 12);
		TraceIn("binaryMultipleOp", 12);
		GrammarAST op = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "binaryMultipleOp");
		DebugLocation(154, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:155:2: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ^( BLOCK ( ^( ALT op= token EOA ) )+ EOB ) recurse EOA ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:155:4: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ^( BLOCK ( ^( ALT op= token EOA ) )+ EOB ) recurse EOA )
			{
			DebugLocation(155, 4);
			DebugLocation(155, 7);
			Match(input,ALT,Follow._ALT_in_binaryMultipleOp853); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(155, 11);
			// Grammars\\LeftRecursiveRuleWalker.g3:155:11: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
			int alt25=2;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==BACKTRACK_SEMPRED))
			{
				alt25 = 1;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:155:12: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(155, 12);
				DebugLocation(155, 14);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_binaryMultipleOp857); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(155, 32);
					// Grammars\\LeftRecursiveRuleWalker.g3:155:32: ( . )*
					try { DebugEnterSubRule(24);
					while (true)
					{
						int alt24=2;
						try { DebugEnterDecision(24, false);
						int LA24_1 = input.LA(1);

						if (((LA24_1>=ACTION && LA24_1<=XDIGIT)))
						{
							alt24 = 1;
						}
						else if ((LA24_1==UP))
						{
							alt24 = 2;
						}


						} finally { DebugExitDecision(24); }
						switch ( alt24 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:155:32: .
							{
							DebugLocation(155, 32);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop24;
						}
					}

					loop24:
						;

					} finally { DebugExitSubRule(24); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(25); }

			DebugLocation(155, 38);
			PushFollow(Follow._recurseNoLabel_in_binaryMultipleOp865);
			recurseNoLabel();
			PopFollow();
			if (state.failed) return;
			DebugLocation(155, 53);
			DebugLocation(155, 56);
			Match(input,BLOCK,Follow._BLOCK_in_binaryMultipleOp869); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(155, 62);
			// Grammars\\LeftRecursiveRuleWalker.g3:155:62: ( ^( ALT op= token EOA ) )+
			int cnt26=0;
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==ALT))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:155:64: ^( ALT op= token EOA )
					{
					DebugLocation(155, 64);
					DebugLocation(155, 67);
					Match(input,ALT,Follow._ALT_in_binaryMultipleOp875); if (state.failed) return;

					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(155, 73);
					PushFollow(Follow._token_in_binaryMultipleOp879);
					op=token();
					PopFollow();
					if (state.failed) return;
					DebugLocation(155, 80);
					Match(input,EOA,Follow._EOA_in_binaryMultipleOp881); if (state.failed) return;
					DebugLocation(155, 84);
					if (state.backtracking == 0)
					{
						SetTokenPrec(op, outerAlt);
					}

					Match(input, TokenTypes.Up, null); if (state.failed) return;


					}
					break;

				default:
					if (cnt26 >= 1)
						goto loop26;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee26 = new EarlyExitException( 26, input );
					DebugRecognitionException(eee26);
					throw eee26;
				}
				cnt26++;
			}
			loop26:
				;

			} finally { DebugExitSubRule(26); }

			DebugLocation(155, 122);
			Match(input,EOB,Follow._EOB_in_binaryMultipleOp890); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(155, 128);
			PushFollow(Follow._recurse_in_binaryMultipleOp894);
			recurse();
			PopFollow();
			if (state.failed) return;
			DebugLocation(155, 136);
			Match(input,EOA,Follow._EOA_in_binaryMultipleOp896); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("binaryMultipleOp", 12);
			LeaveRule("binaryMultipleOp", 12);
			LeaveRule_binaryMultipleOp();
		}
		DebugLocation(156, 1);
		} finally { DebugExitRule(GrammarFileName, "binaryMultipleOp"); }
		return;

	}
	// $ANTLR end "binaryMultipleOp"

	partial void EnterRule_ternary();
	partial void LeaveRule_ternary();
	// $ANTLR start "ternary"
	// Grammars\\LeftRecursiveRuleWalker.g3:158:1: ternary : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse token recurse EOA ) ;
	[GrammarRule("ternary")]
	private void ternary()
	{
		EnterRule_ternary();
		EnterRule("ternary", 13);
		TraceIn("ternary", 13);
		GrammarAST op = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "ternary");
		DebugLocation(158, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:159:2: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse token recurse EOA ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:159:4: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel op= token recurse token recurse EOA )
			{
			DebugLocation(159, 4);
			DebugLocation(159, 7);
			Match(input,ALT,Follow._ALT_in_ternary911); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(159, 11);
			// Grammars\\LeftRecursiveRuleWalker.g3:159:11: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==BACKTRACK_SEMPRED))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:159:12: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(159, 12);
				DebugLocation(159, 14);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_ternary915); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(159, 32);
					// Grammars\\LeftRecursiveRuleWalker.g3:159:32: ( . )*
					try { DebugEnterSubRule(27);
					while (true)
					{
						int alt27=2;
						try { DebugEnterDecision(27, false);
						int LA27_1 = input.LA(1);

						if (((LA27_1>=ACTION && LA27_1<=XDIGIT)))
						{
							alt27 = 1;
						}
						else if ((LA27_1==UP))
						{
							alt27 = 2;
						}


						} finally { DebugExitDecision(27); }
						switch ( alt27 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:159:32: .
							{
							DebugLocation(159, 32);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop27;
						}
					}

					loop27:
						;

					} finally { DebugExitSubRule(27); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(28); }

			DebugLocation(159, 38);
			PushFollow(Follow._recurseNoLabel_in_ternary923);
			recurseNoLabel();
			PopFollow();
			if (state.failed) return;
			DebugLocation(159, 55);
			PushFollow(Follow._token_in_ternary927);
			op=token();
			PopFollow();
			if (state.failed) return;
			DebugLocation(159, 62);
			PushFollow(Follow._recurse_in_ternary929);
			recurse();
			PopFollow();
			if (state.failed) return;
			DebugLocation(159, 70);
			PushFollow(Follow._token_in_ternary931);
			token();
			PopFollow();
			if (state.failed) return;
			DebugLocation(159, 76);
			PushFollow(Follow._recurse_in_ternary933);
			recurse();
			PopFollow();
			if (state.failed) return;
			DebugLocation(159, 84);
			Match(input,EOA,Follow._EOA_in_ternary935); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;

			DebugLocation(159, 90);
			if (state.backtracking == 0)
			{
				SetTokenPrec(op, outerAlt);
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ternary", 13);
			LeaveRule("ternary", 13);
			LeaveRule_ternary();
		}
		DebugLocation(160, 1);
		} finally { DebugExitRule(GrammarFileName, "ternary"); }
		return;

	}
	// $ANTLR end "ternary"

	partial void EnterRule_prefix();
	partial void LeaveRule_prefix();
	// $ANTLR start "prefix"
	// Grammars\\LeftRecursiveRuleWalker.g3:162:1: prefix : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? ({...}? element )+ recurse EOA ) ;
	[GrammarRule("prefix")]
	private void prefix()
	{
		EnterRule_prefix();
		EnterRule("prefix", 14);
		TraceIn("prefix", 14);
		try { DebugEnterRule(GrammarFileName, "prefix");
		DebugLocation(162, 171);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:162:8: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? ({...}? element )+ recurse EOA ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:162:10: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? ({...}? element )+ recurse EOA )
			{
			DebugLocation(162, 10);
			DebugLocation(162, 13);
			Match(input,ALT,Follow._ALT_in_prefix951); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(162, 17);
			// Grammars\\LeftRecursiveRuleWalker.g3:162:17: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_1 = input.LA(1);

			if ((LA30_1==BACKTRACK_SEMPRED))
			{
				int LA30_2 = input.LA(2);

				if ((LA30_2==DOWN))
				{
					alt30 = 1;
				}
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:162:18: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(162, 18);
				DebugLocation(162, 20);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_prefix955); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(162, 38);
					// Grammars\\LeftRecursiveRuleWalker.g3:162:38: ( . )*
					try { DebugEnterSubRule(29);
					while (true)
					{
						int alt29=2;
						try { DebugEnterDecision(29, false);
						int LA29_1 = input.LA(1);

						if (((LA29_1>=ACTION && LA29_1<=XDIGIT)))
						{
							alt29 = 1;
						}
						else if ((LA29_1==UP))
						{
							alt29 = 2;
						}


						} finally { DebugExitDecision(29); }
						switch ( alt29 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:162:38: .
							{
							DebugLocation(162, 38);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop29;
						}
					}

					loop29:
						;

					} finally { DebugExitSubRule(29); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(162, 44);
			if (state.backtracking == 0)
			{
				SetTokenPrec((GrammarAST)input.LT(1), outerAlt);
			}
			DebugLocation(162, 95);
			// Grammars\\LeftRecursiveRuleWalker.g3:162:95: ({...}? element )+
			int cnt31=0;
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				switch (input.LA(1))
				{
				case ASSIGN:
					{
					int LA31_2 = input.LA(2);

					if ((LA31_2==DOWN))
					{
						int LA31_3 = input.LA(3);

						if ((LA31_3==ID))
						{
							int LA31_4 = input.LA(4);

							if ((LA31_4==RULE_REF))
							{
								int LA31_5 = input.LA(5);

								if ((LA31_5==DOWN))
								{
									alt31 = 1;
								}


							}
							else if ((LA31_4==ACTION||(LA31_4>=ASSIGN && LA31_4<=BLOCK)||LA31_4==CHAR_LITERAL||LA31_4==CLOSURE||LA31_4==DOT||LA31_4==EPSILON||LA31_4==FORCED_ACTION||LA31_4==GATED_SEMPRED||LA31_4==NOT||LA31_4==OPTIONAL||(LA31_4>=PLUS_ASSIGN && LA31_4<=POSITIVE_CLOSURE)||LA31_4==RANGE||LA31_4==ROOT||LA31_4==SEMPRED||(LA31_4>=STRING_LITERAL && LA31_4<=SYN_SEMPRED)||LA31_4==TOKEN_REF||LA31_4==TREE_BEGIN||LA31_4==WILDCARD))
							{
								alt31 = 1;
							}


						}


					}


					}
					break;
				case PLUS_ASSIGN:
					{
					int LA31_2 = input.LA(2);

					if ((LA31_2==DOWN))
					{
						int LA31_3 = input.LA(3);

						if ((LA31_3==ID))
						{
							int LA31_4 = input.LA(4);

							if ((LA31_4==RULE_REF))
							{
								int LA31_5 = input.LA(5);

								if ((LA31_5==DOWN))
								{
									alt31 = 1;
								}


							}
							else if ((LA31_4==ACTION||(LA31_4>=ASSIGN && LA31_4<=BLOCK)||LA31_4==CHAR_LITERAL||LA31_4==CLOSURE||LA31_4==DOT||LA31_4==EPSILON||LA31_4==FORCED_ACTION||LA31_4==GATED_SEMPRED||LA31_4==NOT||LA31_4==OPTIONAL||(LA31_4>=PLUS_ASSIGN && LA31_4<=POSITIVE_CLOSURE)||LA31_4==RANGE||LA31_4==ROOT||LA31_4==SEMPRED||(LA31_4>=STRING_LITERAL && LA31_4<=SYN_SEMPRED)||LA31_4==TOKEN_REF||LA31_4==TREE_BEGIN||LA31_4==WILDCARD))
							{
								alt31 = 1;
							}


						}


					}


					}
					break;
				case RULE_REF:
					{
					int LA31_2 = input.LA(2);

					if ((LA31_2==DOWN))
					{
						alt31 = 1;
					}


					}
					break;
				case ACTION:
				case BACKTRACK_SEMPRED:
				case BANG:
				case BLOCK:
				case CHAR_LITERAL:
				case CLOSURE:
				case DOT:
				case EPSILON:
				case FORCED_ACTION:
				case GATED_SEMPRED:
				case NOT:
				case OPTIONAL:
				case POSITIVE_CLOSURE:
				case RANGE:
				case ROOT:
				case SEMPRED:
				case STRING_LITERAL:
				case SYNPRED:
				case SYN_SEMPRED:
				case TOKEN_REF:
				case TREE_BEGIN:
				case WILDCARD:
					{
					alt31 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:162:96: {...}? element
					{
					DebugLocation(162, 96);
					if (!((!((CommonTree)input.LT(1)).Text.Equals(ruleName))))
					{
						if (state.backtracking>0) {state.failed=true; return;}
						throw new FailedPredicateException(input, "prefix", "!((CommonTree)input.LT(1)).Text.Equals(ruleName)");
					}
					DebugLocation(162, 148);
					PushFollow(Follow._element_in_prefix968);
					element();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					if (cnt31 >= 1)
						goto loop31;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee31 = new EarlyExitException( 31, input );
					DebugRecognitionException(eee31);
					throw eee31;
				}
				cnt31++;
			}
			loop31:
				;

			} finally { DebugExitSubRule(31); }

			DebugLocation(162, 158);
			PushFollow(Follow._recurse_in_prefix972);
			recurse();
			PopFollow();
			if (state.failed) return;
			DebugLocation(162, 166);
			Match(input,EOA,Follow._EOA_in_prefix974); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("prefix", 14);
			LeaveRule("prefix", 14);
			LeaveRule_prefix();
		}
		DebugLocation(162, 171);
		} finally { DebugExitRule(GrammarFileName, "prefix"); }
		return;

	}
	// $ANTLR end "prefix"

	partial void EnterRule_suffix();
	partial void LeaveRule_suffix();
	// $ANTLR start "suffix"
	// Grammars\\LeftRecursiveRuleWalker.g3:164:1: suffix : ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ( element )+ EOA ) ;
	[GrammarRule("suffix")]
	private void suffix()
	{
		EnterRule_suffix();
		EnterRule("suffix", 15);
		TraceIn("suffix", 15);
		try { DebugEnterRule(GrammarFileName, "suffix");
		DebugLocation(164, 125);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:164:8: ( ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ( element )+ EOA ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:164:10: ^( ALT ( ^( BACKTRACK_SEMPRED ( . )* ) )? recurseNoLabel ( element )+ EOA )
			{
			DebugLocation(164, 10);
			DebugLocation(164, 13);
			Match(input,ALT,Follow._ALT_in_suffix987); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(164, 17);
			// Grammars\\LeftRecursiveRuleWalker.g3:164:17: ( ^( BACKTRACK_SEMPRED ( . )* ) )?
			int alt33=2;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1==BACKTRACK_SEMPRED))
			{
				alt33 = 1;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:164:18: ^( BACKTRACK_SEMPRED ( . )* )
				{
				DebugLocation(164, 18);
				DebugLocation(164, 20);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_suffix991); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(164, 38);
					// Grammars\\LeftRecursiveRuleWalker.g3:164:38: ( . )*
					try { DebugEnterSubRule(32);
					while (true)
					{
						int alt32=2;
						try { DebugEnterDecision(32, false);
						int LA32_1 = input.LA(1);

						if (((LA32_1>=ACTION && LA32_1<=XDIGIT)))
						{
							alt32 = 1;
						}
						else if ((LA32_1==UP))
						{
							alt32 = 2;
						}


						} finally { DebugExitDecision(32); }
						switch ( alt32 )
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:164:38: .
							{
							DebugLocation(164, 38);
							MatchAny(input); if (state.failed) return;

							}
							break;

						default:
							goto loop32;
						}
					}

					loop32:
						;

					} finally { DebugExitSubRule(32); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;

			}
			} finally { DebugExitSubRule(33); }

			DebugLocation(164, 44);
			PushFollow(Follow._recurseNoLabel_in_suffix999);
			recurseNoLabel();
			PopFollow();
			if (state.failed) return;
			DebugLocation(164, 59);
			if (state.backtracking == 0)
			{
				SetTokenPrec((GrammarAST)input.LT(1), outerAlt);
			}
			DebugLocation(164, 110);
			// Grammars\\LeftRecursiveRuleWalker.g3:164:110: ( element )+
			int cnt34=0;
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==ACTION||(LA34_1>=ASSIGN && LA34_1<=BLOCK)||LA34_1==CHAR_LITERAL||LA34_1==CLOSURE||LA34_1==DOT||LA34_1==EPSILON||LA34_1==FORCED_ACTION||LA34_1==GATED_SEMPRED||LA34_1==NOT||LA34_1==OPTIONAL||(LA34_1>=PLUS_ASSIGN && LA34_1<=POSITIVE_CLOSURE)||LA34_1==RANGE||LA34_1==ROOT||LA34_1==RULE_REF||LA34_1==SEMPRED||(LA34_1>=STRING_LITERAL && LA34_1<=SYN_SEMPRED)||LA34_1==TOKEN_REF||LA34_1==TREE_BEGIN||LA34_1==WILDCARD))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch (alt34)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:164:110: element
					{
					DebugLocation(164, 110);
					PushFollow(Follow._element_in_suffix1003);
					element();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					if (cnt34 >= 1)
						goto loop34;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee34 = new EarlyExitException( 34, input );
					DebugRecognitionException(eee34);
					throw eee34;
				}
				cnt34++;
			}
			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(164, 120);
			Match(input,EOA,Follow._EOA_in_suffix1007); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("suffix", 15);
			LeaveRule("suffix", 15);
			LeaveRule_suffix();
		}
		DebugLocation(164, 125);
		} finally { DebugExitRule(GrammarFileName, "suffix"); }
		return;

	}
	// $ANTLR end "suffix"

	partial void EnterRule_recurse();
	partial void LeaveRule_recurse();
	// $ANTLR start "recurse"
	// Grammars\\LeftRecursiveRuleWalker.g3:166:1: recurse : ( ^( ASSIGN ID recurseNoLabel ) | ^( PLUS_ASSIGN ID recurseNoLabel ) | recurseNoLabel );
	[GrammarRule("recurse")]
	private void recurse()
	{
		EnterRule_recurse();
		EnterRule("recurse", 16);
		TraceIn("recurse", 16);
		try { DebugEnterRule(GrammarFileName, "recurse");
		DebugLocation(166, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:167:2: ( ^( ASSIGN ID recurseNoLabel ) | ^( PLUS_ASSIGN ID recurseNoLabel ) | recurseNoLabel )
			int alt35=3;
			try { DebugEnterDecision(35, false);
			switch (input.LA(1))
			{
			case ASSIGN:
				{
				alt35 = 1;
				}
				break;
			case PLUS_ASSIGN:
				{
				alt35 = 2;
				}
				break;
			case RULE_REF:
				{
				alt35 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 35, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:167:4: ^( ASSIGN ID recurseNoLabel )
				{
				DebugLocation(167, 4);
				DebugLocation(167, 6);
				Match(input,ASSIGN,Follow._ASSIGN_in_recurse1020); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(167, 13);
				Match(input,ID,Follow._ID_in_recurse1022); if (state.failed) return;
				DebugLocation(167, 16);
				PushFollow(Follow._recurseNoLabel_in_recurse1024);
				recurseNoLabel();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:168:4: ^( PLUS_ASSIGN ID recurseNoLabel )
				{
				DebugLocation(168, 4);
				DebugLocation(168, 6);
				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_recurse1031); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(168, 18);
				Match(input,ID,Follow._ID_in_recurse1033); if (state.failed) return;
				DebugLocation(168, 21);
				PushFollow(Follow._recurseNoLabel_in_recurse1035);
				recurseNoLabel();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:169:4: recurseNoLabel
				{
				DebugLocation(169, 4);
				PushFollow(Follow._recurseNoLabel_in_recurse1041);
				recurseNoLabel();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("recurse", 16);
			LeaveRule("recurse", 16);
			LeaveRule_recurse();
		}
		DebugLocation(170, 1);
		} finally { DebugExitRule(GrammarFileName, "recurse"); }
		return;

	}
	// $ANTLR end "recurse"

	partial void EnterRule_recurseNoLabel();
	partial void LeaveRule_recurseNoLabel();
	// $ANTLR start "recurseNoLabel"
	// Grammars\\LeftRecursiveRuleWalker.g3:172:1: recurseNoLabel :{...}? RULE_REF ;
	[GrammarRule("recurseNoLabel")]
	private void recurseNoLabel()
	{
		EnterRule_recurseNoLabel();
		EnterRule("recurseNoLabel", 17);
		TraceIn("recurseNoLabel", 17);
		try { DebugEnterRule(GrammarFileName, "recurseNoLabel");
		DebugLocation(172, 76);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:172:16: ({...}? RULE_REF )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:172:18: {...}? RULE_REF
			{
			DebugLocation(172, 18);
			if (!((((CommonTree)input.LT(1)).Text.Equals(ruleName))))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "recurseNoLabel", "((CommonTree)input.LT(1)).Text.Equals(ruleName)");
			}
			DebugLocation(172, 69);
			Match(input,RULE_REF,Follow._RULE_REF_in_recurseNoLabel1053); if (state.failed) return;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("recurseNoLabel", 17);
			LeaveRule("recurseNoLabel", 17);
			LeaveRule_recurseNoLabel();
		}
		DebugLocation(172, 76);
		} finally { DebugExitRule(GrammarFileName, "recurseNoLabel"); }
		return;

	}
	// $ANTLR end "recurseNoLabel"

	partial void EnterRule_token();
	partial void LeaveRule_token();
	// $ANTLR start "token"
	// Grammars\\LeftRecursiveRuleWalker.g3:181:1: token returns [GrammarAST t=null] : ( ^( ASSIGN ID s= token ) | ^( PLUS_ASSIGN ID s= token ) | ^( ROOT s= token ) | ^( BANG s= token ) |a= CHAR_LITERAL |b= STRING_LITERAL |c= TOKEN_REF );
	[GrammarRule("token")]
	private GrammarAST token()
	{
		EnterRule_token();
		EnterRule("token", 18);
		TraceIn("token", 18);
		GrammarAST t = null;


		GrammarAST a = default(GrammarAST);
		GrammarAST b = default(GrammarAST);
		GrammarAST c = default(GrammarAST);
		GrammarAST s = default(GrammarAST);

		try { DebugEnterRule(GrammarFileName, "token");
		DebugLocation(181, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:182:2: ( ^( ASSIGN ID s= token ) | ^( PLUS_ASSIGN ID s= token ) | ^( ROOT s= token ) | ^( BANG s= token ) |a= CHAR_LITERAL |b= STRING_LITERAL |c= TOKEN_REF )
			int alt36=7;
			try { DebugEnterDecision(36, false);
			switch (input.LA(1))
			{
			case ASSIGN:
				{
				alt36 = 1;
				}
				break;
			case PLUS_ASSIGN:
				{
				alt36 = 2;
				}
				break;
			case ROOT:
				{
				alt36 = 3;
				}
				break;
			case BANG:
				{
				alt36 = 4;
				}
				break;
			case CHAR_LITERAL:
				{
				alt36 = 5;
				}
				break;
			case STRING_LITERAL:
				{
				alt36 = 6;
				}
				break;
			case TOKEN_REF:
				{
				alt36 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return t;}
					NoViableAltException nvae = new NoViableAltException("", 36, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:182:4: ^( ASSIGN ID s= token )
				{
				DebugLocation(182, 4);
				DebugLocation(182, 6);
				Match(input,ASSIGN,Follow._ASSIGN_in_token1070); if (state.failed) return t;

				Match(input, TokenTypes.Down, null); if (state.failed) return t;
				DebugLocation(182, 13);
				Match(input,ID,Follow._ID_in_token1072); if (state.failed) return t;
				DebugLocation(182, 17);
				PushFollow(Follow._token_in_token1076);
				s=token();
				PopFollow();
				if (state.failed) return t;
				DebugLocation(182, 24);
				if (state.backtracking == 0)
				{
					t = s;
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return t;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:183:4: ^( PLUS_ASSIGN ID s= token )
				{
				DebugLocation(183, 4);
				DebugLocation(183, 6);
				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_token1085); if (state.failed) return t;

				Match(input, TokenTypes.Down, null); if (state.failed) return t;
				DebugLocation(183, 18);
				Match(input,ID,Follow._ID_in_token1087); if (state.failed) return t;
				DebugLocation(183, 22);
				PushFollow(Follow._token_in_token1091);
				s=token();
				PopFollow();
				if (state.failed) return t;
				DebugLocation(183, 29);
				if (state.backtracking == 0)
				{
					t = s;
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return t;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:184:4: ^( ROOT s= token )
				{
				DebugLocation(184, 4);
				DebugLocation(184, 6);
				Match(input,ROOT,Follow._ROOT_in_token1100); if (state.failed) return t;

				Match(input, TokenTypes.Down, null); if (state.failed) return t;
				DebugLocation(184, 12);
				PushFollow(Follow._token_in_token1104);
				s=token();
				PopFollow();
				if (state.failed) return t;
				DebugLocation(184, 19);
				if (state.backtracking == 0)
				{
					t = s;
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return t;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LeftRecursiveRuleWalker.g3:185:4: ^( BANG s= token )
				{
				DebugLocation(185, 4);
				DebugLocation(185, 6);
				Match(input,BANG,Follow._BANG_in_token1113); if (state.failed) return t;

				Match(input, TokenTypes.Down, null); if (state.failed) return t;
				DebugLocation(185, 12);
				PushFollow(Follow._token_in_token1117);
				s=token();
				PopFollow();
				if (state.failed) return t;
				DebugLocation(185, 19);
				if (state.backtracking == 0)
				{
					t = s;
				}

				Match(input, TokenTypes.Up, null); if (state.failed) return t;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LeftRecursiveRuleWalker.g3:186:4: a= CHAR_LITERAL
				{
				DebugLocation(186, 5);
				a=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_token1127); if (state.failed) return t;
				DebugLocation(186, 24);
				if (state.backtracking == 0)
				{
					t = a;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LeftRecursiveRuleWalker.g3:187:4: b= STRING_LITERAL
				{
				DebugLocation(187, 5);
				b=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_token1141); if (state.failed) return t;
				DebugLocation(187, 24);
				if (state.backtracking == 0)
				{
					t = b;
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LeftRecursiveRuleWalker.g3:188:4: c= TOKEN_REF
				{
				DebugLocation(188, 5);
				c=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_token1153); if (state.failed) return t;
				DebugLocation(188, 24);
				if (state.backtracking == 0)
				{
					t = c;
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("token", 18);
			LeaveRule("token", 18);
			LeaveRule_token();
		}
		DebugLocation(189, 1);
		} finally { DebugExitRule(GrammarFileName, "token"); }
		return t;

	}
	// $ANTLR end "token"

	partial void EnterRule_exceptionGroup();
	partial void LeaveRule_exceptionGroup();
	// $ANTLR start "exceptionGroup"
	// Grammars\\LeftRecursiveRuleWalker.g3:191:1: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
	[GrammarRule("exceptionGroup")]
	private void exceptionGroup()
	{
		EnterRule_exceptionGroup();
		EnterRule("exceptionGroup", 19);
		TraceIn("exceptionGroup", 19);
		try { DebugEnterRule(GrammarFileName, "exceptionGroup");
		DebugLocation(191, 4);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:192:2: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
			int alt39=2;
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==CATCH))
			{
				alt39 = 1;
			}
			else if ((LA39_1==FINALLY))
			{
				alt39 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 39, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:192:4: ( exceptionHandler )+ ( finallyClause )?
				{
				DebugLocation(192, 4);
				// Grammars\\LeftRecursiveRuleWalker.g3:192:4: ( exceptionHandler )+
				int cnt37=0;
				try { DebugEnterSubRule(37);
				while (true)
				{
					int alt37=2;
					try { DebugEnterDecision(37, false);
					int LA37_1 = input.LA(1);

					if ((LA37_1==CATCH))
					{
						alt37 = 1;
					}


					} finally { DebugExitDecision(37); }
					switch (alt37)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:192:4: exceptionHandler
						{
						DebugLocation(192, 4);
						PushFollow(Follow._exceptionHandler_in_exceptionGroup1174);
						exceptionHandler();
						PopFollow();
						if (state.failed) return;

						}
						break;

					default:
						if (cnt37 >= 1)
							goto loop37;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee37 = new EarlyExitException( 37, input );
						DebugRecognitionException(eee37);
						throw eee37;
					}
					cnt37++;
				}
				loop37:
					;

				} finally { DebugExitSubRule(37); }

				DebugLocation(192, 22);
				// Grammars\\LeftRecursiveRuleWalker.g3:192:22: ( finallyClause )?
				int alt38=2;
				try { DebugEnterSubRule(38);
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1==FINALLY))
				{
					alt38 = 1;
				}
				} finally { DebugExitDecision(38); }
				switch (alt38)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:192:22: finallyClause
					{
					DebugLocation(192, 22);
					PushFollow(Follow._finallyClause_in_exceptionGroup1177);
					finallyClause();
					PopFollow();
					if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(38); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:193:4: finallyClause
				{
				DebugLocation(193, 4);
				PushFollow(Follow._finallyClause_in_exceptionGroup1183);
				finallyClause();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionGroup", 19);
			LeaveRule("exceptionGroup", 19);
			LeaveRule_exceptionGroup();
		}
		DebugLocation(194, 4);
		} finally { DebugExitRule(GrammarFileName, "exceptionGroup"); }
		return;

	}
	// $ANTLR end "exceptionGroup"

	partial void EnterRule_exceptionHandler();
	partial void LeaveRule_exceptionHandler();
	// $ANTLR start "exceptionHandler"
	// Grammars\\LeftRecursiveRuleWalker.g3:196:1: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
	[GrammarRule("exceptionHandler")]
	private void exceptionHandler()
	{
		EnterRule_exceptionHandler();
		EnterRule("exceptionHandler", 20);
		TraceIn("exceptionHandler", 20);
		try { DebugEnterRule(GrammarFileName, "exceptionHandler");
		DebugLocation(196, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:197:2: ( ^( 'catch' ARG_ACTION ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:197:4: ^( 'catch' ARG_ACTION ACTION )
			{
			DebugLocation(197, 4);
			DebugLocation(197, 6);
			Match(input,CATCH,Follow._CATCH_in_exceptionHandler1198); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(197, 14);
			Match(input,ARG_ACTION,Follow._ARG_ACTION_in_exceptionHandler1200); if (state.failed) return;
			DebugLocation(197, 25);
			Match(input,ACTION,Follow._ACTION_in_exceptionHandler1202); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("exceptionHandler", 20);
			LeaveRule("exceptionHandler", 20);
			LeaveRule_exceptionHandler();
		}
		DebugLocation(198, 1);
		} finally { DebugExitRule(GrammarFileName, "exceptionHandler"); }
		return;

	}
	// $ANTLR end "exceptionHandler"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// Grammars\\LeftRecursiveRuleWalker.g3:200:1: finallyClause : ^( 'finally' ACTION ) ;
	[GrammarRule("finallyClause")]
	private void finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 21);
		TraceIn("finallyClause", 21);
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(200, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:201:2: ( ^( 'finally' ACTION ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:201:4: ^( 'finally' ACTION )
			{
			DebugLocation(201, 4);
			DebugLocation(201, 6);
			Match(input,FINALLY,Follow._FINALLY_in_finallyClause1215); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(201, 16);
			Match(input,ACTION,Follow._ACTION_in_finallyClause1217); if (state.failed) return;

			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("finallyClause", 21);
			LeaveRule("finallyClause", 21);
			LeaveRule_finallyClause();
		}
		DebugLocation(202, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_rewrite();
	partial void LeaveRule_rewrite();
	// $ANTLR start "rewrite"
	// Grammars\\LeftRecursiveRuleWalker.g3:204:1: rewrite : ^( REWRITES ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )* ) ;
	[GrammarRule("rewrite")]
	private void rewrite()
	{
		EnterRule_rewrite();
		EnterRule("rewrite", 22);
		TraceIn("rewrite", 22);
		try { DebugEnterRule(GrammarFileName, "rewrite");
		DebugLocation(204, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:205:2: ( ^( REWRITES ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )* ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:205:4: ^( REWRITES ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )* )
			{
			DebugLocation(205, 4);
			DebugLocation(205, 6);
			Match(input,REWRITES,Follow._REWRITES_in_rewrite1230); if (state.failed) return;

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(205, 15);
				// Grammars\\LeftRecursiveRuleWalker.g3:205:15: ( ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) ) )*
				try { DebugEnterSubRule(44);
				while (true)
				{
					int alt44=2;
					try { DebugEnterDecision(44, false);
					int LA44_1 = input.LA(1);

					if ((LA44_1==REWRITE))
					{
						alt44 = 1;
					}


					} finally { DebugExitDecision(44); }
					switch ( alt44 )
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:205:17: ^( REWRITE ( SEMPRED )? ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC ) )
						{
						DebugLocation(205, 17);
						DebugLocation(205, 20);
						Match(input,REWRITE,Follow._REWRITE_in_rewrite1236); if (state.failed) return;

						Match(input, TokenTypes.Down, null); if (state.failed) return;
						DebugLocation(205, 28);
						// Grammars\\LeftRecursiveRuleWalker.g3:205:28: ( SEMPRED )?
						int alt40=2;
						try { DebugEnterSubRule(40);
						try { DebugEnterDecision(40, false);
						int LA40_1 = input.LA(1);

						if ((LA40_1==SEMPRED))
						{
							alt40 = 1;
						}
						} finally { DebugExitDecision(40); }
						switch (alt40)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:205:28: SEMPRED
							{
							DebugLocation(205, 28);
							Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1238); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(40); }

						DebugLocation(205, 37);
						// Grammars\\LeftRecursiveRuleWalker.g3:205:37: ( ^( ALT ( . )* ) | ^( TEMPLATE ( . )* ) | ACTION | ETC )
						int alt43=4;
						try { DebugEnterSubRule(43);
						try { DebugEnterDecision(43, false);
						switch (input.LA(1))
						{
						case ALT:
							{
							alt43 = 1;
							}
							break;
						case TEMPLATE:
							{
							alt43 = 2;
							}
							break;
						case ACTION:
							{
							alt43 = 3;
							}
							break;
						case ETC:
							{
							alt43 = 4;
							}
							break;
						default:
							{
								if (state.backtracking>0) {state.failed=true; return;}
								NoViableAltException nvae = new NoViableAltException("", 43, 0, input, 1);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

						} finally { DebugExitDecision(43); }
						switch (alt43)
						{
						case 1:
							DebugEnterAlt(1);
							// Grammars\\LeftRecursiveRuleWalker.g3:205:38: ^( ALT ( . )* )
							{
							DebugLocation(205, 38);
							DebugLocation(205, 40);
							Match(input,ALT,Follow._ALT_in_rewrite1243); if (state.failed) return;

							if (input.LA(1) == TokenTypes.Down)
							{
								Match(input, TokenTypes.Down, null); if (state.failed) return;
								DebugLocation(205, 44);
								// Grammars\\LeftRecursiveRuleWalker.g3:205:44: ( . )*
								try { DebugEnterSubRule(41);
								while (true)
								{
									int alt41=2;
									try { DebugEnterDecision(41, false);
									int LA41_1 = input.LA(1);

									if (((LA41_1>=ACTION && LA41_1<=XDIGIT)))
									{
										alt41 = 1;
									}
									else if ((LA41_1==UP))
									{
										alt41 = 2;
									}


									} finally { DebugExitDecision(41); }
									switch ( alt41 )
									{
									case 1:
										DebugEnterAlt(1);
										// Grammars\\LeftRecursiveRuleWalker.g3:205:44: .
										{
										DebugLocation(205, 44);
										MatchAny(input); if (state.failed) return;

										}
										break;

									default:
										goto loop41;
									}
								}

								loop41:
									;

								} finally { DebugExitSubRule(41); }


								Match(input, TokenTypes.Up, null); if (state.failed) return;
							}


							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Grammars\\LeftRecursiveRuleWalker.g3:205:48: ^( TEMPLATE ( . )* )
							{
							DebugLocation(205, 48);
							DebugLocation(205, 50);
							Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite1250); if (state.failed) return;

							if (input.LA(1) == TokenTypes.Down)
							{
								Match(input, TokenTypes.Down, null); if (state.failed) return;
								DebugLocation(205, 59);
								// Grammars\\LeftRecursiveRuleWalker.g3:205:59: ( . )*
								try { DebugEnterSubRule(42);
								while (true)
								{
									int alt42=2;
									try { DebugEnterDecision(42, false);
									int LA42_1 = input.LA(1);

									if (((LA42_1>=ACTION && LA42_1<=XDIGIT)))
									{
										alt42 = 1;
									}
									else if ((LA42_1==UP))
									{
										alt42 = 2;
									}


									} finally { DebugExitDecision(42); }
									switch ( alt42 )
									{
									case 1:
										DebugEnterAlt(1);
										// Grammars\\LeftRecursiveRuleWalker.g3:205:59: .
										{
										DebugLocation(205, 59);
										MatchAny(input); if (state.failed) return;

										}
										break;

									default:
										goto loop42;
									}
								}

								loop42:
									;

								} finally { DebugExitSubRule(42); }


								Match(input, TokenTypes.Up, null); if (state.failed) return;
							}


							}
							break;
						case 3:
							DebugEnterAlt(3);
							// Grammars\\LeftRecursiveRuleWalker.g3:205:63: ACTION
							{
							DebugLocation(205, 63);
							Match(input,ACTION,Follow._ACTION_in_rewrite1256); if (state.failed) return;

							}
							break;
						case 4:
							DebugEnterAlt(4);
							// Grammars\\LeftRecursiveRuleWalker.g3:205:70: ETC
							{
							DebugLocation(205, 70);
							Match(input,ETC,Follow._ETC_in_rewrite1258); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(43); }


						Match(input, TokenTypes.Up, null); if (state.failed) return;


						}
						break;

					default:
						goto loop44;
					}
				}

				loop44:
					;

				} finally { DebugExitSubRule(44); }


				Match(input, TokenTypes.Up, null); if (state.failed) return;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("rewrite", 22);
			LeaveRule("rewrite", 22);
			LeaveRule_rewrite();
		}
		DebugLocation(206, 1);
		} finally { DebugExitRule(GrammarFileName, "rewrite"); }
		return;

	}
	// $ANTLR end "rewrite"

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// Grammars\\LeftRecursiveRuleWalker.g3:208:1: element : ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | BACKTRACK_SEMPRED | GATED_SEMPRED | EPSILON );
	[GrammarRule("element")]
	private void element()
	{
		EnterRule_element();
		EnterRule("element", 23);
		TraceIn("element", 23);
		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(208, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:209:2: ( ^( ROOT element ) | ^( BANG element ) | atom | ^( NOT element ) | ^( RANGE atom atom ) | ^( ASSIGN ID element ) | ^( PLUS_ASSIGN ID element ) | ebnf | tree_ | ^( SYNPRED block ) | FORCED_ACTION | ACTION | SEMPRED | SYN_SEMPRED | BACKTRACK_SEMPRED | GATED_SEMPRED | EPSILON )
			int alt45=17;
			try { DebugEnterDecision(45, false);
			switch (input.LA(1))
			{
			case ROOT:
				{
				alt45 = 1;
				}
				break;
			case BANG:
				{
				alt45 = 2;
				}
				break;
			case CHAR_LITERAL:
			case DOT:
			case RULE_REF:
			case STRING_LITERAL:
			case TOKEN_REF:
			case WILDCARD:
				{
				alt45 = 3;
				}
				break;
			case NOT:
				{
				alt45 = 4;
				}
				break;
			case RANGE:
				{
				alt45 = 5;
				}
				break;
			case ASSIGN:
				{
				alt45 = 6;
				}
				break;
			case PLUS_ASSIGN:
				{
				alt45 = 7;
				}
				break;
			case BLOCK:
			case CLOSURE:
			case OPTIONAL:
			case POSITIVE_CLOSURE:
				{
				alt45 = 8;
				}
				break;
			case TREE_BEGIN:
				{
				alt45 = 9;
				}
				break;
			case SYNPRED:
				{
				alt45 = 10;
				}
				break;
			case FORCED_ACTION:
				{
				alt45 = 11;
				}
				break;
			case ACTION:
				{
				alt45 = 12;
				}
				break;
			case SEMPRED:
				{
				alt45 = 13;
				}
				break;
			case SYN_SEMPRED:
				{
				alt45 = 14;
				}
				break;
			case BACKTRACK_SEMPRED:
				{
				alt45 = 15;
				}
				break;
			case GATED_SEMPRED:
				{
				alt45 = 16;
				}
				break;
			case EPSILON:
				{
				alt45 = 17;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:209:4: ^( ROOT element )
				{
				DebugLocation(209, 4);
				DebugLocation(209, 6);
				Match(input,ROOT,Follow._ROOT_in_element1278); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(209, 11);
				PushFollow(Follow._element_in_element1280);
				element();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:210:4: ^( BANG element )
				{
				DebugLocation(210, 4);
				DebugLocation(210, 6);
				Match(input,BANG,Follow._BANG_in_element1287); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(210, 11);
				PushFollow(Follow._element_in_element1289);
				element();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:211:4: atom
				{
				DebugLocation(211, 4);
				PushFollow(Follow._atom_in_element1295);
				atom();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LeftRecursiveRuleWalker.g3:212:4: ^( NOT element )
				{
				DebugLocation(212, 4);
				DebugLocation(212, 6);
				Match(input,NOT,Follow._NOT_in_element1301); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(212, 10);
				PushFollow(Follow._element_in_element1303);
				element();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LeftRecursiveRuleWalker.g3:213:4: ^( RANGE atom atom )
				{
				DebugLocation(213, 4);
				DebugLocation(213, 6);
				Match(input,RANGE,Follow._RANGE_in_element1310); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(213, 12);
				PushFollow(Follow._atom_in_element1312);
				atom();
				PopFollow();
				if (state.failed) return;
				DebugLocation(213, 17);
				PushFollow(Follow._atom_in_element1314);
				atom();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LeftRecursiveRuleWalker.g3:214:4: ^( ASSIGN ID element )
				{
				DebugLocation(214, 4);
				DebugLocation(214, 6);
				Match(input,ASSIGN,Follow._ASSIGN_in_element1321); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(214, 13);
				Match(input,ID,Follow._ID_in_element1323); if (state.failed) return;
				DebugLocation(214, 16);
				PushFollow(Follow._element_in_element1325);
				element();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Grammars\\LeftRecursiveRuleWalker.g3:215:4: ^( PLUS_ASSIGN ID element )
				{
				DebugLocation(215, 4);
				DebugLocation(215, 6);
				Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element1332); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(215, 18);
				Match(input,ID,Follow._ID_in_element1334); if (state.failed) return;
				DebugLocation(215, 21);
				PushFollow(Follow._element_in_element1336);
				element();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Grammars\\LeftRecursiveRuleWalker.g3:216:4: ebnf
				{
				DebugLocation(216, 4);
				PushFollow(Follow._ebnf_in_element1342);
				ebnf();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Grammars\\LeftRecursiveRuleWalker.g3:217:4: tree_
				{
				DebugLocation(217, 4);
				PushFollow(Follow._tree__in_element1347);
				tree_();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Grammars\\LeftRecursiveRuleWalker.g3:218:4: ^( SYNPRED block )
				{
				DebugLocation(218, 4);
				DebugLocation(218, 6);
				Match(input,SYNPRED,Follow._SYNPRED_in_element1353); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(218, 14);
				PushFollow(Follow._block_in_element1355);
				block();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Grammars\\LeftRecursiveRuleWalker.g3:219:4: FORCED_ACTION
				{
				DebugLocation(219, 4);
				Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element1362); if (state.failed) return;

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// Grammars\\LeftRecursiveRuleWalker.g3:220:4: ACTION
				{
				DebugLocation(220, 4);
				Match(input,ACTION,Follow._ACTION_in_element1367); if (state.failed) return;

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// Grammars\\LeftRecursiveRuleWalker.g3:221:4: SEMPRED
				{
				DebugLocation(221, 4);
				Match(input,SEMPRED,Follow._SEMPRED_in_element1372); if (state.failed) return;

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// Grammars\\LeftRecursiveRuleWalker.g3:222:4: SYN_SEMPRED
				{
				DebugLocation(222, 4);
				Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1377); if (state.failed) return;

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// Grammars\\LeftRecursiveRuleWalker.g3:223:4: BACKTRACK_SEMPRED
				{
				DebugLocation(223, 4);
				Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1382); if (state.failed) return;

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// Grammars\\LeftRecursiveRuleWalker.g3:224:4: GATED_SEMPRED
				{
				DebugLocation(224, 4);
				Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1387); if (state.failed) return;

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// Grammars\\LeftRecursiveRuleWalker.g3:225:4: EPSILON
				{
				DebugLocation(225, 4);
				Match(input,EPSILON,Follow._EPSILON_in_element1392); if (state.failed) return;

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("element", 23);
			LeaveRule("element", 23);
			LeaveRule_element();
		}
		DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return;

	}
	// $ANTLR end "element"

	partial void EnterRule_ebnf();
	partial void LeaveRule_ebnf();
	// $ANTLR start "ebnf"
	// Grammars\\LeftRecursiveRuleWalker.g3:228:1: ebnf : ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
	[GrammarRule("ebnf")]
	private void ebnf()
	{
		EnterRule_ebnf();
		EnterRule("ebnf", 24);
		TraceIn("ebnf", 24);
		try { DebugEnterRule(GrammarFileName, "ebnf");
		DebugLocation(228, 4);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:228:5: ( block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
			int alt46=4;
			try { DebugEnterDecision(46, false);
			switch (input.LA(1))
			{
			case BLOCK:
				{
				alt46 = 1;
				}
				break;
			case OPTIONAL:
				{
				alt46 = 2;
				}
				break;
			case CLOSURE:
				{
				alt46 = 3;
				}
				break;
			case POSITIVE_CLOSURE:
				{
				alt46 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:228:9: block
				{
				DebugLocation(228, 9);
				PushFollow(Follow._block_in_ebnf1404);
				block();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:229:9: ^( OPTIONAL block )
				{
				DebugLocation(229, 9);
				DebugLocation(229, 12);
				Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1416); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(229, 21);
				PushFollow(Follow._block_in_ebnf1418);
				block();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:230:9: ^( CLOSURE block )
				{
				DebugLocation(230, 9);
				DebugLocation(230, 12);
				Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1433); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(230, 20);
				PushFollow(Follow._block_in_ebnf1435);
				block();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LeftRecursiveRuleWalker.g3:231:9: ^( POSITIVE_CLOSURE block )
				{
				DebugLocation(231, 9);
				DebugLocation(231, 12);
				Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1451); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(231, 29);
				PushFollow(Follow._block_in_ebnf1453);
				block();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ebnf", 24);
			LeaveRule("ebnf", 24);
			LeaveRule_ebnf();
		}
		DebugLocation(232, 4);
		} finally { DebugExitRule(GrammarFileName, "ebnf"); }
		return;

	}
	// $ANTLR end "ebnf"

	partial void EnterRule_tree_();
	partial void LeaveRule_tree_();
	// $ANTLR start "tree_"
	// Grammars\\LeftRecursiveRuleWalker.g3:234:1: tree_ : ^( TREE_BEGIN ( element )+ ) ;
	[GrammarRule("tree_")]
	private void tree_()
	{
		EnterRule_tree_();
		EnterRule("tree_", 25);
		TraceIn("tree_", 25);
		try { DebugEnterRule(GrammarFileName, "tree_");
		DebugLocation(234, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:235:2: ( ^( TREE_BEGIN ( element )+ ) )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:235:4: ^( TREE_BEGIN ( element )+ )
			{
			DebugLocation(235, 4);
			DebugLocation(235, 6);
			Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1471); if (state.failed) return;

			Match(input, TokenTypes.Down, null); if (state.failed) return;
			DebugLocation(235, 17);
			// Grammars\\LeftRecursiveRuleWalker.g3:235:17: ( element )+
			int cnt47=0;
			try { DebugEnterSubRule(47);
			while (true)
			{
				int alt47=2;
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==ACTION||(LA47_1>=ASSIGN && LA47_1<=BLOCK)||LA47_1==CHAR_LITERAL||LA47_1==CLOSURE||LA47_1==DOT||LA47_1==EPSILON||LA47_1==FORCED_ACTION||LA47_1==GATED_SEMPRED||LA47_1==NOT||LA47_1==OPTIONAL||(LA47_1>=PLUS_ASSIGN && LA47_1<=POSITIVE_CLOSURE)||LA47_1==RANGE||LA47_1==ROOT||LA47_1==RULE_REF||LA47_1==SEMPRED||(LA47_1>=STRING_LITERAL && LA47_1<=SYN_SEMPRED)||LA47_1==TOKEN_REF||LA47_1==TREE_BEGIN||LA47_1==WILDCARD))
				{
					alt47 = 1;
				}


				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// Grammars\\LeftRecursiveRuleWalker.g3:235:17: element
					{
					DebugLocation(235, 17);
					PushFollow(Follow._element_in_tree_1473);
					element();
					PopFollow();
					if (state.failed) return;

					}
					break;

				default:
					if (cnt47 >= 1)
						goto loop47;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee47 = new EarlyExitException( 47, input );
					DebugRecognitionException(eee47);
					throw eee47;
				}
				cnt47++;
			}
			loop47:
				;

			} finally { DebugExitSubRule(47); }


			Match(input, TokenTypes.Up, null); if (state.failed) return;


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tree_", 25);
			LeaveRule("tree_", 25);
			LeaveRule_tree_();
		}
		DebugLocation(236, 1);
		} finally { DebugExitRule(GrammarFileName, "tree_"); }
		return;

	}
	// $ANTLR end "tree_"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Grammars\\LeftRecursiveRuleWalker.g3:238:1: atom : ( ^( RULE_REF ( ARG_ACTION )? ) | ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL | WILDCARD | ^( DOT ID atom ) );
	[GrammarRule("atom")]
	private void atom()
	{
		EnterRule_atom();
		EnterRule("atom", 26);
		TraceIn("atom", 26);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(238, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:239:2: ( ^( RULE_REF ( ARG_ACTION )? ) | ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL | WILDCARD | ^( DOT ID atom ) )
			int alt50=6;
			try { DebugEnterDecision(50, false);
			switch (input.LA(1))
			{
			case RULE_REF:
				{
				alt50 = 1;
				}
				break;
			case TOKEN_REF:
				{
				alt50 = 2;
				}
				break;
			case CHAR_LITERAL:
				{
				alt50 = 3;
				}
				break;
			case STRING_LITERAL:
				{
				alt50 = 4;
				}
				break;
			case WILDCARD:
				{
				alt50 = 5;
				}
				break;
			case DOT:
				{
				alt50 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 50, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Grammars\\LeftRecursiveRuleWalker.g3:239:4: ^( RULE_REF ( ARG_ACTION )? )
				{
				DebugLocation(239, 4);
				DebugLocation(239, 6);
				Match(input,RULE_REF,Follow._RULE_REF_in_atom1487); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(239, 15);
					// Grammars\\LeftRecursiveRuleWalker.g3:239:15: ( ARG_ACTION )?
					int alt48=2;
					try { DebugEnterSubRule(48);
					try { DebugEnterDecision(48, false);
					int LA48_1 = input.LA(1);

					if ((LA48_1==ARG_ACTION))
					{
						alt48 = 1;
					}
					} finally { DebugExitDecision(48); }
					switch (alt48)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:239:15: ARG_ACTION
						{
						DebugLocation(239, 15);
						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1489); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(48); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Grammars\\LeftRecursiveRuleWalker.g3:240:4: ^( TOKEN_REF ( ARG_ACTION )? )
				{
				DebugLocation(240, 4);
				DebugLocation(240, 6);
				Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1497); if (state.failed) return;

				if (input.LA(1) == TokenTypes.Down)
				{
					Match(input, TokenTypes.Down, null); if (state.failed) return;
					DebugLocation(240, 16);
					// Grammars\\LeftRecursiveRuleWalker.g3:240:16: ( ARG_ACTION )?
					int alt49=2;
					try { DebugEnterSubRule(49);
					try { DebugEnterDecision(49, false);
					int LA49_1 = input.LA(1);

					if ((LA49_1==ARG_ACTION))
					{
						alt49 = 1;
					}
					} finally { DebugExitDecision(49); }
					switch (alt49)
					{
					case 1:
						DebugEnterAlt(1);
						// Grammars\\LeftRecursiveRuleWalker.g3:240:16: ARG_ACTION
						{
						DebugLocation(240, 16);
						Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1499); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(49); }


					Match(input, TokenTypes.Up, null); if (state.failed) return;
				}


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Grammars\\LeftRecursiveRuleWalker.g3:241:4: CHAR_LITERAL
				{
				DebugLocation(241, 4);
				Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1506); if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Grammars\\LeftRecursiveRuleWalker.g3:242:4: STRING_LITERAL
				{
				DebugLocation(242, 4);
				Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1511); if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Grammars\\LeftRecursiveRuleWalker.g3:243:4: WILDCARD
				{
				DebugLocation(243, 4);
				Match(input,WILDCARD,Follow._WILDCARD_in_atom1516); if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Grammars\\LeftRecursiveRuleWalker.g3:244:4: ^( DOT ID atom )
				{
				DebugLocation(244, 4);
				DebugLocation(244, 6);
				Match(input,DOT,Follow._DOT_in_atom1522); if (state.failed) return;

				Match(input, TokenTypes.Down, null); if (state.failed) return;
				DebugLocation(244, 10);
				Match(input,ID,Follow._ID_in_atom1524); if (state.failed) return;
				DebugLocation(244, 13);
				PushFollow(Follow._atom_in_atom1526);
				atom();
				PopFollow();
				if (state.failed) return;

				Match(input, TokenTypes.Up, null); if (state.failed) return;


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 26);
			LeaveRule("atom", 26);
			LeaveRule_atom();
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return;

	}
	// $ANTLR end "atom"

	partial void EnterRule_ast_suffix();
	partial void LeaveRule_ast_suffix();
	// $ANTLR start "ast_suffix"
	// Grammars\\LeftRecursiveRuleWalker.g3:247:1: ast_suffix : ( ROOT | BANG );
	[GrammarRule("ast_suffix")]
	private void ast_suffix()
	{
		EnterRule_ast_suffix();
		EnterRule("ast_suffix", 27);
		TraceIn("ast_suffix", 27);
		try { DebugEnterRule(GrammarFileName, "ast_suffix");
		DebugLocation(247, 1);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:248:2: ( ROOT | BANG )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:
			{
			DebugLocation(248, 2);
			if (input.LA(1)==BANG||input.LA(1)==ROOT)
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ast_suffix", 27);
			LeaveRule("ast_suffix", 27);
			LeaveRule_ast_suffix();
		}
		DebugLocation(250, 1);
		} finally { DebugExitRule(GrammarFileName, "ast_suffix"); }
		return;

	}
	// $ANTLR end "ast_suffix"

	partial void EnterRule_synpred1_LeftRecursiveRuleWalker_fragment();
	partial void LeaveRule_synpred1_LeftRecursiveRuleWalker_fragment();

	// $ANTLR start synpred1_LeftRecursiveRuleWalker
	private void synpred1_LeftRecursiveRuleWalker_fragment()
	{
		EnterRule_synpred1_LeftRecursiveRuleWalker_fragment();
		EnterRule("synpred1_LeftRecursiveRuleWalker_fragment", 28);
		TraceIn("synpred1_LeftRecursiveRuleWalker_fragment", 28);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:136:9: ( binaryMultipleOp )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:136:10: binaryMultipleOp
			{
			DebugLocation(136, 10);
			PushFollow(Follow._binaryMultipleOp_in_synpred1_LeftRecursiveRuleWalker486);
			binaryMultipleOp();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_LeftRecursiveRuleWalker_fragment", 28);
			LeaveRule("synpred1_LeftRecursiveRuleWalker_fragment", 28);
			LeaveRule_synpred1_LeftRecursiveRuleWalker_fragment();
		}
	}
	// $ANTLR end synpred1_LeftRecursiveRuleWalker

	partial void EnterRule_synpred2_LeftRecursiveRuleWalker_fragment();
	partial void LeaveRule_synpred2_LeftRecursiveRuleWalker_fragment();

	// $ANTLR start synpred2_LeftRecursiveRuleWalker
	private void synpred2_LeftRecursiveRuleWalker_fragment()
	{
		EnterRule_synpred2_LeftRecursiveRuleWalker_fragment();
		EnterRule("synpred2_LeftRecursiveRuleWalker_fragment", 29);
		TraceIn("synpred2_LeftRecursiveRuleWalker_fragment", 29);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:138:9: ( binary )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:138:10: binary
			{
			DebugLocation(138, 10);
			PushFollow(Follow._binary_in_synpred2_LeftRecursiveRuleWalker532);
			binary();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_LeftRecursiveRuleWalker_fragment", 29);
			LeaveRule("synpred2_LeftRecursiveRuleWalker_fragment", 29);
			LeaveRule_synpred2_LeftRecursiveRuleWalker_fragment();
		}
	}
	// $ANTLR end synpred2_LeftRecursiveRuleWalker

	partial void EnterRule_synpred3_LeftRecursiveRuleWalker_fragment();
	partial void LeaveRule_synpred3_LeftRecursiveRuleWalker_fragment();

	// $ANTLR start synpred3_LeftRecursiveRuleWalker
	private void synpred3_LeftRecursiveRuleWalker_fragment()
	{
		EnterRule_synpred3_LeftRecursiveRuleWalker_fragment();
		EnterRule("synpred3_LeftRecursiveRuleWalker_fragment", 30);
		TraceIn("synpred3_LeftRecursiveRuleWalker_fragment", 30);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:140:9: ( ternary )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:140:10: ternary
			{
			DebugLocation(140, 10);
			PushFollow(Follow._ternary_in_synpred3_LeftRecursiveRuleWalker595);
			ternary();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_LeftRecursiveRuleWalker_fragment", 30);
			LeaveRule("synpred3_LeftRecursiveRuleWalker_fragment", 30);
			LeaveRule_synpred3_LeftRecursiveRuleWalker_fragment();
		}
	}
	// $ANTLR end synpred3_LeftRecursiveRuleWalker

	partial void EnterRule_synpred4_LeftRecursiveRuleWalker_fragment();
	partial void LeaveRule_synpred4_LeftRecursiveRuleWalker_fragment();

	// $ANTLR start synpred4_LeftRecursiveRuleWalker
	private void synpred4_LeftRecursiveRuleWalker_fragment()
	{
		EnterRule_synpred4_LeftRecursiveRuleWalker_fragment();
		EnterRule("synpred4_LeftRecursiveRuleWalker_fragment", 31);
		TraceIn("synpred4_LeftRecursiveRuleWalker_fragment", 31);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:142:9: ( prefix )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:142:10: prefix
			{
			DebugLocation(142, 10);
			PushFollow(Follow._prefix_in_synpred4_LeftRecursiveRuleWalker650);
			prefix();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_LeftRecursiveRuleWalker_fragment", 31);
			LeaveRule("synpred4_LeftRecursiveRuleWalker_fragment", 31);
			LeaveRule_synpred4_LeftRecursiveRuleWalker_fragment();
		}
	}
	// $ANTLR end synpred4_LeftRecursiveRuleWalker

	partial void EnterRule_synpred5_LeftRecursiveRuleWalker_fragment();
	partial void LeaveRule_synpred5_LeftRecursiveRuleWalker_fragment();

	// $ANTLR start synpred5_LeftRecursiveRuleWalker
	private void synpred5_LeftRecursiveRuleWalker_fragment()
	{
		EnterRule_synpred5_LeftRecursiveRuleWalker_fragment();
		EnterRule("synpred5_LeftRecursiveRuleWalker_fragment", 32);
		TraceIn("synpred5_LeftRecursiveRuleWalker_fragment", 32);
		try
		{
			// Grammars\\LeftRecursiveRuleWalker.g3:144:9: ( suffix )
			DebugEnterAlt(1);
			// Grammars\\LeftRecursiveRuleWalker.g3:144:10: suffix
			{
			DebugLocation(144, 10);
			PushFollow(Follow._suffix_in_synpred5_LeftRecursiveRuleWalker706);
			suffix();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_LeftRecursiveRuleWalker_fragment", 32);
			LeaveRule("synpred5_LeftRecursiveRuleWalker_fragment", 32);
			LeaveRule_synpred5_LeftRecursiveRuleWalker_fragment();
		}
	}
	// $ANTLR end synpred5_LeftRecursiveRuleWalker
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _OPTIONS_in_optionsSpec59 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _option_in_optionsSpec61 = new BitSet(new ulong[]{0x2008UL});
		public static readonly BitSet _ASSIGN_in_option75 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_option77 = new BitSet(new ulong[]{0x880000040000UL,0x1000000UL});
		public static readonly BitSet _optionValue_in_option79 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement117 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OR_in_charSetElement123 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement125 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement127 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RANGE_in_charSetElement134 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement136 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _CHAR_LITERAL_in_charSetElement138 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RULE_in_rec_rule166 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_rec_rule170 = new BitSet(new ulong[]{0x10000000400UL,0x1CUL});
		public static readonly BitSet _modifier_in_rec_rule177 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ARG_in_rec_rule184 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rec_rule186 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RET_in_rec_rule194 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_rec_rule196 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _optionsSpec_in_rec_rule203 = new BitSet(new ulong[]{0x10200UL,0x20000UL});
		public static readonly BitSet _ruleScopeSpec_in_rec_rule209 = new BitSet(new ulong[]{0x10200UL});
		public static readonly BitSet _AMPERSAND_in_rec_rule217 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ruleBlock_in_rec_rule228 = new BitSet(new ulong[]{0x4400020000UL});
		public static readonly BitSet _exceptionGroup_in_rec_rule235 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _EOR_in_rec_rule241 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _SCOPE_in_ruleScopeSpec288 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_ruleScopeSpec290 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _ID_in_ruleScopeSpec293 = new BitSet(new ulong[]{0x80000000008UL});
		public static readonly BitSet _BLOCK_in_ruleBlock317 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _optionsSpec_in_ruleBlock322 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _outerAlternative_in_ruleBlock330 = new BitSet(new ulong[]{0x200000100UL,0x1000UL});
		public static readonly BitSet _rewrite_in_ruleBlock342 = new BitSet(new ulong[]{0x200000100UL});
		public static readonly BitSet _EOB_in_ruleBlock360 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BLOCK_in_block383 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _optionsSpec_in_block397 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ALT_in_block415 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_block417 = new BitSet(new ulong[]{0x828002892025E010UL,0x547092041UL});
		public static readonly BitSet _EOA_in_block420 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _rewrite_in_block423 = new BitSet(new ulong[]{0x200000100UL});
		public static readonly BitSet _EOB_in_block441 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _binaryMultipleOp_in_outerAlternative490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _binary_in_outerAlternative546 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ternary_in_outerAlternative608 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _prefix_in_outerAlternative664 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _suffix_in_outerAlternative720 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ALT_in_outerAlternative762 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_outerAlternative764 = new BitSet(new ulong[]{0x828002892025E010UL,0x547092041UL});
		public static readonly BitSet _EOA_in_outerAlternative767 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_binary816 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_binary820 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _recurseNoLabel_in_binary828 = new BitSet(new ulong[]{0x800000000004A000UL,0x41002000UL});
		public static readonly BitSet _token_in_binary832 = new BitSet(new ulong[]{0x8000000000002000UL,0x10000UL});
		public static readonly BitSet _recurse_in_binary834 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_binary836 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_binaryMultipleOp853 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_binaryMultipleOp857 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _recurseNoLabel_in_binaryMultipleOp865 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _BLOCK_in_binaryMultipleOp869 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ALT_in_binaryMultipleOp875 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _token_in_binaryMultipleOp879 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_binaryMultipleOp881 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _EOB_in_binaryMultipleOp890 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _recurse_in_binaryMultipleOp894 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_binaryMultipleOp896 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_ternary911 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_ternary915 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _recurseNoLabel_in_ternary923 = new BitSet(new ulong[]{0x800000000004A000UL,0x41002000UL});
		public static readonly BitSet _token_in_ternary927 = new BitSet(new ulong[]{0x8000000000002000UL,0x10000UL});
		public static readonly BitSet _recurse_in_ternary929 = new BitSet(new ulong[]{0x800000000004A000UL,0x41002000UL});
		public static readonly BitSet _token_in_ternary931 = new BitSet(new ulong[]{0x8000000000002000UL,0x10000UL});
		public static readonly BitSet _recurse_in_ternary933 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_ternary935 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_prefix951 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_prefix955 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_prefix968 = new BitSet(new ulong[]{0x828002882025E010UL,0x547092041UL});
		public static readonly BitSet _recurse_in_prefix972 = new BitSet(new ulong[]{0x100000000UL});
		public static readonly BitSet _EOA_in_prefix974 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ALT_in_suffix987 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_suffix991 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _recurseNoLabel_in_suffix999 = new BitSet(new ulong[]{0x828002882025E010UL,0x547092041UL});
		public static readonly BitSet _element_in_suffix1003 = new BitSet(new ulong[]{0x828002892025E010UL,0x547092041UL});
		public static readonly BitSet _EOA_in_suffix1007 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_recurse1020 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_recurse1022 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _recurseNoLabel_in_recurse1024 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PLUS_ASSIGN_in_recurse1031 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_recurse1033 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _recurseNoLabel_in_recurse1035 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _recurseNoLabel_in_recurse1041 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RULE_REF_in_recurseNoLabel1053 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_token1070 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_token1072 = new BitSet(new ulong[]{0x800000000004A000UL,0x41002000UL});
		public static readonly BitSet _token_in_token1076 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PLUS_ASSIGN_in_token1085 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_token1087 = new BitSet(new ulong[]{0x800000000004A000UL,0x41002000UL});
		public static readonly BitSet _token_in_token1091 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ROOT_in_token1100 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _token_in_token1104 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BANG_in_token1113 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _token_in_token1117 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_token1127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_token1141 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TOKEN_REF_in_token1153 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _exceptionHandler_in_exceptionGroup1174 = new BitSet(new ulong[]{0x4000020002UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup1177 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_exceptionGroup1183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_exceptionHandler1198 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_exceptionHandler1200 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ACTION_in_exceptionHandler1202 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FINALLY_in_finallyClause1215 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_finallyClause1217 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _REWRITES_in_rewrite1230 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _REWRITE_in_rewrite1236 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _SEMPRED_in_rewrite1238 = new BitSet(new ulong[]{0x2000000110UL,0x8000000UL});
		public static readonly BitSet _ALT_in_rewrite1243 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _TEMPLATE_in_rewrite1250 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ACTION_in_rewrite1256 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ETC_in_rewrite1258 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ROOT_in_element1278 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element1280 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _BANG_in_element1287 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element1289 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _atom_in_element1295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_element1301 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_element1303 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _RANGE_in_element1310 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _atom_in_element1312 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_element1314 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ASSIGN_in_element1321 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element1323 = new BitSet(new ulong[]{0x828002882025E010UL,0x547092041UL});
		public static readonly BitSet _element_in_element1325 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _PLUS_ASSIGN_in_element1332 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_element1334 = new BitSet(new ulong[]{0x828002882025E010UL,0x547092041UL});
		public static readonly BitSet _element_in_element1336 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _ebnf_in_element1342 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tree__in_element1347 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYNPRED_in_element1353 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_element1355 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _FORCED_ACTION_in_element1362 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_element1367 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMPRED_in_element1372 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SYN_SEMPRED_in_element1377 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BACKTRACK_SEMPRED_in_element1382 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GATED_SEMPRED_in_element1387 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EPSILON_in_element1392 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_ebnf1404 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPTIONAL_in_ebnf1416 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1418 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CLOSURE_in_ebnf1433 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1435 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _POSITIVE_CLOSURE_in_ebnf1451 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _block_in_ebnf1453 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TREE_BEGIN_in_tree_1471 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _element_in_tree_1473 = new BitSet(new ulong[]{0x828002882025E018UL,0x547092041UL});
		public static readonly BitSet _RULE_REF_in_atom1487 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1489 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _TOKEN_REF_in_atom1497 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ARG_ACTION_in_atom1499 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _CHAR_LITERAL_in_atom1506 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_in_atom1511 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WILDCARD_in_atom1516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_atom1522 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _ID_in_atom1524 = new BitSet(new ulong[]{0x20040000UL,0x441010000UL});
		public static readonly BitSet _atom_in_atom1526 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _binaryMultipleOp_in_synpred1_LeftRecursiveRuleWalker486 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _binary_in_synpred2_LeftRecursiveRuleWalker532 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ternary_in_synpred3_LeftRecursiveRuleWalker595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _prefix_in_synpred4_LeftRecursiveRuleWalker650 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _suffix_in_synpred5_LeftRecursiveRuleWalker706 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.Grammars
