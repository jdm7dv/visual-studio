//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Language\\Action.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Antlr3.ST.Language 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ActionParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "APPLY", "ARGS", "ASSIGN", "COLON", "COMMA", "CONDITIONAL", "DOT", "DOTDOTDOT", "ELSEIF", "ESC_CHAR", "FIRST", "FUNCTION", "ID", "INCLUDE", "INT", "LAST", "LBRACK", "LENGTH", "LIST", "LPAREN", "MULTI_APPLY", "NESTED_ANONYMOUS_TEMPLATE", "NEWLINE", "NOT", "NOTHING", "PLUS", "RBRACK", "REST", "RPAREN", "SEMI", "SINGLEVALUEARG", "STRING", "STRIP", "SUPER", "TEMPLATE", "TEMPLATE_ARGS", "TRUNC", "VALUE", "WS", "WS_CHAR"
	};
	public const int EOF=-1;
	public const int ANONYMOUS_TEMPLATE=4;
	public const int APPLY=5;
	public const int ARGS=6;
	public const int ASSIGN=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int CONDITIONAL=10;
	public const int DOT=11;
	public const int DOTDOTDOT=12;
	public const int ELSEIF=13;
	public const int ESC_CHAR=14;
	public const int FIRST=15;
	public const int FUNCTION=16;
	public const int ID=17;
	public const int INCLUDE=18;
	public const int INT=19;
	public const int LAST=20;
	public const int LBRACK=21;
	public const int LENGTH=22;
	public const int LIST=23;
	public const int LPAREN=24;
	public const int MULTI_APPLY=25;
	public const int NESTED_ANONYMOUS_TEMPLATE=26;
	public const int NEWLINE=27;
	public const int NOT=28;
	public const int NOTHING=29;
	public const int PLUS=30;
	public const int RBRACK=31;
	public const int REST=32;
	public const int RPAREN=33;
	public const int SEMI=34;
	public const int SINGLEVALUEARG=35;
	public const int STRING=36;
	public const int STRIP=37;
	public const int SUPER=38;
	public const int TEMPLATE=39;
	public const int TEMPLATE_ARGS=40;
	public const int TRUNC=41;
	public const int VALUE=42;
	public const int WS=43;
	public const int WS_CHAR=44;

	private ActionParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	private ActionParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		StringTemplateTreeAdaptor treeAdaptor = default(StringTemplateTreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor;
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref StringTemplateTreeAdaptor adaptor);

	private StringTemplateTreeAdaptor adaptor;

	public StringTemplateTreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return ActionParser.tokenNames; } }
	public override string GrammarFileName { get { return "Language\\Action.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	public sealed partial class action_return : AstParserRuleReturnScope<StringTemplateAST, IToken>
	{
		public IDictionary<string, object> opts;
		public action_return(ActionParser grammar) {OnCreated(grammar);}
		partial void OnCreated(ActionParser grammar);
	}

	partial void EnterRule_action();
	partial void LeaveRule_action();
	// $ANTLR start "action"
	// Language\\Action.g3:78:1: public action returns [IDictionary<string, object> opts] : ( templatesExpr ( SEMI ! optionList )? | 'if' ^ LPAREN ! ifCondition RPAREN !| 'elseif' ! LPAREN ! ifCondition RPAREN !) EOF !;
	[GrammarRule("action")]
	public ActionParser.action_return action()
	{
		EnterRule_action();
		EnterRule("action", 1);
		TraceIn("action", 1);
		ActionParser.action_return retval = new ActionParser.action_return(this);
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken SEMI2 = default(IToken);
		IToken string_literal4 = default(IToken);
		IToken LPAREN5 = default(IToken);
		IToken RPAREN7 = default(IToken);
		IToken string_literal8 = default(IToken);
		IToken LPAREN9 = default(IToken);
		IToken RPAREN11 = default(IToken);
		IToken EOF12 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> templatesExpr1 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> optionList3 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> ifCondition6 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> ifCondition10 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST SEMI2_tree = default(StringTemplateAST);
		StringTemplateAST string_literal4_tree = default(StringTemplateAST);
		StringTemplateAST LPAREN5_tree = default(StringTemplateAST);
		StringTemplateAST RPAREN7_tree = default(StringTemplateAST);
		StringTemplateAST string_literal8_tree = default(StringTemplateAST);
		StringTemplateAST LPAREN9_tree = default(StringTemplateAST);
		StringTemplateAST RPAREN11_tree = default(StringTemplateAST);
		StringTemplateAST EOF12_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "action");
		DebugLocation(78, 1);
		try
		{
			// Language\\Action.g3:79:2: ( ( templatesExpr ( SEMI ! optionList )? | 'if' ^ LPAREN ! ifCondition RPAREN !| 'elseif' ! LPAREN ! ifCondition RPAREN !) EOF !)
			DebugEnterAlt(1);
			// Language\\Action.g3:79:4: ( templatesExpr ( SEMI ! optionList )? | 'if' ^ LPAREN ! ifCondition RPAREN !| 'elseif' ! LPAREN ! ifCondition RPAREN !) EOF !
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(79, 4);
			// Language\\Action.g3:79:4: ( templatesExpr ( SEMI ! optionList )? | 'if' ^ LPAREN ! ifCondition RPAREN !| 'elseif' ! LPAREN ! ifCondition RPAREN !)
			int alt2=3;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case ANONYMOUS_TEMPLATE:
			case FIRST:
			case ID:
			case INT:
			case LAST:
			case LBRACK:
			case LENGTH:
			case LPAREN:
			case REST:
			case STRING:
			case STRIP:
			case SUPER:
			case TRUNC:
				{
				alt2 = 1;
				}
				break;
			case CONDITIONAL:
				{
				alt2 = 2;
				}
				break;
			case ELSEIF:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:79:6: templatesExpr ( SEMI ! optionList )?
				{
				DebugLocation(79, 6);
				PushFollow(Follow._templatesExpr_in_action189);
				templatesExpr1=templatesExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, templatesExpr1.Tree);
				DebugLocation(79, 20);
				// Language\\Action.g3:79:20: ( SEMI ! optionList )?
				int alt1=2;
				try { DebugEnterSubRule(1);
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==SEMI))
				{
					alt1 = 1;
				}
				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:79:21: SEMI ! optionList
					{
					DebugLocation(79, 25);
					SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_action192); if (state.failed) return retval;
					DebugLocation(79, 27);
					PushFollow(Follow._optionList_in_action195);
					optionList3=optionList();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, optionList3.Tree);
					DebugLocation(79, 38);
					if (state.backtracking == 0)
					{
						retval.opts = (optionList3!=null?((ActionParser.optionList_return)optionList3).opts:default(IDictionary<string, object>));
					}

					}
					break;

				}
				} finally { DebugExitSubRule(1); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:80:5: 'if' ^ LPAREN ! ifCondition RPAREN !
				{
				DebugLocation(80, 9);
				string_literal4=(IToken)Match(input,CONDITIONAL,Follow._CONDITIONAL_in_action205); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal4_tree = (StringTemplateAST)adaptor.Create(string_literal4);
				root_0 = (StringTemplateAST)adaptor.BecomeRoot(string_literal4_tree, root_0);
				}
				DebugLocation(80, 17);
				LPAREN5=(IToken)Match(input,LPAREN,Follow._LPAREN_in_action208); if (state.failed) return retval;
				DebugLocation(80, 19);
				PushFollow(Follow._ifCondition_in_action211);
				ifCondition6=ifCondition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifCondition6.Tree);
				DebugLocation(80, 37);
				RPAREN7=(IToken)Match(input,RPAREN,Follow._RPAREN_in_action213); if (state.failed) return retval;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:81:5: 'elseif' ! LPAREN ! ifCondition RPAREN !
				{
				DebugLocation(81, 13);
				string_literal8=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_action220); if (state.failed) return retval;
				DebugLocation(81, 21);
				LPAREN9=(IToken)Match(input,LPAREN,Follow._LPAREN_in_action223); if (state.failed) return retval;
				DebugLocation(81, 23);
				PushFollow(Follow._ifCondition_in_action226);
				ifCondition10=ifCondition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifCondition10.Tree);
				DebugLocation(81, 41);
				RPAREN11=(IToken)Match(input,RPAREN,Follow._RPAREN_in_action228); if (state.failed) return retval;

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(83, 6);
			EOF12=(IToken)Match(input,EOF,Follow._EOF_in_action238); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("action", 1);
			LeaveRule("action", 1);
			LeaveRule_action();
		}
		DebugLocation(84, 1);
		} finally { DebugExitRule(GrammarFileName, "action"); }
		return retval;

	}
	// $ANTLR end "action"

	private sealed partial class optionList_return : AstParserRuleReturnScope<StringTemplateAST, IToken>
	{
		public IDictionary<string, object> opts=new Dictionary<string, object>();
		public optionList_return(ActionParser grammar) {OnCreated(grammar);}
		partial void OnCreated(ActionParser grammar);
	}

	partial void EnterRule_optionList();
	partial void LeaveRule_optionList();
	// $ANTLR start "optionList"
	// Language\\Action.g3:86:1: optionList returns [IDictionary<string, object> opts=new Dictionary<string, object>()] : option[$opts] ( COMMA option[$opts] )* ;
	[GrammarRule("optionList")]
	private ActionParser.optionList_return optionList()
	{
		EnterRule_optionList();
		EnterRule("optionList", 2);
		TraceIn("optionList", 2);
		ActionParser.optionList_return retval = new ActionParser.optionList_return(this);
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken COMMA14 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> option13 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> option15 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST COMMA14_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "optionList");
		DebugLocation(86, 1);
		try
		{
			// Language\\Action.g3:87:2: ( option[$opts] ( COMMA option[$opts] )* )
			DebugEnterAlt(1);
			// Language\\Action.g3:87:4: option[$opts] ( COMMA option[$opts] )*
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(87, 4);
			PushFollow(Follow._option_in_optionList255);
			option13=option(retval.opts);
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, option13.Tree);
			DebugLocation(87, 18);
			// Language\\Action.g3:87:18: ( COMMA option[$opts] )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==COMMA))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:87:19: COMMA option[$opts]
					{
					DebugLocation(87, 19);
					COMMA14=(IToken)Match(input,COMMA,Follow._COMMA_in_optionList259); if (state.failed) return retval;
					if (state.backtracking == 0) {
					COMMA14_tree = (StringTemplateAST)adaptor.Create(COMMA14);
					adaptor.AddChild(root_0, COMMA14_tree);
					}
					DebugLocation(87, 25);
					PushFollow(Follow._option_in_optionList261);
					option15=option(retval.opts);
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, option15.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("optionList", 2);
			LeaveRule("optionList", 2);
			LeaveRule_optionList();
		}
		DebugLocation(88, 1);
		} finally { DebugExitRule(GrammarFileName, "optionList"); }
		return retval;

	}
	// $ANTLR end "optionList"

	partial void EnterRule_option();
	partial void LeaveRule_option();
	// $ANTLR start "option"
	// Language\\Action.g3:90:1: option[IDictionary<string, object> opts] : ID ( ASSIGN nonAlternatingTemplateExpr )? ;
	[GrammarRule("option")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> option(IDictionary<string, object> opts)
	{
		EnterRule_option();
		EnterRule("option", 3);
		TraceIn("option", 3);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken ID16 = default(IToken);
		IToken ASSIGN17 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> nonAlternatingTemplateExpr18 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST ID16_tree = default(StringTemplateAST);
		StringTemplateAST ASSIGN17_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "option");
		DebugLocation(90, 1);
		try
		{
			// Language\\Action.g3:91:2: ( ID ( ASSIGN nonAlternatingTemplateExpr )? )
			DebugEnterAlt(1);
			// Language\\Action.g3:91:4: ID ( ASSIGN nonAlternatingTemplateExpr )?
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(91, 4);
			ID16=(IToken)Match(input,ID,Follow._ID_in_option276); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ID16_tree = (StringTemplateAST)adaptor.Create(ID16);
			adaptor.AddChild(root_0, ID16_tree);
			}
			DebugLocation(91, 7);
			// Language\\Action.g3:91:7: ( ASSIGN nonAlternatingTemplateExpr )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1==ASSIGN))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:91:8: ASSIGN nonAlternatingTemplateExpr
				{
				DebugLocation(91, 8);
				ASSIGN17=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_option279); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN17_tree = (StringTemplateAST)adaptor.Create(ASSIGN17);
				adaptor.AddChild(root_0, ASSIGN17_tree);
				}
				DebugLocation(91, 15);
				PushFollow(Follow._nonAlternatingTemplateExpr_in_option281);
				nonAlternatingTemplateExpr18=nonAlternatingTemplateExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonAlternatingTemplateExpr18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(92, 3);
			if (state.backtracking == 0)
			{
				opts[(ID16!=null?ID16.Text:default(string))] = (object)(nonAlternatingTemplateExpr18!=null?((StringTemplateAST)nonAlternatingTemplateExpr18.Tree):default(StringTemplateAST)) ?? ASTExpr.EmptyOption;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("option", 3);
			LeaveRule("option", 3);
			LeaveRule_option();
		}
		DebugLocation(93, 1);
		} finally { DebugExitRule(GrammarFileName, "option"); }
		return retval;

	}
	// $ANTLR end "option"

	partial void EnterRule_templatesExpr();
	partial void LeaveRule_templatesExpr();
	// $ANTLR start "templatesExpr"
	// Language\\Action.g3:95:1: templatesExpr : expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) ;
	[GrammarRule("templatesExpr")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> templatesExpr()
	{
		EnterRule_templatesExpr();
		EnterRule("templatesExpr", 4);
		TraceIn("templatesExpr", 4);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken colon = default(IToken);
		IToken COMMA20 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> expr19 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> expr21 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> anonymousTemplate22 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> templateList23 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST colon_tree = default(StringTemplateAST);
		StringTemplateAST COMMA20_tree = default(StringTemplateAST);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_anonymousTemplate=new RewriteRuleSubtreeStream(adaptor,"rule anonymousTemplate");
		RewriteRuleSubtreeStream stream_templateList=new RewriteRuleSubtreeStream(adaptor,"rule templateList");
		try { DebugEnterRule(GrammarFileName, "templatesExpr");
		DebugLocation(95, 1);
		try
		{
			// Language\\Action.g3:96:2: ( expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* ) )
			DebugEnterAlt(1);
			// Language\\Action.g3:97:3: expr ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
			{
			DebugLocation(97, 3);
			PushFollow(Follow._expr_in_templatesExpr301);
			expr19=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr19.Tree);
			DebugLocation(98, 3);
			// Language\\Action.g3:98:3: ( ( COMMA expr )+ colon= COLON anonymousTemplate -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate ) | ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )* )
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1==COMMA))
			{
				alt7 = 1;
			}
			else if ((LA7_1==EOF||LA7_1==COLON||(LA7_1>=RPAREN && LA7_1<=SEMI)))
			{
				alt7 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:98:5: ( COMMA expr )+ colon= COLON anonymousTemplate
				{
				DebugLocation(98, 5);
				// Language\\Action.g3:98:5: ( COMMA expr )+
				int cnt5=0;
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1==COMMA))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Action.g3:98:6: COMMA expr
						{
						DebugLocation(98, 6);
						COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_templatesExpr308); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA20);

						DebugLocation(98, 12);
						PushFollow(Follow._expr_in_templatesExpr310);
						expr21=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr21.Tree);

						}
						break;

					default:
						if (cnt5 >= 1)
							goto loop5;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee5 = new EarlyExitException( 5, input );
						DebugRecognitionException(eee5);
						throw eee5;
					}
					cnt5++;
				}
				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(98, 24);
				colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr316); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(colon);

				DebugLocation(98, 31);
				PushFollow(Follow._anonymousTemplate_in_templatesExpr318);
				anonymousTemplate22=anonymousTemplate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_anonymousTemplate.Add(anonymousTemplate22.Tree);


				{
				// AST REWRITE
				// elements: expr, colon, anonymousTemplate
				// token labels: colon
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_colon=new RewriteRuleITokenStream(adaptor,"token colon",colon);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 99:4: -> ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate )
				{
					DebugLocation(99, 7);
					// Language\\Action.g3:99:7: ^( MULTI_APPLY[\"MULTI_APPLY\"] ( expr )+ $colon anonymousTemplate )
					{
					StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
					DebugLocation(99, 9);
					root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(MULTI_APPLY, "MULTI_APPLY"), root_1);

					DebugLocation(99, 36);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(99, 36);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();
					DebugLocation(99, 43);
					adaptor.AddChild(root_1, stream_colon.NextNode());
					DebugLocation(99, 49);
					adaptor.AddChild(root_1, stream_anonymousTemplate.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:100:5: ( -> expr ) (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )*
				{
				DebugLocation(100, 5);
				// Language\\Action.g3:100:5: ( -> expr )
				DebugEnterAlt(1);
				// Language\\Action.g3:100:7: 
				{

				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 100:7: -> expr
				{
					DebugLocation(100, 10);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}

				DebugLocation(102, 4);
				// Language\\Action.g3:102:4: (colon= COLON templateList -> ^( APPLY[$colon] $templatesExpr templateList ) )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=2;
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if ((LA6_1==COLON))
					{
						alt6 = 1;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Action.g3:102:6: colon= COLON templateList
						{
						DebugLocation(102, 11);
						colon=(IToken)Match(input,COLON,Follow._COLON_in_templatesExpr360); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COLON.Add(colon);

						DebugLocation(102, 18);
						PushFollow(Follow._templateList_in_templatesExpr362);
						templateList23=templateList();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_templateList.Add(templateList23.Tree);


						{
						// AST REWRITE
						// elements: templatesExpr, templateList
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (StringTemplateAST)adaptor.Nil();
						// 103:5: -> ^( APPLY[$colon] $templatesExpr templateList )
						{
							DebugLocation(103, 8);
							// Language\\Action.g3:103:8: ^( APPLY[$colon] $templatesExpr templateList )
							{
							StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
							DebugLocation(103, 10);
							root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(APPLY, colon), root_1);

							DebugLocation(103, 25);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(103, 39);
							adaptor.AddChild(root_1, stream_templateList.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }


				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("templatesExpr", 4);
			LeaveRule("templatesExpr", 4);
			LeaveRule_templatesExpr();
		}
		DebugLocation(106, 1);
		} finally { DebugExitRule(GrammarFileName, "templatesExpr"); }
		return retval;

	}
	// $ANTLR end "templatesExpr"

	partial void EnterRule_templateList();
	partial void LeaveRule_templateList();
	// $ANTLR start "templateList"
	// Language\\Action.g3:108:1: templateList : template ( COMMA ! template )* ;
	[GrammarRule("templateList")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> templateList()
	{
		EnterRule_templateList();
		EnterRule("templateList", 5);
		TraceIn("templateList", 5);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken COMMA25 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> template24 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> template26 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST COMMA25_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "templateList");
		DebugLocation(108, 1);
		try
		{
			// Language\\Action.g3:109:2: ( template ( COMMA ! template )* )
			DebugEnterAlt(1);
			// Language\\Action.g3:109:4: template ( COMMA ! template )*
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(109, 4);
			PushFollow(Follow._template_in_templateList401);
			template24=template();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, template24.Tree);
			DebugLocation(109, 13);
			// Language\\Action.g3:109:13: ( COMMA ! template )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==COMMA))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:109:14: COMMA ! template
					{
					DebugLocation(109, 19);
					COMMA25=(IToken)Match(input,COMMA,Follow._COMMA_in_templateList404); if (state.failed) return retval;
					DebugLocation(109, 21);
					PushFollow(Follow._template_in_templateList407);
					template26=template();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, template26.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("templateList", 5);
			LeaveRule("templateList", 5);
			LeaveRule_templateList();
		}
		DebugLocation(110, 1);
		} finally { DebugExitRule(GrammarFileName, "templateList"); }
		return retval;

	}
	// $ANTLR end "templateList"

	partial void EnterRule_ifCondition();
	partial void LeaveRule_ifCondition();
	// $ANTLR start "ifCondition"
	// Language\\Action.g3:112:1: ifCondition : ( ifAtom | NOT ^ ifAtom );
	[GrammarRule("ifCondition")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> ifCondition()
	{
		EnterRule_ifCondition();
		EnterRule("ifCondition", 6);
		TraceIn("ifCondition", 6);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken NOT28 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> ifAtom27 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> ifAtom29 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST NOT28_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "ifCondition");
		DebugLocation(112, 1);
		try
		{
			// Language\\Action.g3:113:2: ( ifAtom | NOT ^ ifAtom )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ANONYMOUS_TEMPLATE||LA9_1==FIRST||LA9_1==ID||(LA9_1>=INT && LA9_1<=LENGTH)||LA9_1==LPAREN||LA9_1==REST||(LA9_1>=STRING && LA9_1<=SUPER)||LA9_1==TRUNC))
			{
				alt9 = 1;
			}
			else if ((LA9_1==NOT))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:113:4: ifAtom
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(113, 4);
				PushFollow(Follow._ifAtom_in_ifCondition420);
				ifAtom27=ifAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifAtom27.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:114:4: NOT ^ ifAtom
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(114, 7);
				NOT28=(IToken)Match(input,NOT,Follow._NOT_in_ifCondition425); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NOT28_tree = (StringTemplateAST)adaptor.Create(NOT28);
				root_0 = (StringTemplateAST)adaptor.BecomeRoot(NOT28_tree, root_0);
				}
				DebugLocation(114, 9);
				PushFollow(Follow._ifAtom_in_ifCondition428);
				ifAtom29=ifAtom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifAtom29.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifCondition", 6);
			LeaveRule("ifCondition", 6);
			LeaveRule_ifCondition();
		}
		DebugLocation(115, 1);
		} finally { DebugExitRule(GrammarFileName, "ifCondition"); }
		return retval;

	}
	// $ANTLR end "ifCondition"

	partial void EnterRule_ifAtom();
	partial void LeaveRule_ifAtom();
	// $ANTLR start "ifAtom"
	// Language\\Action.g3:117:1: ifAtom : templatesExpr ;
	[GrammarRule("ifAtom")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> ifAtom()
	{
		EnterRule_ifAtom();
		EnterRule("ifAtom", 7);
		TraceIn("ifAtom", 7);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		AstParserRuleReturnScope<StringTemplateAST, IToken> templatesExpr30 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "ifAtom");
		DebugLocation(117, 1);
		try
		{
			// Language\\Action.g3:118:2: ( templatesExpr )
			DebugEnterAlt(1);
			// Language\\Action.g3:118:4: templatesExpr
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(118, 4);
			PushFollow(Follow._templatesExpr_in_ifAtom439);
			templatesExpr30=templatesExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, templatesExpr30.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifAtom", 7);
			LeaveRule("ifAtom", 7);
			LeaveRule_ifAtom();
		}
		DebugLocation(119, 1);
		} finally { DebugExitRule(GrammarFileName, "ifAtom"); }
		return retval;

	}
	// $ANTLR end "ifAtom"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// Language\\Action.g3:121:1: expr : primaryExpr ( PLUS ^ primaryExpr )* ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 8);
		TraceIn("expr", 8);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken PLUS32 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> primaryExpr31 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> primaryExpr33 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST PLUS32_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(121, 1);
		try
		{
			// Language\\Action.g3:122:2: ( primaryExpr ( PLUS ^ primaryExpr )* )
			DebugEnterAlt(1);
			// Language\\Action.g3:122:4: primaryExpr ( PLUS ^ primaryExpr )*
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(122, 4);
			PushFollow(Follow._primaryExpr_in_expr450);
			primaryExpr31=primaryExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpr31.Tree);
			DebugLocation(122, 16);
			// Language\\Action.g3:122:16: ( PLUS ^ primaryExpr )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1==PLUS))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:122:17: PLUS ^ primaryExpr
					{
					DebugLocation(122, 21);
					PLUS32=(IToken)Match(input,PLUS,Follow._PLUS_in_expr453); if (state.failed) return retval;
					if (state.backtracking == 0) {
					PLUS32_tree = (StringTemplateAST)adaptor.Create(PLUS32);
					root_0 = (StringTemplateAST)adaptor.BecomeRoot(PLUS32_tree, root_0);
					}
					DebugLocation(122, 23);
					PushFollow(Follow._primaryExpr_in_expr456);
					primaryExpr33=primaryExpr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, primaryExpr33.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 8);
			LeaveRule("expr", 8);
			LeaveRule_expr();
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_primaryExpr();
	partial void LeaveRule_primaryExpr();
	// $ANTLR start "primaryExpr"
	// Language\\Action.g3:125:1: primaryExpr : ( ( templateInclude )=> templateInclude | atom ( DOT ^ ( ID | valueExpr ) )* | function ( DOT ^ ( ID | valueExpr ) )* | valueExpr | list );
	[GrammarRule("primaryExpr")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> primaryExpr()
	{
		EnterRule_primaryExpr();
		EnterRule("primaryExpr", 9);
		TraceIn("primaryExpr", 9);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken DOT36 = default(IToken);
		IToken ID37 = default(IToken);
		IToken DOT40 = default(IToken);
		IToken ID41 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> templateInclude34 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> atom35 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> valueExpr38 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> function39 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> valueExpr42 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> valueExpr43 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> list44 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST DOT36_tree = default(StringTemplateAST);
		StringTemplateAST ID37_tree = default(StringTemplateAST);
		StringTemplateAST DOT40_tree = default(StringTemplateAST);
		StringTemplateAST ID41_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "primaryExpr");
		DebugLocation(125, 1);
		try
		{
			// Language\\Action.g3:126:2: ( ( templateInclude )=> templateInclude | atom ( DOT ^ ( ID | valueExpr ) )* | function ( DOT ^ ( ID | valueExpr ) )* | valueExpr | list )
			int alt15=5;
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if ((LA15_1==ID))
			{
				int LA15_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Action_fragment)))
				{
					alt15 = 1;
				}
				else if ((true))
				{
					alt15 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA15_1==SUPER) && (EvaluatePredicate(synpred1_Action_fragment)))
			{
				alt15 = 1;
			}
			else if ((LA15_1==LPAREN))
			{
				int LA15_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Action_fragment)))
				{
					alt15 = 1;
				}
				else if ((true))
				{
					alt15 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 15, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA15_1==ANONYMOUS_TEMPLATE||LA15_1==INT||LA15_1==STRING))
			{
				alt15 = 2;
			}
			else if ((LA15_1==FIRST||LA15_1==LAST||LA15_1==LENGTH||LA15_1==REST||LA15_1==STRIP||LA15_1==TRUNC))
			{
				alt15 = 3;
			}
			else if ((LA15_1==LBRACK))
			{
				alt15 = 5;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:126:4: ( templateInclude )=> templateInclude
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(126, 23);
				PushFollow(Follow._templateInclude_in_primaryExpr473);
				templateInclude34=templateInclude();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, templateInclude34.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:127:4: atom ( DOT ^ ( ID | valueExpr ) )*
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(127, 4);
				PushFollow(Follow._atom_in_primaryExpr480);
				atom35=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, atom35.Tree);
				DebugLocation(128, 3);
				// Language\\Action.g3:128:3: ( DOT ^ ( ID | valueExpr ) )*
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if ((LA12_1==DOT))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch ( alt12 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Action.g3:128:5: DOT ^ ( ID | valueExpr )
						{
						DebugLocation(128, 8);
						DOT36=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr486); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DOT36_tree = (StringTemplateAST)adaptor.Create(DOT36);
						root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT36_tree, root_0);
						}
						DebugLocation(129, 4);
						// Language\\Action.g3:129:4: ( ID | valueExpr )
						int alt11=2;
						try { DebugEnterSubRule(11);
						try { DebugEnterDecision(11, false);
						int LA11_1 = input.LA(1);

						if ((LA11_1==ID))
						{
							alt11 = 1;
						}
						else if ((LA11_1==LPAREN))
						{
							alt11 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(11); }
						switch (alt11)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Action.g3:129:6: ID
							{
							DebugLocation(129, 6);
							ID37=(IToken)Match(input,ID,Follow._ID_in_primaryExpr495); if (state.failed) return retval;
							if (state.backtracking == 0) {
							ID37_tree = (StringTemplateAST)adaptor.Create(ID37);
							adaptor.AddChild(root_0, ID37_tree);
							}

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Language\\Action.g3:130:6: valueExpr
							{
							DebugLocation(130, 6);
							PushFollow(Follow._valueExpr_in_primaryExpr502);
							valueExpr38=valueExpr();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) adaptor.AddChild(root_0, valueExpr38.Tree);

							}
							break;

						}
						} finally { DebugExitSubRule(11); }


						}
						break;

					default:
						goto loop12;
					}
				}

				loop12:
					;

				} finally { DebugExitSubRule(12); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:133:4: function ( DOT ^ ( ID | valueExpr ) )*
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(133, 4);
				PushFollow(Follow._function_in_primaryExpr517);
				function39=function();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, function39.Tree);
				DebugLocation(134, 3);
				// Language\\Action.g3:134:3: ( DOT ^ ( ID | valueExpr ) )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if ((LA14_1==DOT))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Action.g3:134:5: DOT ^ ( ID | valueExpr )
						{
						DebugLocation(134, 8);
						DOT40=(IToken)Match(input,DOT,Follow._DOT_in_primaryExpr523); if (state.failed) return retval;
						if (state.backtracking == 0) {
						DOT40_tree = (StringTemplateAST)adaptor.Create(DOT40);
						root_0 = (StringTemplateAST)adaptor.BecomeRoot(DOT40_tree, root_0);
						}
						DebugLocation(135, 4);
						// Language\\Action.g3:135:4: ( ID | valueExpr )
						int alt13=2;
						try { DebugEnterSubRule(13);
						try { DebugEnterDecision(13, false);
						int LA13_1 = input.LA(1);

						if ((LA13_1==ID))
						{
							alt13 = 1;
						}
						else if ((LA13_1==LPAREN))
						{
							alt13 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(13); }
						switch (alt13)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Action.g3:135:6: ID
							{
							DebugLocation(135, 6);
							ID41=(IToken)Match(input,ID,Follow._ID_in_primaryExpr531); if (state.failed) return retval;
							if (state.backtracking == 0) {
							ID41_tree = (StringTemplateAST)adaptor.Create(ID41);
							adaptor.AddChild(root_0, ID41_tree);
							}

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Language\\Action.g3:136:6: valueExpr
							{
							DebugLocation(136, 6);
							PushFollow(Follow._valueExpr_in_primaryExpr538);
							valueExpr42=valueExpr();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) adaptor.AddChild(root_0, valueExpr42.Tree);

							}
							break;

						}
						} finally { DebugExitSubRule(13); }


						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Action.g3:139:4: valueExpr
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(139, 4);
				PushFollow(Follow._valueExpr_in_primaryExpr553);
				valueExpr43=valueExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, valueExpr43.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Language\\Action.g3:140:4: list
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(140, 4);
				PushFollow(Follow._list_in_primaryExpr558);
				list44=list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, list44.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpr", 9);
			LeaveRule("primaryExpr", 9);
			LeaveRule_primaryExpr();
		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpr"); }
		return retval;

	}
	// $ANTLR end "primaryExpr"

	partial void EnterRule_valueExpr();
	partial void LeaveRule_valueExpr();
	// $ANTLR start "valueExpr"
	// Language\\Action.g3:143:1: valueExpr : LPAREN ^ templatesExpr RPAREN !;
	[GrammarRule("valueExpr")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> valueExpr()
	{
		EnterRule_valueExpr();
		EnterRule("valueExpr", 10);
		TraceIn("valueExpr", 10);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken LPAREN45 = default(IToken);
		IToken RPAREN47 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> templatesExpr46 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST LPAREN45_tree = default(StringTemplateAST);
		StringTemplateAST RPAREN47_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "valueExpr");
		DebugLocation(143, 1);
		try
		{
			// Language\\Action.g3:144:2: ( LPAREN ^ templatesExpr RPAREN !)
			DebugEnterAlt(1);
			// Language\\Action.g3:144:4: LPAREN ^ templatesExpr RPAREN !
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(144, 35);
			LPAREN45=(IToken)Match(input,LPAREN,Follow._LPAREN_in_valueExpr569); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN45_tree = (StringTemplateAST)adaptor.Create(VALUE,LPAREN45,"value");
			root_0 = (StringTemplateAST)adaptor.BecomeRoot(LPAREN45_tree, root_0);
			}
			DebugLocation(144, 37);
			PushFollow(Follow._templatesExpr_in_valueExpr581);
			templatesExpr46=templatesExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, templatesExpr46.Tree);
			DebugLocation(144, 57);
			RPAREN47=(IToken)Match(input,RPAREN,Follow._RPAREN_in_valueExpr583); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("valueExpr", 10);
			LeaveRule("valueExpr", 10);
			LeaveRule_valueExpr();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "valueExpr"); }
		return retval;

	}
	// $ANTLR end "valueExpr"

	partial void EnterRule_nonAlternatingTemplateExpr();
	partial void LeaveRule_nonAlternatingTemplateExpr();
	// $ANTLR start "nonAlternatingTemplateExpr"
	// Language\\Action.g3:147:1: nonAlternatingTemplateExpr : ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )* ;
	[GrammarRule("nonAlternatingTemplateExpr")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> nonAlternatingTemplateExpr()
	{
		EnterRule_nonAlternatingTemplateExpr();
		EnterRule("nonAlternatingTemplateExpr", 11);
		TraceIn("nonAlternatingTemplateExpr", 11);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken COLON49 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> expr48 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> template50 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST COLON49_tree = default(StringTemplateAST);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_template=new RewriteRuleSubtreeStream(adaptor,"rule template");
		try { DebugEnterRule(GrammarFileName, "nonAlternatingTemplateExpr");
		DebugLocation(147, 1);
		try
		{
			// Language\\Action.g3:148:2: ( ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )* )
			DebugEnterAlt(1);
			// Language\\Action.g3:148:4: ( expr -> expr ) ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )*
			{
			DebugLocation(148, 4);
			// Language\\Action.g3:148:4: ( expr -> expr )
			DebugEnterAlt(1);
			// Language\\Action.g3:148:5: expr
			{
			DebugLocation(148, 5);
			PushFollow(Follow._expr_in_nonAlternatingTemplateExpr596);
			expr48=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr48.Tree);


			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (StringTemplateAST)adaptor.Nil();
			// 148:10: -> expr
			{
				DebugLocation(148, 13);
				adaptor.AddChild(root_0, stream_expr.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(148, 19);
			// Language\\Action.g3:148:19: ( COLON template -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template ) )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==COLON))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:148:21: COLON template
					{
					DebugLocation(148, 21);
					COLON49=(IToken)Match(input,COLON,Follow._COLON_in_nonAlternatingTemplateExpr605); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COLON.Add(COLON49);

					DebugLocation(148, 27);
					PushFollow(Follow._template_in_nonAlternatingTemplateExpr607);
					template50=template();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_template.Add(template50.Tree);


					{
					// AST REWRITE
					// elements: nonAlternatingTemplateExpr, template
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (StringTemplateAST)adaptor.Nil();
					// 148:36: -> ^( APPLY[$COLON] $nonAlternatingTemplateExpr template )
					{
						DebugLocation(148, 39);
						// Language\\Action.g3:148:39: ^( APPLY[$COLON] $nonAlternatingTemplateExpr template )
						{
						StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
						DebugLocation(148, 41);
						root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(APPLY, COLON49), root_1);

						DebugLocation(148, 56);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(148, 83);
						adaptor.AddChild(root_1, stream_template.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonAlternatingTemplateExpr", 11);
			LeaveRule("nonAlternatingTemplateExpr", 11);
			LeaveRule_nonAlternatingTemplateExpr();
		}
		DebugLocation(149, 1);
		} finally { DebugExitRule(GrammarFileName, "nonAlternatingTemplateExpr"); }
		return retval;

	}
	// $ANTLR end "nonAlternatingTemplateExpr"

	partial void EnterRule_function();
	partial void LeaveRule_function();
	// $ANTLR start "function"
	// Language\\Action.g3:151:1: function : ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg ) ;
	[GrammarRule("function")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> function()
	{
		EnterRule_function();
		EnterRule("function", 12);
		TraceIn("function", 12);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken string_literal51 = default(IToken);
		IToken string_literal52 = default(IToken);
		IToken string_literal53 = default(IToken);
		IToken string_literal54 = default(IToken);
		IToken string_literal55 = default(IToken);
		IToken string_literal56 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> singleArg57 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST string_literal51_tree = default(StringTemplateAST);
		StringTemplateAST string_literal52_tree = default(StringTemplateAST);
		StringTemplateAST string_literal53_tree = default(StringTemplateAST);
		StringTemplateAST string_literal54_tree = default(StringTemplateAST);
		StringTemplateAST string_literal55_tree = default(StringTemplateAST);
		StringTemplateAST string_literal56_tree = default(StringTemplateAST);
		RewriteRuleITokenStream stream_FIRST=new RewriteRuleITokenStream(adaptor,"token FIRST");
		RewriteRuleITokenStream stream_REST=new RewriteRuleITokenStream(adaptor,"token REST");
		RewriteRuleITokenStream stream_LAST=new RewriteRuleITokenStream(adaptor,"token LAST");
		RewriteRuleITokenStream stream_LENGTH=new RewriteRuleITokenStream(adaptor,"token LENGTH");
		RewriteRuleITokenStream stream_STRIP=new RewriteRuleITokenStream(adaptor,"token STRIP");
		RewriteRuleITokenStream stream_TRUNC=new RewriteRuleITokenStream(adaptor,"token TRUNC");
		RewriteRuleSubtreeStream stream_singleArg=new RewriteRuleSubtreeStream(adaptor,"rule singleArg");
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(151, 1);
		try
		{
			// Language\\Action.g3:152:2: ( ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg ) )
			DebugEnterAlt(1);
			// Language\\Action.g3:152:4: ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' ) singleArg
			{
			DebugLocation(152, 4);
			// Language\\Action.g3:152:4: ( 'first' | 'rest' | 'last' | 'length' | 'strip' | 'trunc' )
			int alt17=6;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case FIRST:
				{
				alt17 = 1;
				}
				break;
			case REST:
				{
				alt17 = 2;
				}
				break;
			case LAST:
				{
				alt17 = 3;
				}
				break;
			case LENGTH:
				{
				alt17 = 4;
				}
				break;
			case STRIP:
				{
				alt17 = 5;
				}
				break;
			case TRUNC:
				{
				alt17 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:152:6: 'first'
				{
				DebugLocation(152, 6);
				string_literal51=(IToken)Match(input,FIRST,Follow._FIRST_in_function635); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FIRST.Add(string_literal51);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:153:5: 'rest'
				{
				DebugLocation(153, 5);
				string_literal52=(IToken)Match(input,REST,Follow._REST_in_function641); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_REST.Add(string_literal52);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:154:5: 'last'
				{
				DebugLocation(154, 5);
				string_literal53=(IToken)Match(input,LAST,Follow._LAST_in_function647); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LAST.Add(string_literal53);


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Action.g3:155:5: 'length'
				{
				DebugLocation(155, 5);
				string_literal54=(IToken)Match(input,LENGTH,Follow._LENGTH_in_function653); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LENGTH.Add(string_literal54);


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Language\\Action.g3:156:5: 'strip'
				{
				DebugLocation(156, 5);
				string_literal55=(IToken)Match(input,STRIP,Follow._STRIP_in_function659); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STRIP.Add(string_literal55);


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Language\\Action.g3:157:5: 'trunc'
				{
				DebugLocation(157, 5);
				string_literal56=(IToken)Match(input,TRUNC,Follow._TRUNC_in_function665); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TRUNC.Add(string_literal56);


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(159, 3);
			PushFollow(Follow._singleArg_in_function673);
			singleArg57=singleArg();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_singleArg.Add(singleArg57.Tree);


			{
			// AST REWRITE
			// elements: FIRST, REST, LAST, LENGTH, STRIP, TRUNC, singleArg
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (StringTemplateAST)adaptor.Nil();
			// 160:3: -> ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg )
			{
				DebugLocation(160, 6);
				// Language\\Action.g3:160:6: ^( FUNCTION ( 'first' )? ( 'rest' )? ( 'last' )? ( 'length' )? ( 'strip' )? ( 'trunc' )? singleArg )
				{
				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
				DebugLocation(160, 8);
				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(FUNCTION, "FUNCTION"), root_1);

				DebugLocation(160, 17);
				// Language\\Action.g3:160:17: ( 'first' )?
				if (stream_FIRST.HasNext)
				{
					DebugLocation(160, 17);
					adaptor.AddChild(root_1, stream_FIRST.NextNode());

				}
				stream_FIRST.Reset();
				DebugLocation(160, 26);
				// Language\\Action.g3:160:26: ( 'rest' )?
				if (stream_REST.HasNext)
				{
					DebugLocation(160, 26);
					adaptor.AddChild(root_1, stream_REST.NextNode());

				}
				stream_REST.Reset();
				DebugLocation(160, 34);
				// Language\\Action.g3:160:34: ( 'last' )?
				if (stream_LAST.HasNext)
				{
					DebugLocation(160, 34);
					adaptor.AddChild(root_1, stream_LAST.NextNode());

				}
				stream_LAST.Reset();
				DebugLocation(160, 42);
				// Language\\Action.g3:160:42: ( 'length' )?
				if (stream_LENGTH.HasNext)
				{
					DebugLocation(160, 42);
					adaptor.AddChild(root_1, stream_LENGTH.NextNode());

				}
				stream_LENGTH.Reset();
				DebugLocation(160, 52);
				// Language\\Action.g3:160:52: ( 'strip' )?
				if (stream_STRIP.HasNext)
				{
					DebugLocation(160, 52);
					adaptor.AddChild(root_1, stream_STRIP.NextNode());

				}
				stream_STRIP.Reset();
				DebugLocation(160, 61);
				// Language\\Action.g3:160:61: ( 'trunc' )?
				if (stream_TRUNC.HasNext)
				{
					DebugLocation(160, 61);
					adaptor.AddChild(root_1, stream_TRUNC.NextNode());

				}
				stream_TRUNC.Reset();
				DebugLocation(160, 70);
				adaptor.AddChild(root_1, stream_singleArg.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function", 12);
			LeaveRule("function", 12);
			LeaveRule_function();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return retval;

	}
	// $ANTLR end "function"

	partial void EnterRule_template();
	partial void LeaveRule_template();
	// $ANTLR start "template"
	// Language\\Action.g3:163:1: template : ( namedTemplate | anonymousTemplate ) -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? ) ;
	[GrammarRule("template")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> template()
	{
		EnterRule_template();
		EnterRule("template", 13);
		TraceIn("template", 13);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		AstParserRuleReturnScope<StringTemplateAST, IToken> namedTemplate58 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> anonymousTemplate59 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		RewriteRuleSubtreeStream stream_namedTemplate=new RewriteRuleSubtreeStream(adaptor,"rule namedTemplate");
		RewriteRuleSubtreeStream stream_anonymousTemplate=new RewriteRuleSubtreeStream(adaptor,"rule anonymousTemplate");
		try { DebugEnterRule(GrammarFileName, "template");
		DebugLocation(163, 1);
		try
		{
			// Language\\Action.g3:164:2: ( ( namedTemplate | anonymousTemplate ) -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? ) )
			DebugEnterAlt(1);
			// Language\\Action.g3:164:4: ( namedTemplate | anonymousTemplate )
			{
			DebugLocation(164, 4);
			// Language\\Action.g3:164:4: ( namedTemplate | anonymousTemplate )
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==ID||LA18_1==LPAREN||LA18_1==SUPER))
			{
				alt18 = 1;
			}
			else if ((LA18_1==ANONYMOUS_TEMPLATE))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:164:6: namedTemplate
				{
				DebugLocation(164, 6);
				PushFollow(Follow._namedTemplate_in_template714);
				namedTemplate58=namedTemplate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_namedTemplate.Add(namedTemplate58.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:165:5: anonymousTemplate
				{
				DebugLocation(165, 5);
				PushFollow(Follow._anonymousTemplate_in_template723);
				anonymousTemplate59=anonymousTemplate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_anonymousTemplate.Add(anonymousTemplate59.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: namedTemplate, anonymousTemplate
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (StringTemplateAST)adaptor.Nil();
			// 167:3: -> ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? )
			{
				DebugLocation(167, 6);
				// Language\\Action.g3:167:6: ^( TEMPLATE ( namedTemplate )? ( anonymousTemplate )? )
				{
				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
				DebugLocation(167, 8);
				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(TEMPLATE, "TEMPLATE"), root_1);

				DebugLocation(167, 17);
				// Language\\Action.g3:167:17: ( namedTemplate )?
				if (stream_namedTemplate.HasNext)
				{
					DebugLocation(167, 17);
					adaptor.AddChild(root_1, stream_namedTemplate.NextTree());

				}
				stream_namedTemplate.Reset();
				DebugLocation(167, 32);
				// Language\\Action.g3:167:32: ( anonymousTemplate )?
				if (stream_anonymousTemplate.HasNext)
				{
					DebugLocation(167, 32);
					adaptor.AddChild(root_1, stream_anonymousTemplate.NextTree());

				}
				stream_anonymousTemplate.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("template", 13);
			LeaveRule("template", 13);
			LeaveRule_template();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "template"); }
		return retval;

	}
	// $ANTLR end "template"

	partial void EnterRule_namedTemplate();
	partial void LeaveRule_namedTemplate();
	// $ANTLR start "namedTemplate"
	// Language\\Action.g3:170:1: namedTemplate : ( ID argList -> ID argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate );
	[GrammarRule("namedTemplate")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> namedTemplate()
	{
		EnterRule_namedTemplate();
		EnterRule("namedTemplate", 14);
		TraceIn("namedTemplate", 14);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken qid = default(IToken);
		IToken ID60 = default(IToken);
		IToken string_literal62 = default(IToken);
		IToken DOT63 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argList61 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argList64 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> indirectTemplate65 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST qid_tree = default(StringTemplateAST);
		StringTemplateAST ID60_tree = default(StringTemplateAST);
		StringTemplateAST string_literal62_tree = default(StringTemplateAST);
		StringTemplateAST DOT63_tree = default(StringTemplateAST);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_SUPER=new RewriteRuleITokenStream(adaptor,"token SUPER");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
		RewriteRuleSubtreeStream stream_indirectTemplate=new RewriteRuleSubtreeStream(adaptor,"rule indirectTemplate");
		try { DebugEnterRule(GrammarFileName, "namedTemplate");
		DebugLocation(170, 1);
		try
		{
			// Language\\Action.g3:171:2: ( ID argList -> ID argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
			int alt19=3;
			try { DebugEnterDecision(19, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt19 = 1;
				}
				break;
			case SUPER:
				{
				alt19 = 2;
				}
				break;
			case LPAREN:
				{
				alt19 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 19, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:171:4: ID argList
				{
				DebugLocation(171, 4);
				ID60=(IToken)Match(input,ID,Follow._ID_in_namedTemplate754); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID60);

				DebugLocation(171, 7);
				PushFollow(Follow._argList_in_namedTemplate756);
				argList61=argList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_argList.Add(argList61.Tree);


				{
				// AST REWRITE
				// elements: ID, argList
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 172:3: -> ID argList
				{
					DebugLocation(172, 6);
					adaptor.AddChild(root_0, stream_ID.NextNode());
					DebugLocation(172, 9);
					adaptor.AddChild(root_0, stream_argList.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:173:4: 'super' DOT qid= ID argList
				{
				DebugLocation(173, 4);
				string_literal62=(IToken)Match(input,SUPER,Follow._SUPER_in_namedTemplate769); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SUPER.Add(string_literal62);

				DebugLocation(173, 12);
				DOT63=(IToken)Match(input,DOT,Follow._DOT_in_namedTemplate771); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOT.Add(DOT63);

				DebugLocation(173, 19);
				qid=(IToken)Match(input,ID,Follow._ID_in_namedTemplate775); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(qid);

				DebugLocation(173, 23);
				PushFollow(Follow._argList_in_namedTemplate777);
				argList64=argList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_argList.Add(argList64.Tree);


				{
				// AST REWRITE
				// elements: ID, argList
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 174:3: -> ID[$qid,\"super.\"+$qid.text] argList
				{
					DebugLocation(174, 6);
					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ID, qid, "super."+(qid!=null?qid.Text:default(string))));
					DebugLocation(174, 34);
					adaptor.AddChild(root_0, stream_argList.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:175:4: indirectTemplate
				{
				DebugLocation(175, 4);
				PushFollow(Follow._indirectTemplate_in_namedTemplate791);
				indirectTemplate65=indirectTemplate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_indirectTemplate.Add(indirectTemplate65.Tree);


				{
				// AST REWRITE
				// elements: indirectTemplate
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 176:3: -> indirectTemplate
				{
					DebugLocation(176, 6);
					adaptor.AddChild(root_0, stream_indirectTemplate.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namedTemplate", 14);
			LeaveRule("namedTemplate", 14);
			LeaveRule_namedTemplate();
		}
		DebugLocation(177, 1);
		} finally { DebugExitRule(GrammarFileName, "namedTemplate"); }
		return retval;

	}
	// $ANTLR end "namedTemplate"

	partial void EnterRule_anonymousTemplate();
	partial void LeaveRule_anonymousTemplate();
	// $ANTLR start "anonymousTemplate"
	// Language\\Action.g3:179:1: anonymousTemplate : t= ANONYMOUS_TEMPLATE ;
	[GrammarRule("anonymousTemplate")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> anonymousTemplate()
	{
		EnterRule_anonymousTemplate();
		EnterRule("anonymousTemplate", 15);
		TraceIn("anonymousTemplate", 15);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken t = default(IToken);

		StringTemplateAST t_tree = default(StringTemplateAST);

			StringTemplate anonymous = null;

		try { DebugEnterRule(GrammarFileName, "anonymousTemplate");
		DebugLocation(179, 1);
		try
		{
			// Language\\Action.g3:188:2: (t= ANONYMOUS_TEMPLATE )
			DebugEnterAlt(1);
			// Language\\Action.g3:188:4: t= ANONYMOUS_TEMPLATE
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(188, 5);
			t=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_anonymousTemplate820); if (state.failed) return retval;
			if (state.backtracking == 0) {
			t_tree = (StringTemplateAST)adaptor.Create(t);
			adaptor.AddChild(root_0, t_tree);
			}
			DebugLocation(189, 3);
			if (state.backtracking == 0)
			{

							anonymous = new StringTemplate();
							anonymous.Group = self.Group;
							anonymous.EnclosingInstance = self;
							anonymous.Template = (t!=null?t.Text:default(string));
							if ( t is StringTemplateToken )
								anonymous.DefineFormalArguments(((StringTemplateToken)t).args);
							else
								anonymous.DefineFormalArguments(new string[0]);
						
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{

					retval.Tree.StringTemplate = anonymous;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("anonymousTemplate", 15);
			LeaveRule("anonymousTemplate", 15);
			LeaveRule_anonymousTemplate();
		}
		DebugLocation(199, 1);
		} finally { DebugExitRule(GrammarFileName, "anonymousTemplate"); }
		return retval;

	}
	// $ANTLR end "anonymousTemplate"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Language\\Action.g3:201:1: atom : ( ID | STRING | INT | ANONYMOUS_TEMPLATE );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 16);
		TraceIn("atom", 16);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken set66 = default(IToken);

		StringTemplateAST set66_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(201, 1);
		try
		{
			// Language\\Action.g3:202:2: ( ID | STRING | INT | ANONYMOUS_TEMPLATE )
			DebugEnterAlt(1);
			// Language\\Action.g3:
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(202, 2);

			set66=(IToken)input.LT(1);
			if (input.LA(1)==ANONYMOUS_TEMPLATE||input.LA(1)==ID||input.LA(1)==INT||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(set66));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 16);
			LeaveRule("atom", 16);
			LeaveRule_atom();
		}
		DebugLocation(206, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_list();
	partial void LeaveRule_list();
	// $ANTLR start "list"
	// Language\\Action.g3:208:1: list : LBRACK ^ listElement ( COMMA ! listElement )* RBRACK !;
	[GrammarRule("list")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> list()
	{
		EnterRule_list();
		EnterRule("list", 17);
		TraceIn("list", 17);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken LBRACK67 = default(IToken);
		IToken COMMA69 = default(IToken);
		IToken RBRACK71 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> listElement68 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> listElement70 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST LBRACK67_tree = default(StringTemplateAST);
		StringTemplateAST COMMA69_tree = default(StringTemplateAST);
		StringTemplateAST RBRACK71_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "list");
		DebugLocation(208, 1);
		try
		{
			// Language\\Action.g3:209:2: ( LBRACK ^ listElement ( COMMA ! listElement )* RBRACK !)
			DebugEnterAlt(1);
			// Language\\Action.g3:209:4: LBRACK ^ listElement ( COMMA ! listElement )* RBRACK !
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(209, 34);
			LBRACK67=(IToken)Match(input,LBRACK,Follow._LBRACK_in_list861); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LBRACK67_tree = (StringTemplateAST)adaptor.Create(LIST,LBRACK67,"value");
			root_0 = (StringTemplateAST)adaptor.BecomeRoot(LBRACK67_tree, root_0);
			}
			DebugLocation(210, 3);
			PushFollow(Follow._listElement_in_list875);
			listElement68=listElement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, listElement68.Tree);
			DebugLocation(210, 15);
			// Language\\Action.g3:210:15: ( COMMA ! listElement )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==COMMA))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:210:16: COMMA ! listElement
					{
					DebugLocation(210, 21);
					COMMA69=(IToken)Match(input,COMMA,Follow._COMMA_in_list878); if (state.failed) return retval;
					DebugLocation(210, 23);
					PushFollow(Follow._listElement_in_list881);
					listElement70=listElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, listElement70.Tree);

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(211, 9);
			RBRACK71=(IToken)Match(input,RBRACK,Follow._RBRACK_in_list887); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("list", 17);
			LeaveRule("list", 17);
			LeaveRule_list();
		}
		DebugLocation(212, 1);
		} finally { DebugExitRule(GrammarFileName, "list"); }
		return retval;

	}
	// $ANTLR end "list"

	partial void EnterRule_listElement();
	partial void LeaveRule_listElement();
	// $ANTLR start "listElement"
	// Language\\Action.g3:214:1: listElement : ( nonAlternatingTemplateExpr | -> NOTHING[\"NOTHING\"] );
	[GrammarRule("listElement")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> listElement()
	{
		EnterRule_listElement();
		EnterRule("listElement", 18);
		TraceIn("listElement", 18);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		AstParserRuleReturnScope<StringTemplateAST, IToken> nonAlternatingTemplateExpr72 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		try { DebugEnterRule(GrammarFileName, "listElement");
		DebugLocation(214, 1);
		try
		{
			// Language\\Action.g3:215:2: ( nonAlternatingTemplateExpr | -> NOTHING[\"NOTHING\"] )
			int alt21=2;
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1==ANONYMOUS_TEMPLATE||LA21_1==FIRST||LA21_1==ID||(LA21_1>=INT && LA21_1<=LENGTH)||LA21_1==LPAREN||LA21_1==REST||(LA21_1>=STRING && LA21_1<=SUPER)||LA21_1==TRUNC))
			{
				alt21 = 1;
			}
			else if ((LA21_1==COMMA||LA21_1==RBRACK))
			{
				alt21 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:215:4: nonAlternatingTemplateExpr
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(215, 4);
				PushFollow(Follow._nonAlternatingTemplateExpr_in_listElement899);
				nonAlternatingTemplateExpr72=nonAlternatingTemplateExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonAlternatingTemplateExpr72.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:217:3: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 217:3: -> NOTHING[\"NOTHING\"]
				{
					DebugLocation(217, 6);
					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(NOTHING, "NOTHING"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("listElement", 18);
			LeaveRule("listElement", 18);
			LeaveRule_listElement();
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "listElement"); }
		return retval;

	}
	// $ANTLR end "listElement"

	partial void EnterRule_templateInclude();
	partial void LeaveRule_templateInclude();
	// $ANTLR start "templateInclude"
	// Language\\Action.g3:220:1: templateInclude : (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate ) -> ^( INCLUDE[\"include\"] $templateInclude) ;
	[GrammarRule("templateInclude")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> templateInclude()
	{
		EnterRule_templateInclude();
		EnterRule("templateInclude", 19);
		TraceIn("templateInclude", 19);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken id = default(IToken);
		IToken qid = default(IToken);
		IToken string_literal74 = default(IToken);
		IToken DOT75 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argList73 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argList76 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> indirectTemplate77 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST id_tree = default(StringTemplateAST);
		StringTemplateAST qid_tree = default(StringTemplateAST);
		StringTemplateAST string_literal74_tree = default(StringTemplateAST);
		StringTemplateAST DOT75_tree = default(StringTemplateAST);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_SUPER=new RewriteRuleITokenStream(adaptor,"token SUPER");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_argList=new RewriteRuleSubtreeStream(adaptor,"rule argList");
		RewriteRuleSubtreeStream stream_indirectTemplate=new RewriteRuleSubtreeStream(adaptor,"rule indirectTemplate");
		try { DebugEnterRule(GrammarFileName, "templateInclude");
		DebugLocation(220, 1);
		try
		{
			// Language\\Action.g3:221:2: ( (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate ) -> ^( INCLUDE[\"include\"] $templateInclude) )
			DebugEnterAlt(1);
			// Language\\Action.g3:221:4: (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
			{
			DebugLocation(221, 4);
			// Language\\Action.g3:221:4: (id= ID argList -> $id argList | 'super' DOT qid= ID argList -> ID[$qid,\"super.\"+$qid.text] argList | indirectTemplate -> indirectTemplate )
			int alt22=3;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt22 = 1;
				}
				break;
			case SUPER:
				{
				alt22 = 2;
				}
				break;
			case LPAREN:
				{
				alt22 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:221:6: id= ID argList
				{
				DebugLocation(221, 8);
				id=(IToken)Match(input,ID,Follow._ID_in_templateInclude924); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(id);

				DebugLocation(221, 12);
				PushFollow(Follow._argList_in_templateInclude926);
				argList73=argList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_argList.Add(argList73.Tree);


				{
				// AST REWRITE
				// elements: id, argList
				// token labels: id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 221:20: -> $id argList
				{
					DebugLocation(221, 24);
					adaptor.AddChild(root_0, stream_id.NextNode());
					DebugLocation(221, 27);
					adaptor.AddChild(root_0, stream_argList.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:222:5: 'super' DOT qid= ID argList
				{
				DebugLocation(222, 5);
				string_literal74=(IToken)Match(input,SUPER,Follow._SUPER_in_templateInclude939); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SUPER.Add(string_literal74);

				DebugLocation(222, 13);
				DOT75=(IToken)Match(input,DOT,Follow._DOT_in_templateInclude941); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOT.Add(DOT75);

				DebugLocation(222, 20);
				qid=(IToken)Match(input,ID,Follow._ID_in_templateInclude945); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(qid);

				DebugLocation(222, 24);
				PushFollow(Follow._argList_in_templateInclude947);
				argList76=argList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_argList.Add(argList76.Tree);


				{
				// AST REWRITE
				// elements: ID, argList
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 222:32: -> ID[$qid,\"super.\"+$qid.text] argList
				{
					DebugLocation(222, 35);
					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ID, qid, "super."+(qid!=null?qid.Text:default(string))));
					DebugLocation(222, 63);
					adaptor.AddChild(root_0, stream_argList.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:223:5: indirectTemplate
				{
				DebugLocation(223, 5);
				PushFollow(Follow._indirectTemplate_in_templateInclude960);
				indirectTemplate77=indirectTemplate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_indirectTemplate.Add(indirectTemplate77.Tree);


				{
				// AST REWRITE
				// elements: indirectTemplate
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (StringTemplateAST)adaptor.Nil();
				// 223:22: -> indirectTemplate
				{
					DebugLocation(223, 25);
					adaptor.AddChild(root_0, stream_indirectTemplate.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: templateInclude
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (StringTemplateAST)adaptor.Nil();
			// 225:3: -> ^( INCLUDE[\"include\"] $templateInclude)
			{
				DebugLocation(225, 6);
				// Language\\Action.g3:225:6: ^( INCLUDE[\"include\"] $templateInclude)
				{
				StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
				DebugLocation(225, 8);
				root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(INCLUDE, "include"), root_1);

				DebugLocation(225, 28);
				adaptor.AddChild(root_1, stream_retval.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("templateInclude", 19);
			LeaveRule("templateInclude", 19);
			LeaveRule_templateInclude();
		}
		DebugLocation(226, 1);
		} finally { DebugExitRule(GrammarFileName, "templateInclude"); }
		return retval;

	}
	// $ANTLR end "templateInclude"

	partial void EnterRule_indirectTemplate();
	partial void LeaveRule_indirectTemplate();
	// $ANTLR start "indirectTemplate"
	// Language\\Action.g3:229:1: indirectTemplate : LPAREN ^ templatesExpr RPAREN ! argList ;
	[GrammarRule("indirectTemplate")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> indirectTemplate()
	{
		EnterRule_indirectTemplate();
		EnterRule("indirectTemplate", 20);
		TraceIn("indirectTemplate", 20);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken LPAREN78 = default(IToken);
		IToken RPAREN80 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> templatesExpr79 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argList81 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST LPAREN78_tree = default(StringTemplateAST);
		StringTemplateAST RPAREN80_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "indirectTemplate");
		DebugLocation(229, 1);
		try
		{
			// Language\\Action.g3:230:2: ( LPAREN ^ templatesExpr RPAREN ! argList )
			DebugEnterAlt(1);
			// Language\\Action.g3:230:4: LPAREN ^ templatesExpr RPAREN ! argList
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(230, 35);
			LPAREN78=(IToken)Match(input,LPAREN,Follow._LPAREN_in_indirectTemplate993); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN78_tree = (StringTemplateAST)adaptor.Create(VALUE,LPAREN78,"value");
			root_0 = (StringTemplateAST)adaptor.BecomeRoot(LPAREN78_tree, root_0);
			}
			DebugLocation(230, 37);
			PushFollow(Follow._templatesExpr_in_indirectTemplate1005);
			templatesExpr79=templatesExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, templatesExpr79.Tree);
			DebugLocation(230, 57);
			RPAREN80=(IToken)Match(input,RPAREN,Follow._RPAREN_in_indirectTemplate1007); if (state.failed) return retval;
			DebugLocation(230, 59);
			PushFollow(Follow._argList_in_indirectTemplate1010);
			argList81=argList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, argList81.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indirectTemplate", 20);
			LeaveRule("indirectTemplate", 20);
			LeaveRule_indirectTemplate();
		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "indirectTemplate"); }
		return retval;

	}
	// $ANTLR end "indirectTemplate"

	partial void EnterRule_argList();
	partial void LeaveRule_argList();
	// $ANTLR start "argList"
	// Language\\Action.g3:233:1: argList : ( LPAREN ^ ( argumentAssignment ( COMMA ! argumentAssignment )* )? RPAREN !| singleArg );
	[GrammarRule("argList")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> argList()
	{
		EnterRule_argList();
		EnterRule("argList", 21);
		TraceIn("argList", 21);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken LPAREN82 = default(IToken);
		IToken COMMA84 = default(IToken);
		IToken RPAREN86 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argumentAssignment83 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> argumentAssignment85 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);
		AstParserRuleReturnScope<StringTemplateAST, IToken> singleArg87 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST LPAREN82_tree = default(StringTemplateAST);
		StringTemplateAST COMMA84_tree = default(StringTemplateAST);
		StringTemplateAST RPAREN86_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "argList");
		DebugLocation(233, 1);
		try
		{
			// Language\\Action.g3:234:2: ( LPAREN ^ ( argumentAssignment ( COMMA ! argumentAssignment )* )? RPAREN !| singleArg )
			int alt25=2;
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==LPAREN))
			{
				switch (input.LA(2))
				{
				case ID:
					{
					int LA25_3 = input.LA(3);

					if ((LA25_3==ASSIGN))
					{
						alt25 = 1;
					}
					else if ((LA25_3==COLON||LA25_3==DOT||LA25_3==LPAREN||LA25_3==PLUS||LA25_3==RPAREN))
					{
						alt25 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 2, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case DOTDOTDOT:
				case RPAREN:
					{
					alt25 = 1;
					}
					break;
				case ANONYMOUS_TEMPLATE:
				case FIRST:
				case INT:
				case LAST:
				case LBRACK:
				case LENGTH:
				case LPAREN:
				case REST:
				case STRING:
				case STRIP:
				case SUPER:
				case TRUNC:
					{
					alt25 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 25, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:234:4: LPAREN ^ ( argumentAssignment ( COMMA ! argumentAssignment )* )? RPAREN !
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(234, 33);
				LPAREN82=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1021); if (state.failed) return retval;
				if (state.backtracking == 0) {
				LPAREN82_tree = (StringTemplateAST)adaptor.Create(ARGS,LPAREN82,"ARGS");
				root_0 = (StringTemplateAST)adaptor.BecomeRoot(LPAREN82_tree, root_0);
				}
				DebugLocation(235, 3);
				// Language\\Action.g3:235:3: ( argumentAssignment ( COMMA ! argumentAssignment )* )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==DOTDOTDOT||LA24_1==ID))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:235:5: argumentAssignment ( COMMA ! argumentAssignment )*
					{
					DebugLocation(235, 5);
					PushFollow(Follow._argumentAssignment_in_argList1037);
					argumentAssignment83=argumentAssignment();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, argumentAssignment83.Tree);
					DebugLocation(235, 24);
					// Language\\Action.g3:235:24: ( COMMA ! argumentAssignment )*
					try { DebugEnterSubRule(23);
					while (true)
					{
						int alt23=2;
						try { DebugEnterDecision(23, false);
						int LA23_1 = input.LA(1);

						if ((LA23_1==COMMA))
						{
							alt23 = 1;
						}


						} finally { DebugExitDecision(23); }
						switch ( alt23 )
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Action.g3:235:25: COMMA ! argumentAssignment
							{
							DebugLocation(235, 30);
							COMMA84=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1040); if (state.failed) return retval;
							DebugLocation(235, 32);
							PushFollow(Follow._argumentAssignment_in_argList1043);
							argumentAssignment85=argumentAssignment();
							PopFollow();
							if (state.failed) return retval;
							if (state.backtracking == 0) adaptor.AddChild(root_0, argumentAssignment85.Tree);

							}
							break;

						default:
							goto loop23;
						}
					}

					loop23:
						;

					} finally { DebugExitSubRule(23); }


					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(237, 9);
				RPAREN86=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1054); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:238:4: singleArg
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(238, 4);
				PushFollow(Follow._singleArg_in_argList1060);
				singleArg87=singleArg();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, singleArg87.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argList", 21);
			LeaveRule("argList", 21);
			LeaveRule_argList();
		}
		DebugLocation(239, 1);
		} finally { DebugExitRule(GrammarFileName, "argList"); }
		return retval;

	}
	// $ANTLR end "argList"

	partial void EnterRule_singleArg();
	partial void LeaveRule_singleArg();
	// $ANTLR start "singleArg"
	// Language\\Action.g3:241:1: singleArg : LPAREN ^ nonAlternatingTemplateExpr RPAREN !;
	[GrammarRule("singleArg")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> singleArg()
	{
		EnterRule_singleArg();
		EnterRule("singleArg", 22);
		TraceIn("singleArg", 22);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken LPAREN88 = default(IToken);
		IToken RPAREN90 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> nonAlternatingTemplateExpr89 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST LPAREN88_tree = default(StringTemplateAST);
		StringTemplateAST RPAREN90_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "singleArg");
		DebugLocation(241, 1);
		try
		{
			// Language\\Action.g3:242:2: ( LPAREN ^ nonAlternatingTemplateExpr RPAREN !)
			DebugEnterAlt(1);
			// Language\\Action.g3:242:4: LPAREN ^ nonAlternatingTemplateExpr RPAREN !
			{
			root_0 = (StringTemplateAST)adaptor.Nil();

			DebugLocation(242, 53);
			LPAREN88=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1072); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN88_tree = (StringTemplateAST)adaptor.Create(SINGLEVALUEARG,LPAREN88,"SINGLEVALUEARG");
			root_0 = (StringTemplateAST)adaptor.BecomeRoot(LPAREN88_tree, root_0);
			}
			DebugLocation(242, 55);
			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1084);
			nonAlternatingTemplateExpr89=nonAlternatingTemplateExpr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, nonAlternatingTemplateExpr89.Tree);
			DebugLocation(242, 88);
			RPAREN90=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1086); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("singleArg", 22);
			LeaveRule("singleArg", 22);
			LeaveRule_singleArg();
		}
		DebugLocation(243, 1);
		} finally { DebugExitRule(GrammarFileName, "singleArg"); }
		return retval;

	}
	// $ANTLR end "singleArg"

	partial void EnterRule_argumentAssignment();
	partial void LeaveRule_argumentAssignment();
	// $ANTLR start "argumentAssignment"
	// Language\\Action.g3:245:1: argumentAssignment : ( ID ASSIGN ^ nonAlternatingTemplateExpr | DOTDOTDOT );
	[GrammarRule("argumentAssignment")]
	private AstParserRuleReturnScope<StringTemplateAST, IToken> argumentAssignment()
	{
		EnterRule_argumentAssignment();
		EnterRule("argumentAssignment", 23);
		TraceIn("argumentAssignment", 23);
		AstParserRuleReturnScope<StringTemplateAST, IToken> retval = new AstParserRuleReturnScope<StringTemplateAST, IToken>();
		retval.Start = (IToken)input.LT(1);

		StringTemplateAST root_0 = default(StringTemplateAST);

		IToken ID91 = default(IToken);
		IToken ASSIGN92 = default(IToken);
		IToken DOTDOTDOT94 = default(IToken);
		AstParserRuleReturnScope<StringTemplateAST, IToken> nonAlternatingTemplateExpr93 = default(AstParserRuleReturnScope<StringTemplateAST, IToken>);

		StringTemplateAST ID91_tree = default(StringTemplateAST);
		StringTemplateAST ASSIGN92_tree = default(StringTemplateAST);
		StringTemplateAST DOTDOTDOT94_tree = default(StringTemplateAST);
		try { DebugEnterRule(GrammarFileName, "argumentAssignment");
		DebugLocation(245, 1);
		try
		{
			// Language\\Action.g3:246:2: ( ID ASSIGN ^ nonAlternatingTemplateExpr | DOTDOTDOT )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1==ID))
			{
				alt26 = 1;
			}
			else if ((LA26_1==DOTDOTDOT))
			{
				alt26 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:246:4: ID ASSIGN ^ nonAlternatingTemplateExpr
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(246, 4);
				ID91=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1098); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ID91_tree = (StringTemplateAST)adaptor.Create(ID91);
				adaptor.AddChild(root_0, ID91_tree);
				}
				DebugLocation(246, 13);
				ASSIGN92=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1100); if (state.failed) return retval;
				if (state.backtracking == 0) {
				ASSIGN92_tree = (StringTemplateAST)adaptor.Create(ASSIGN92);
				root_0 = (StringTemplateAST)adaptor.BecomeRoot(ASSIGN92_tree, root_0);
				}
				DebugLocation(246, 15);
				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1103);
				nonAlternatingTemplateExpr93=nonAlternatingTemplateExpr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonAlternatingTemplateExpr93.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:247:4: DOTDOTDOT
				{
				root_0 = (StringTemplateAST)adaptor.Nil();

				DebugLocation(247, 4);
				DOTDOTDOT94=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1108); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DOTDOTDOT94_tree = (StringTemplateAST)adaptor.Create(DOTDOTDOT94);
				adaptor.AddChild(root_0, DOTDOTDOT94_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (StringTemplateAST)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (StringTemplateAST)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argumentAssignment", 23);
			LeaveRule("argumentAssignment", 23);
			LeaveRule_argumentAssignment();
		}
		DebugLocation(248, 1);
		} finally { DebugExitRule(GrammarFileName, "argumentAssignment"); }
		return retval;

	}
	// $ANTLR end "argumentAssignment"

	partial void EnterRule_synpred1_Action_fragment();
	partial void LeaveRule_synpred1_Action_fragment();

	// $ANTLR start synpred1_Action
	private void synpred1_Action_fragment()
	{
		EnterRule_synpred1_Action_fragment();
		EnterRule("synpred1_Action_fragment", 24);
		TraceIn("synpred1_Action_fragment", 24);
		try
		{
			// Language\\Action.g3:126:4: ( templateInclude )
			DebugEnterAlt(1);
			// Language\\Action.g3:126:5: templateInclude
			{
			DebugLocation(126, 5);
			PushFollow(Follow._templateInclude_in_synpred1_Action470);
			templateInclude();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Action_fragment", 24);
			LeaveRule("synpred1_Action_fragment", 24);
			LeaveRule_synpred1_Action_fragment();
		}
	}
	// $ANTLR end synpred1_Action
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _templatesExpr_in_action189 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _SEMI_in_action192 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _optionList_in_action195 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _CONDITIONAL_in_action205 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _LPAREN_in_action208 = new BitSet(new ulong[]{0x271117A8010UL});
		public static readonly BitSet _ifCondition_in_action211 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RPAREN_in_action213 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _ELSEIF_in_action220 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _LPAREN_in_action223 = new BitSet(new ulong[]{0x271117A8010UL});
		public static readonly BitSet _ifCondition_in_action226 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RPAREN_in_action228 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_action238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _option_in_optionList255 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_optionList259 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _option_in_optionList261 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ID_in_option276 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _ASSIGN_in_option279 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _nonAlternatingTemplateExpr_in_option281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_templatesExpr301 = new BitSet(new ulong[]{0x302UL});
		public static readonly BitSet _COMMA_in_templatesExpr308 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _expr_in_templatesExpr310 = new BitSet(new ulong[]{0x300UL});
		public static readonly BitSet _COLON_in_templatesExpr316 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _anonymousTemplate_in_templatesExpr318 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_templatesExpr360 = new BitSet(new ulong[]{0x4001020010UL});
		public static readonly BitSet _templateList_in_templatesExpr362 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _template_in_templateList401 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_templateList404 = new BitSet(new ulong[]{0x4001020010UL});
		public static readonly BitSet _template_in_templateList407 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ifAtom_in_ifCondition420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_ifCondition425 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _ifAtom_in_ifCondition428 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _templatesExpr_in_ifAtom439 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpr_in_expr450 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _PLUS_in_expr453 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _primaryExpr_in_expr456 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _templateInclude_in_primaryExpr473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_primaryExpr480 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _DOT_in_primaryExpr486 = new BitSet(new ulong[]{0x1020000UL});
		public static readonly BitSet _ID_in_primaryExpr495 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _valueExpr_in_primaryExpr502 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _function_in_primaryExpr517 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _DOT_in_primaryExpr523 = new BitSet(new ulong[]{0x1020000UL});
		public static readonly BitSet _ID_in_primaryExpr531 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _valueExpr_in_primaryExpr538 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _valueExpr_in_primaryExpr553 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _list_in_primaryExpr558 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_valueExpr569 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _templatesExpr_in_valueExpr581 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RPAREN_in_valueExpr583 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_nonAlternatingTemplateExpr596 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _COLON_in_nonAlternatingTemplateExpr605 = new BitSet(new ulong[]{0x4001020010UL});
		public static readonly BitSet _template_in_nonAlternatingTemplateExpr607 = new BitSet(new ulong[]{0x102UL});
		public static readonly BitSet _FIRST_in_function635 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _REST_in_function641 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _LAST_in_function647 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _LENGTH_in_function653 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _STRIP_in_function659 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _TRUNC_in_function665 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _singleArg_in_function673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namedTemplate_in_template714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _anonymousTemplate_in_template723 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_namedTemplate754 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _argList_in_namedTemplate756 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUPER_in_namedTemplate769 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DOT_in_namedTemplate771 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_namedTemplate775 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _argList_in_namedTemplate777 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indirectTemplate_in_namedTemplate791 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_anonymousTemplate820 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_list861 = new BitSet(new ulong[]{0x271817A8210UL});
		public static readonly BitSet _listElement_in_list875 = new BitSet(new ulong[]{0x80000200UL});
		public static readonly BitSet _COMMA_in_list878 = new BitSet(new ulong[]{0x271817A8210UL});
		public static readonly BitSet _listElement_in_list881 = new BitSet(new ulong[]{0x80000200UL});
		public static readonly BitSet _RBRACK_in_list887 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonAlternatingTemplateExpr_in_listElement899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_templateInclude924 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _argList_in_templateInclude926 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUPER_in_templateInclude939 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DOT_in_templateInclude941 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_templateInclude945 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _argList_in_templateInclude947 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indirectTemplate_in_templateInclude960 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_indirectTemplate993 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _templatesExpr_in_indirectTemplate1005 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RPAREN_in_indirectTemplate1007 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _argList_in_indirectTemplate1010 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_argList1021 = new BitSet(new ulong[]{0x200021000UL});
		public static readonly BitSet _argumentAssignment_in_argList1037 = new BitSet(new ulong[]{0x200000200UL});
		public static readonly BitSet _COMMA_in_argList1040 = new BitSet(new ulong[]{0x21000UL});
		public static readonly BitSet _argumentAssignment_in_argList1043 = new BitSet(new ulong[]{0x200000200UL});
		public static readonly BitSet _RPAREN_in_argList1054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _singleArg_in_argList1060 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_singleArg1072 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1084 = new BitSet(new ulong[]{0x200000000UL});
		public static readonly BitSet _RPAREN_in_singleArg1086 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_argumentAssignment1098 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _ASSIGN_in_argumentAssignment1100 = new BitSet(new ulong[]{0x271017A8010UL});
		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1103 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _templateInclude_in_synpred1_Action470 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Antlr3.ST.Language 
