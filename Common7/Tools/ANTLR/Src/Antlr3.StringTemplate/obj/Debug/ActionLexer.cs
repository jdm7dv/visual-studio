//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Language\\Action.g3 2013-06-14 09:39:35

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Antlr3.ST.Language 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class ActionLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ANONYMOUS_TEMPLATE=4;
	public const int APPLY=5;
	public const int ARGS=6;
	public const int ASSIGN=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int CONDITIONAL=10;
	public const int DOT=11;
	public const int DOTDOTDOT=12;
	public const int ELSEIF=13;
	public const int ESC_CHAR=14;
	public const int FIRST=15;
	public const int FUNCTION=16;
	public const int ID=17;
	public const int INCLUDE=18;
	public const int INT=19;
	public const int LAST=20;
	public const int LBRACK=21;
	public const int LENGTH=22;
	public const int LIST=23;
	public const int LPAREN=24;
	public const int MULTI_APPLY=25;
	public const int NESTED_ANONYMOUS_TEMPLATE=26;
	public const int NEWLINE=27;
	public const int NOT=28;
	public const int NOTHING=29;
	public const int PLUS=30;
	public const int RBRACK=31;
	public const int REST=32;
	public const int RPAREN=33;
	public const int SEMI=34;
	public const int SINGLEVALUEARG=35;
	public const int STRING=36;
	public const int STRIP=37;
	public const int SUPER=38;
	public const int TEMPLATE=39;
	public const int TEMPLATE_ARGS=40;
	public const int TRUNC=41;
	public const int VALUE=42;
	public const int WS=43;
	public const int WS_CHAR=44;

	// delegates
	// delegators

	public ActionLexer()
	{
		OnCreated();
	}

	public ActionLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public ActionLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Language\\Action.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_CONDITIONAL();
	partial void LeaveRule_CONDITIONAL();

	// $ANTLR start "CONDITIONAL"
	[GrammarRule("CONDITIONAL")]
	private void mCONDITIONAL()
	{
		EnterRule_CONDITIONAL();
		EnterRule("CONDITIONAL", 1);
		TraceIn("CONDITIONAL", 1);
		try
		{
			int _type = CONDITIONAL;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:9:13: ( 'if' )
			DebugEnterAlt(1);
			// Language\\Action.g3:9:15: 'if'
			{
			DebugLocation(9, 15);
			Match("if"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CONDITIONAL", 1);
			LeaveRule("CONDITIONAL", 1);
			LeaveRule_CONDITIONAL();
		}
	}
	// $ANTLR end "CONDITIONAL"

	partial void EnterRule_ELSEIF();
	partial void LeaveRule_ELSEIF();

	// $ANTLR start "ELSEIF"
	[GrammarRule("ELSEIF")]
	private void mELSEIF()
	{
		EnterRule_ELSEIF();
		EnterRule("ELSEIF", 2);
		TraceIn("ELSEIF", 2);
		try
		{
			int _type = ELSEIF;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:10:8: ( 'elseif' )
			DebugEnterAlt(1);
			// Language\\Action.g3:10:10: 'elseif'
			{
			DebugLocation(10, 10);
			Match("elseif"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSEIF", 2);
			LeaveRule("ELSEIF", 2);
			LeaveRule_ELSEIF();
		}
	}
	// $ANTLR end "ELSEIF"

	partial void EnterRule_FIRST();
	partial void LeaveRule_FIRST();

	// $ANTLR start "FIRST"
	[GrammarRule("FIRST")]
	private void mFIRST()
	{
		EnterRule_FIRST();
		EnterRule("FIRST", 3);
		TraceIn("FIRST", 3);
		try
		{
			int _type = FIRST;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:11:7: ( 'first' )
			DebugEnterAlt(1);
			// Language\\Action.g3:11:9: 'first'
			{
			DebugLocation(11, 9);
			Match("first"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FIRST", 3);
			LeaveRule("FIRST", 3);
			LeaveRule_FIRST();
		}
	}
	// $ANTLR end "FIRST"

	partial void EnterRule_LAST();
	partial void LeaveRule_LAST();

	// $ANTLR start "LAST"
	[GrammarRule("LAST")]
	private void mLAST()
	{
		EnterRule_LAST();
		EnterRule("LAST", 4);
		TraceIn("LAST", 4);
		try
		{
			int _type = LAST;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:12:6: ( 'last' )
			DebugEnterAlt(1);
			// Language\\Action.g3:12:8: 'last'
			{
			DebugLocation(12, 8);
			Match("last"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LAST", 4);
			LeaveRule("LAST", 4);
			LeaveRule_LAST();
		}
	}
	// $ANTLR end "LAST"

	partial void EnterRule_LENGTH();
	partial void LeaveRule_LENGTH();

	// $ANTLR start "LENGTH"
	[GrammarRule("LENGTH")]
	private void mLENGTH()
	{
		EnterRule_LENGTH();
		EnterRule("LENGTH", 5);
		TraceIn("LENGTH", 5);
		try
		{
			int _type = LENGTH;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:13:8: ( 'length' )
			DebugEnterAlt(1);
			// Language\\Action.g3:13:10: 'length'
			{
			DebugLocation(13, 10);
			Match("length"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LENGTH", 5);
			LeaveRule("LENGTH", 5);
			LeaveRule_LENGTH();
		}
	}
	// $ANTLR end "LENGTH"

	partial void EnterRule_REST();
	partial void LeaveRule_REST();

	// $ANTLR start "REST"
	[GrammarRule("REST")]
	private void mREST()
	{
		EnterRule_REST();
		EnterRule("REST", 6);
		TraceIn("REST", 6);
		try
		{
			int _type = REST;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:14:6: ( 'rest' )
			DebugEnterAlt(1);
			// Language\\Action.g3:14:8: 'rest'
			{
			DebugLocation(14, 8);
			Match("rest"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REST", 6);
			LeaveRule("REST", 6);
			LeaveRule_REST();
		}
	}
	// $ANTLR end "REST"

	partial void EnterRule_STRIP();
	partial void LeaveRule_STRIP();

	// $ANTLR start "STRIP"
	[GrammarRule("STRIP")]
	private void mSTRIP()
	{
		EnterRule_STRIP();
		EnterRule("STRIP", 7);
		TraceIn("STRIP", 7);
		try
		{
			int _type = STRIP;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:15:7: ( 'strip' )
			DebugEnterAlt(1);
			// Language\\Action.g3:15:9: 'strip'
			{
			DebugLocation(15, 9);
			Match("strip"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRIP", 7);
			LeaveRule("STRIP", 7);
			LeaveRule_STRIP();
		}
	}
	// $ANTLR end "STRIP"

	partial void EnterRule_SUPER();
	partial void LeaveRule_SUPER();

	// $ANTLR start "SUPER"
	[GrammarRule("SUPER")]
	private void mSUPER()
	{
		EnterRule_SUPER();
		EnterRule("SUPER", 8);
		TraceIn("SUPER", 8);
		try
		{
			int _type = SUPER;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:16:7: ( 'super' )
			DebugEnterAlt(1);
			// Language\\Action.g3:16:9: 'super'
			{
			DebugLocation(16, 9);
			Match("super"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SUPER", 8);
			LeaveRule("SUPER", 8);
			LeaveRule_SUPER();
		}
	}
	// $ANTLR end "SUPER"

	partial void EnterRule_TRUNC();
	partial void LeaveRule_TRUNC();

	// $ANTLR start "TRUNC"
	[GrammarRule("TRUNC")]
	private void mTRUNC()
	{
		EnterRule_TRUNC();
		EnterRule("TRUNC", 9);
		TraceIn("TRUNC", 9);
		try
		{
			int _type = TRUNC;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:17:7: ( 'trunc' )
			DebugEnterAlt(1);
			// Language\\Action.g3:17:9: 'trunc'
			{
			DebugLocation(17, 9);
			Match("trunc"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRUNC", 9);
			LeaveRule("TRUNC", 9);
			LeaveRule_TRUNC();
		}
	}
	// $ANTLR end "TRUNC"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 10);
		TraceIn("ID", 10);
		try
		{
			int _type = ID;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:256:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )* )
			DebugEnterAlt(1);
			// Language\\Action.g3:256:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
			{
			DebugLocation(256, 4);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(256, 28);
			// Language\\Action.g3:256:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='/' && LA1_1<='9')||(LA1_1>='A' && LA1_1<='Z')||LA1_1=='_'||(LA1_1>='a' && LA1_1<='z')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:
					{
					DebugLocation(256, 28);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ID", 10);
			LeaveRule("ID", 10);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 11);
		TraceIn("INT", 11);
		try
		{
			int _type = INT;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:260:2: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Language\\Action.g3:260:4: ( '0' .. '9' )+
			{
			DebugLocation(260, 4);
			// Language\\Action.g3:260:4: ( '0' .. '9' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if (((LA2_1>='0' && LA2_1<='9')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:
					{
					DebugLocation(260, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INT", 11);
			LeaveRule("INT", 11);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 12);
		TraceIn("STRING", 12);
		try
		{
			int _type = STRING;
			int _channel = DefaultTokenChannel;
			int ch = 0;


				char uc = '\0';
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\Action.g3:269:2: ( '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"' )
			DebugEnterAlt(1);
			// Language\\Action.g3:269:4: '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"'
			{
			DebugLocation(269, 4);
			Match('\"'); if (state.failed) return;
			DebugLocation(270, 3);
			// Language\\Action.g3:270:3: ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=3;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1=='\\'))
				{
					alt3 = 1;
				}
				else if (((LA3_1>='\u0000' && LA3_1<='!')||(LA3_1>='#' && LA3_1<='[')||(LA3_1>=']' && LA3_1<='\uFFFF')))
				{
					alt3 = 2;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:270:5: ESC_CHAR[out uc, true]
					{
					DebugLocation(270, 5);
					mESC_CHAR(out uc, true); if (state.failed) return;
					DebugLocation(270, 28);
					if (state.backtracking == 0)
					{
						builder.Append(uc);
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Action.g3:271:5: ch=~ ( '\\\\' | '\"' )
					{
					DebugLocation(271, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(271, 20);
					if (state.backtracking == 0)
					{
						builder.Append((char)ch);
					}

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }

			DebugLocation(273, 3);
			Match('\"'); if (state.failed) return;
			DebugLocation(274, 3);
			if (state.backtracking == 0)
			{

							Text = builder.ToString();
						
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING", 12);
			LeaveRule("STRING", 12);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_ANONYMOUS_TEMPLATE();
	partial void LeaveRule_ANONYMOUS_TEMPLATE();

	// $ANTLR start "ANONYMOUS_TEMPLATE"
	[GrammarRule("ANONYMOUS_TEMPLATE")]
	private void mANONYMOUS_TEMPLATE()
	{
		EnterRule_ANONYMOUS_TEMPLATE();
		EnterRule("ANONYMOUS_TEMPLATE", 13);
		TraceIn("ANONYMOUS_TEMPLATE", 13);
		try
		{
			int _type = ANONYMOUS_TEMPLATE;
			int _channel = DefaultTokenChannel;
			CommonToken ESC_CHAR1 = default(CommonToken);
			int ch = 0;


				StringTemplateToken t = null;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();
				List<string> args = new List<string>();
				string subtext = string.Empty;
				char uc = '\0';

			// Language\\Action.g3:288:2: ( '{' ( ( ( WS_CHAR )? ID )=> TEMPLATE_ARGS[out subtext, args] ( ( WS_CHAR )=> WS_CHAR )? |) ( ( '\\\\{' )=> '\\\\{' | ( '\\\\}' )=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}' )
			DebugEnterAlt(1);
			// Language\\Action.g3:288:4: '{' ( ( ( WS_CHAR )? ID )=> TEMPLATE_ARGS[out subtext, args] ( ( WS_CHAR )=> WS_CHAR )? |) ( ( '\\\\{' )=> '\\\\{' | ( '\\\\}' )=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}'
			{
			DebugLocation(288, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(289, 3);
			// Language\\Action.g3:289:3: ( ( ( WS_CHAR )? ID )=> TEMPLATE_ARGS[out subtext, args] ( ( WS_CHAR )=> WS_CHAR )? |)
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			try
			{
				alt5 = dfa5.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:289:5: ( ( WS_CHAR )? ID )=> TEMPLATE_ARGS[out subtext, args] ( ( WS_CHAR )=> WS_CHAR )?
				{
				DebugLocation(289, 22);
				mTEMPLATE_ARGS(out subtext, args); if (state.failed) return;
				DebugLocation(289, 55);
				if (state.backtracking == 0)
				{
					builder.Append(subtext);
				}
				DebugLocation(289, 82);
				// Language\\Action.g3:289:82: ( ( WS_CHAR )=> WS_CHAR )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				switch (input.LA(1))
				{
				case ' ':
					{
					int LA4_2 = input.LA(2);

					if ((EvaluatePredicate(synpred2_Action_fragment)))
					{
						alt4 = 1;
					}
					}
					break;
				case '\t':
					{
					int LA4_2 = input.LA(2);

					if ((EvaluatePredicate(synpred2_Action_fragment)))
					{
						alt4 = 1;
					}
					}
					break;
				case '\r':
					{
					int LA4_2 = input.LA(2);

					if ((EvaluatePredicate(synpred2_Action_fragment)))
					{
						alt4 = 1;
					}
					}
					break;
				case '\n':
					{
					int LA4_2 = input.LA(2);

					if ((EvaluatePredicate(synpred2_Action_fragment)))
					{
						alt4 = 1;
					}
					}
					break;
				}

				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:289:83: ( WS_CHAR )=> WS_CHAR
					{
					DebugLocation(289, 96);
					mWS_CHAR(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(4); }

				DebugLocation(290, 4);
				if (state.backtracking == 0)
				{

									// create a special token to track args
									t = new StringTemplateToken(ANONYMOUS_TEMPLATE,Text,args);
									//setToken(t);
									state.token = t;
								
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:297:3: 
				{
				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(298, 3);
			// Language\\Action.g3:298:3: ( ( '\\\\{' )=> '\\\\{' | ( '\\\\}' )=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=6;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1=='\\'))
				{
					int LA6_2 = input.LA(2);

					if ((LA6_2=='{'))
					{
						int LA6_3 = input.LA(3);

						if ((EvaluatePredicate(synpred3_Action_fragment)))
						{
							alt6 = 1;
						}
						else if ((true))
						{
							alt6 = 3;
						}


					}
					else if ((LA6_2=='}'))
					{
						int LA6_3 = input.LA(3);

						if ((EvaluatePredicate(synpred4_Action_fragment)))
						{
							alt6 = 2;
						}
						else if ((true))
						{
							alt6 = 3;
						}


					}
					else if (((LA6_2>='\u0000' && LA6_2<='z')||LA6_2=='|'||(LA6_2>='~' && LA6_2<='\uFFFF')))
					{
						alt6 = 3;
					}


				}
				else if ((LA6_1=='{'))
				{
					alt6 = 4;
				}
				else if (((LA6_1>='\u0000' && LA6_1<='[')||(LA6_1>=']' && LA6_1<='z')||LA6_1=='|'||(LA6_1>='~' && LA6_1<='\uFFFF')))
				{
					alt6 = 5;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:298:5: ( '\\\\{' )=> '\\\\{'
					{
					DebugLocation(298, 16);
					Match("\\{"); if (state.failed) return;

					DebugLocation(298, 22);
					if (state.backtracking == 0)
					{
						builder.Append( '{' );
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Action.g3:299:5: ( '\\\\}' )=> '\\\\}'
					{
					DebugLocation(299, 16);
					Match("\\}"); if (state.failed) return;

					DebugLocation(299, 22);
					if (state.backtracking == 0)
					{
						builder.Append( '}' );
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Action.g3:300:5: ESC_CHAR[out uc, false]
					{
					DebugLocation(300, 5);
					int ESC_CHAR1Start295 = CharIndex;
					int ESC_CHAR1StartLine295 = Line;
					int ESC_CHAR1StartCharPos295 = CharPositionInLine;
					mESC_CHAR(out uc, false); if (state.failed) return;
					ESC_CHAR1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC_CHAR1Start295, CharIndex-1);
					ESC_CHAR1.Line = ESC_CHAR1StartLine295;
					ESC_CHAR1.CharPositionInLine = ESC_CHAR1StartCharPos295;
					DebugLocation(300, 29);
					if (state.backtracking == 0)
					{
						builder.Append( (ESC_CHAR1!=null?ESC_CHAR1.Text:default(string)) );
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\Action.g3:301:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
					{
					DebugLocation(301, 5);
					mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return;
					DebugLocation(301, 44);
					if (state.backtracking == 0)
					{
						builder.Append(subtext);
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Language\\Action.g3:302:5: ch=~ ( '\\\\' | '{' | '}' )
					{
					DebugLocation(302, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(302, 24);
					if (state.backtracking == 0)
					{
						builder.Append((char)ch);
					}

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(304, 3);
			if (state.backtracking == 0)
			{

							Text = builder.ToString();
							if ( t!=null )
								t.Text = Text;
						
			}
			DebugLocation(309, 3);
			Match('}'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ANONYMOUS_TEMPLATE", 13);
			LeaveRule("ANONYMOUS_TEMPLATE", 13);
			LeaveRule_ANONYMOUS_TEMPLATE();
		}
	}
	// $ANTLR end "ANONYMOUS_TEMPLATE"

	partial void EnterRule_TEMPLATE_ARGS();
	partial void LeaveRule_TEMPLATE_ARGS();

	// $ANTLR start "TEMPLATE_ARGS"
	[GrammarRule("TEMPLATE_ARGS")]
	private void mTEMPLATE_ARGS(out string _text, List<string> args)
	{
		EnterRule_TEMPLATE_ARGS();
		EnterRule("TEMPLATE_ARGS", 14);
		TraceIn("TEMPLATE_ARGS", 14);
		try
		{
			CommonToken a = default(CommonToken);
			CommonToken a2 = default(CommonToken);


				_text = string.Empty; // this template is empty text
				args.Clear();

			// Language\\Action.g3:320:2: ( ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|' )
			DebugEnterAlt(1);
			// Language\\Action.g3:320:4: ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|'
			{
			DebugLocation(320, 4);
			// Language\\Action.g3:320:4: ( WS_CHAR )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if (((LA7_1>='\t' && LA7_1<='\n')||LA7_1=='\r'||LA7_1==' '))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:320:5: WS_CHAR
				{
				DebugLocation(320, 5);
				mWS_CHAR(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(320, 16);
			int aStart363 = CharIndex;
			int aStartLine363 = Line;
			int aStartCharPos363 = CharPositionInLine;
			mID(); if (state.failed) return;
			a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart363, CharIndex-1);
			a.Line = aStartLine363;
			a.CharPositionInLine = aStartCharPos363;
			DebugLocation(320, 20);
			if (state.backtracking == 0)
			{
				args.Add((a!=null?a.Text:default(string)));
			}
			DebugLocation(321, 3);
			// Language\\Action.g3:321:3: ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				switch (input.LA(1))
				{
				case ' ':
					{
					int LA10_2 = input.LA(2);

					if ((LA10_2==','))
					{
						alt10 = 1;
					}


					}
					break;
				case '\t':
					{
					int LA10_2 = input.LA(2);

					if ((LA10_2==','))
					{
						alt10 = 1;
					}


					}
					break;
				case '\r':
					{
					int LA10_2 = input.LA(2);

					if ((LA10_2=='\n'))
					{
						int LA10_3 = input.LA(3);

						if ((LA10_3==','))
						{
							alt10 = 1;
						}


					}
					else if ((LA10_2==','))
					{
						alt10 = 1;
					}


					}
					break;
				case '\n':
					{
					int LA10_2 = input.LA(2);

					if ((LA10_2==','))
					{
						alt10 = 1;
					}


					}
					break;
				case ',':
					{
					alt10 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:321:5: ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID
					{
					DebugLocation(321, 5);
					// Language\\Action.g3:321:5: ( WS_CHAR )?
					int alt8=2;
					try { DebugEnterSubRule(8);
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if (((LA8_1>='\t' && LA8_1<='\n')||LA8_1=='\r'||LA8_1==' '))
					{
						alt8 = 1;
					}
					} finally { DebugExitDecision(8); }
					switch (alt8)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Action.g3:321:6: WS_CHAR
						{
						DebugLocation(321, 6);
						mWS_CHAR(); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(8); }

					DebugLocation(321, 16);
					Match(','); if (state.failed) return;
					DebugLocation(321, 20);
					// Language\\Action.g3:321:20: ( WS_CHAR )?
					int alt9=2;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					int LA9_1 = input.LA(1);

					if (((LA9_1>='\t' && LA9_1<='\n')||LA9_1=='\r'||LA9_1==' '))
					{
						alt9 = 1;
					}
					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Action.g3:321:21: WS_CHAR
						{
						DebugLocation(321, 21);
						mWS_CHAR(); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(321, 33);
					int a2Start385 = CharIndex;
					int a2StartLine385 = Line;
					int a2StartCharPos385 = CharPositionInLine;
					mID(); if (state.failed) return;
					a2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, a2Start385, CharIndex-1);
					a2.Line = a2StartLine385;
					a2.CharPositionInLine = a2StartCharPos385;
					DebugLocation(321, 37);
					if (state.backtracking == 0)
					{
						args.Add((a2!=null?a2.Text:default(string)));
					}

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(322, 3);
			// Language\\Action.g3:322:3: ( WS_CHAR )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if (((LA11_1>='\t' && LA11_1<='\n')||LA11_1=='\r'||LA11_1==' '))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:322:4: WS_CHAR
				{
				DebugLocation(322, 4);
				mWS_CHAR(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(322, 14);
			Match('|'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("TEMPLATE_ARGS", 14);
			LeaveRule("TEMPLATE_ARGS", 14);
			LeaveRule_TEMPLATE_ARGS();
		}
	}
	// $ANTLR end "TEMPLATE_ARGS"

	partial void EnterRule_NESTED_ANONYMOUS_TEMPLATE();
	partial void LeaveRule_NESTED_ANONYMOUS_TEMPLATE();

	// $ANTLR start "NESTED_ANONYMOUS_TEMPLATE"
	[GrammarRule("NESTED_ANONYMOUS_TEMPLATE")]
	private void mNESTED_ANONYMOUS_TEMPLATE(out string _text)
	{
		EnterRule_NESTED_ANONYMOUS_TEMPLATE();
		EnterRule("NESTED_ANONYMOUS_TEMPLATE", 15);
		TraceIn("NESTED_ANONYMOUS_TEMPLATE", 15);
		try
		{
			CommonToken ESC_CHAR2 = default(CommonToken);
			int ch = 0;


				_text = string.Empty;
				char uc = '\0';
				string subtext = string.Empty;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\Action.g3:334:2: ( '{' ( ( '\\\\{' )=> '\\\\{' | ( '\\\\}' )=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}' )
			DebugEnterAlt(1);
			// Language\\Action.g3:334:4: '{' ( ( '\\\\{' )=> '\\\\{' | ( '\\\\}' )=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}'
			{
			DebugLocation(334, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(335, 3);
			if (state.backtracking == 0)
			{
				builder.Append('{');
			}
			DebugLocation(336, 3);
			// Language\\Action.g3:336:3: ( ( '\\\\{' )=> '\\\\{' | ( '\\\\}' )=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=6;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1=='\\'))
				{
					int LA12_2 = input.LA(2);

					if ((LA12_2=='{'))
					{
						int LA12_3 = input.LA(3);

						if ((EvaluatePredicate(synpred5_Action_fragment)))
						{
							alt12 = 1;
						}
						else if ((true))
						{
							alt12 = 3;
						}


					}
					else if ((LA12_2=='}'))
					{
						int LA12_3 = input.LA(3);

						if ((EvaluatePredicate(synpred6_Action_fragment)))
						{
							alt12 = 2;
						}
						else if ((true))
						{
							alt12 = 3;
						}


					}
					else if (((LA12_2>='\u0000' && LA12_2<='z')||LA12_2=='|'||(LA12_2>='~' && LA12_2<='\uFFFF')))
					{
						alt12 = 3;
					}


				}
				else if ((LA12_1=='{'))
				{
					alt12 = 4;
				}
				else if (((LA12_1>='\u0000' && LA12_1<='[')||(LA12_1>=']' && LA12_1<='z')||LA12_1=='|'||(LA12_1>='~' && LA12_1<='\uFFFF')))
				{
					alt12 = 5;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:336:5: ( '\\\\{' )=> '\\\\{'
					{
					DebugLocation(336, 16);
					Match("\\{"); if (state.failed) return;

					DebugLocation(336, 22);
					if (state.backtracking == 0)
					{
						builder.Append('{');
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Action.g3:337:5: ( '\\\\}' )=> '\\\\}'
					{
					DebugLocation(337, 16);
					Match("\\}"); if (state.failed) return;

					DebugLocation(337, 22);
					if (state.backtracking == 0)
					{
						builder.Append('}');
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Action.g3:338:5: ESC_CHAR[out uc, false]
					{
					DebugLocation(338, 5);
					int ESC_CHAR2Start455 = CharIndex;
					int ESC_CHAR2StartLine455 = Line;
					int ESC_CHAR2StartCharPos455 = CharPositionInLine;
					mESC_CHAR(out uc, false); if (state.failed) return;
					ESC_CHAR2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC_CHAR2Start455, CharIndex-1);
					ESC_CHAR2.Line = ESC_CHAR2StartLine455;
					ESC_CHAR2.CharPositionInLine = ESC_CHAR2StartCharPos455;
					DebugLocation(338, 29);
					if (state.backtracking == 0)
					{
						builder.Append((ESC_CHAR2!=null?ESC_CHAR2.Text:default(string)));
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\Action.g3:339:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
					{
					DebugLocation(339, 5);
					mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return;
					DebugLocation(339, 44);
					if (state.backtracking == 0)
					{
						builder.Append(subtext);
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Language\\Action.g3:340:5: ch=~ ( '{' | '}' | '\\\\' )
					{
					DebugLocation(340, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(340, 24);
					if (state.backtracking == 0)
					{
						builder.Append((char)ch);
					}

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(342, 3);
			Match('}'); if (state.failed) return;
			DebugLocation(343, 3);
			if (state.backtracking == 0)
			{

							builder.Append('}');
							_text = builder.ToString();
						
			}

			}

		}
		finally
		{
			TraceOut("NESTED_ANONYMOUS_TEMPLATE", 15);
			LeaveRule("NESTED_ANONYMOUS_TEMPLATE", 15);
			LeaveRule_NESTED_ANONYMOUS_TEMPLATE();
		}
	}
	// $ANTLR end "NESTED_ANONYMOUS_TEMPLATE"

	partial void EnterRule_ESC_CHAR();
	partial void LeaveRule_ESC_CHAR();

	// $ANTLR start "ESC_CHAR"
	[GrammarRule("ESC_CHAR")]
	private void mESC_CHAR(out char uc, bool doEscape)
	{
		EnterRule_ESC_CHAR();
		EnterRule("ESC_CHAR", 16);
		TraceIn("ESC_CHAR", 16);
		try
		{
			int c = 0;


				uc = '\0';

			// Language\\Action.g3:361:2: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) ) )
			DebugEnterAlt(1);
			// Language\\Action.g3:361:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
			{
			DebugLocation(361, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(362, 3);
			// Language\\Action.g3:362:3: ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
			int alt13=6;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1=='n'))
			{
				alt13 = 1;
			}
			else if ((LA13_1=='r'))
			{
				alt13 = 2;
			}
			else if ((LA13_1=='t'))
			{
				alt13 = 3;
			}
			else if ((LA13_1=='b'))
			{
				alt13 = 4;
			}
			else if ((LA13_1=='f'))
			{
				alt13 = 5;
			}
			else if (((LA13_1>='\u0000' && LA13_1<='a')||(LA13_1>='c' && LA13_1<='e')||(LA13_1>='g' && LA13_1<='m')||(LA13_1>='o' && LA13_1<='q')||LA13_1=='s'||(LA13_1>='u' && LA13_1<='\uFFFF')))
			{
				alt13 = 6;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:362:5: 'n'
				{
				DebugLocation(362, 5);
				Match('n'); if (state.failed) return;
				DebugLocation(362, 9);
				if (state.backtracking == 0)
				{
					if (doEscape) { uc = '\n'; }
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:363:5: 'r'
				{
				DebugLocation(363, 5);
				Match('r'); if (state.failed) return;
				DebugLocation(363, 9);
				if (state.backtracking == 0)
				{
					if (doEscape) { uc = '\r'; }
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:364:5: 't'
				{
				DebugLocation(364, 5);
				Match('t'); if (state.failed) return;
				DebugLocation(364, 9);
				if (state.backtracking == 0)
				{
					if (doEscape) { uc = '\t'; }
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Action.g3:365:5: 'b'
				{
				DebugLocation(365, 5);
				Match('b'); if (state.failed) return;
				DebugLocation(365, 9);
				if (state.backtracking == 0)
				{
					if (doEscape) { uc = '\b'; }
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Language\\Action.g3:366:5: 'f'
				{
				DebugLocation(366, 5);
				Match('f'); if (state.failed) return;
				DebugLocation(366, 9);
				if (state.backtracking == 0)
				{
					if (doEscape) { uc = '\f'; }
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Language\\Action.g3:367:5: c=~ ( 'n' | 'r' | 't' | 'b' | 'f' )
				{
				DebugLocation(367, 6);
				c= input.LA(1);
				input.Consume();
				state.failed=false;
				DebugLocation(367, 30);
				if (state.backtracking == 0)
				{
					if (doEscape) { uc = (char)c; }
				}

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

		}
		finally
		{
			TraceOut("ESC_CHAR", 16);
			LeaveRule("ESC_CHAR", 16);
			LeaveRule_ESC_CHAR();
		}
	}
	// $ANTLR end "ESC_CHAR"

	partial void EnterRule_LBRACK();
	partial void LeaveRule_LBRACK();

	// $ANTLR start "LBRACK"
	[GrammarRule("LBRACK")]
	private void mLBRACK()
	{
		EnterRule_LBRACK();
		EnterRule("LBRACK", 17);
		TraceIn("LBRACK", 17);
		try
		{
			int _type = LBRACK;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:367:9: ( '[' )
			DebugEnterAlt(1);
			// Language\\Action.g3:367:11: '['
			{
			DebugLocation(367, 11);
			Match('['); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACK", 17);
			LeaveRule("LBRACK", 17);
			LeaveRule_LBRACK();
		}
	}
	// $ANTLR end "LBRACK"

	partial void EnterRule_RBRACK();
	partial void LeaveRule_RBRACK();

	// $ANTLR start "RBRACK"
	[GrammarRule("RBRACK")]
	private void mRBRACK()
	{
		EnterRule_RBRACK();
		EnterRule("RBRACK", 18);
		TraceIn("RBRACK", 18);
		try
		{
			int _type = RBRACK;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:368:9: ( ']' )
			DebugEnterAlt(1);
			// Language\\Action.g3:368:11: ']'
			{
			DebugLocation(368, 11);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACK", 18);
			LeaveRule("RBRACK", 18);
			LeaveRule_RBRACK();
		}
	}
	// $ANTLR end "RBRACK"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 19);
		TraceIn("LPAREN", 19);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:369:9: ( '(' )
			DebugEnterAlt(1);
			// Language\\Action.g3:369:11: '('
			{
			DebugLocation(369, 11);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 19);
			LeaveRule("LPAREN", 19);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 20);
		TraceIn("RPAREN", 20);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:370:9: ( ')' )
			DebugEnterAlt(1);
			// Language\\Action.g3:370:11: ')'
			{
			DebugLocation(370, 11);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 20);
			LeaveRule("RPAREN", 20);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 21);
		TraceIn("COMMA", 21);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:371:8: ( ',' )
			DebugEnterAlt(1);
			// Language\\Action.g3:371:10: ','
			{
			DebugLocation(371, 10);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 21);
			LeaveRule("COMMA", 21);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 22);
		TraceIn("DOT", 22);
		try
		{
			int _type = DOT;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:372:7: ( '.' )
			DebugEnterAlt(1);
			// Language\\Action.g3:372:9: '.'
			{
			DebugLocation(372, 9);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOT", 22);
			LeaveRule("DOT", 22);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 23);
		TraceIn("ASSIGN", 23);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:373:9: ( '=' )
			DebugEnterAlt(1);
			// Language\\Action.g3:373:11: '='
			{
			DebugLocation(373, 11);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 23);
			LeaveRule("ASSIGN", 23);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 24);
		TraceIn("COLON", 24);
		try
		{
			int _type = COLON;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:374:8: ( ':' )
			DebugEnterAlt(1);
			// Language\\Action.g3:374:10: ':'
			{
			DebugLocation(374, 10);
			Match(':'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLON", 24);
			LeaveRule("COLON", 24);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 25);
		TraceIn("PLUS", 25);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:375:7: ( '+' )
			DebugEnterAlt(1);
			// Language\\Action.g3:375:9: '+'
			{
			DebugLocation(375, 9);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 25);
			LeaveRule("PLUS", 25);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 26);
		TraceIn("SEMI", 26);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:376:7: ( ';' )
			DebugEnterAlt(1);
			// Language\\Action.g3:376:9: ';'
			{
			DebugLocation(376, 9);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 26);
			LeaveRule("SEMI", 26);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 27);
		TraceIn("NOT", 27);
		try
		{
			int _type = NOT;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:377:7: ( '!' )
			DebugEnterAlt(1);
			// Language\\Action.g3:377:9: '!'
			{
			DebugLocation(377, 9);
			Match('!'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT", 27);
			LeaveRule("NOT", 27);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_DOTDOTDOT();
	partial void LeaveRule_DOTDOTDOT();

	// $ANTLR start "DOTDOTDOT"
	[GrammarRule("DOTDOTDOT")]
	private void mDOTDOTDOT()
	{
		EnterRule_DOTDOTDOT();
		EnterRule("DOTDOTDOT", 28);
		TraceIn("DOTDOTDOT", 28);
		try
		{
			int _type = DOTDOTDOT;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:378:11: ( '...' )
			DebugEnterAlt(1);
			// Language\\Action.g3:378:13: '...'
			{
			DebugLocation(378, 13);
			Match("..."); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOTDOTDOT", 28);
			LeaveRule("DOTDOTDOT", 28);
			LeaveRule_DOTDOTDOT();
		}
	}
	// $ANTLR end "DOTDOTDOT"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 29);
		TraceIn("WS", 29);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// Language\\Action.g3:381:2: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
			DebugEnterAlt(1);
			// Language\\Action.g3:381:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
			{
			DebugLocation(381, 4);
			// Language\\Action.g3:381:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
			int cnt14=0;
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if (((LA14_1>='\t' && LA14_1<='\n')||LA14_1=='\r'||LA14_1==' '))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch (alt14)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:
					{
					DebugLocation(381, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt14 >= 1)
						goto loop14;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee14 = new EarlyExitException( 14, input );
					DebugRecognitionException(eee14);
					throw eee14;
				}
				cnt14++;
			}
			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(382, 3);
			if (state.backtracking == 0)
			{
				_channel = Hidden;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 29);
			LeaveRule("WS", 29);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_WS_CHAR();
	partial void LeaveRule_WS_CHAR();

	// $ANTLR start "WS_CHAR"
	[GrammarRule("WS_CHAR")]
	private void mWS_CHAR()
	{
		EnterRule_WS_CHAR();
		EnterRule("WS_CHAR", 30);
		TraceIn("WS_CHAR", 30);
		try
		{
			// Language\\Action.g3:388:2: ( ' ' | '\\t' | NEWLINE )
			int alt15=3;
			try { DebugEnterDecision(15, false);
			switch (input.LA(1))
			{
			case ' ':
				{
				alt15 = 1;
				}
				break;
			case '\t':
				{
				alt15 = 2;
				}
				break;
			case '\n':
			case '\r':
				{
				alt15 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:388:4: ' '
				{
				DebugLocation(388, 4);
				Match(' '); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:388:8: '\\t'
				{
				DebugLocation(388, 8);
				Match('\t'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Action.g3:388:13: NEWLINE
				{
				DebugLocation(388, 13);
				mNEWLINE(); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("WS_CHAR", 30);
			LeaveRule("WS_CHAR", 30);
			LeaveRule_WS_CHAR();
		}
	}
	// $ANTLR end "WS_CHAR"

	partial void EnterRule_NEWLINE();
	partial void LeaveRule_NEWLINE();

	// $ANTLR start "NEWLINE"
	[GrammarRule("NEWLINE")]
	private void mNEWLINE()
	{
		EnterRule_NEWLINE();
		EnterRule("NEWLINE", 31);
		TraceIn("NEWLINE", 31);
		try
		{
			// Language\\Action.g3:393:2: ( '\\r' ( ( '\\n' )=> '\\n' )? | '\\n' )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1=='\r'))
			{
				alt17 = 1;
			}
			else if ((LA17_1=='\n'))
			{
				alt17 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:393:4: '\\r' ( ( '\\n' )=> '\\n' )?
				{
				DebugLocation(393, 4);
				Match('\r'); if (state.failed) return;
				DebugLocation(393, 9);
				// Language\\Action.g3:393:9: ( ( '\\n' )=> '\\n' )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1=='\n') && (EvaluatePredicate(synpred7_Action_fragment)))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Action.g3:393:10: ( '\\n' )=> '\\n'
					{
					DebugLocation(393, 20);
					Match('\n'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(16); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Action.g3:394:4: '\\n'
				{
				DebugLocation(394, 4);
				Match('\n'); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("NEWLINE", 31);
			LeaveRule("NEWLINE", 31);
			LeaveRule_NEWLINE();
		}
	}
	// $ANTLR end "NEWLINE"

	public override void mTokens()
	{
		// Language\\Action.g3:1:8: ( CONDITIONAL | ELSEIF | FIRST | LAST | LENGTH | REST | STRIP | SUPER | TRUNC | ID | INT | STRING | ANONYMOUS_TEMPLATE | LBRACK | RBRACK | LPAREN | RPAREN | COMMA | DOT | ASSIGN | COLON | PLUS | SEMI | NOT | DOTDOTDOT | WS )
		int alt18=26;
		try { DebugEnterDecision(18, false);
		try
		{
			alt18 = dfa18.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(18); }
		switch (alt18)
		{
		case 1:
			DebugEnterAlt(1);
			// Language\\Action.g3:1:10: CONDITIONAL
			{
			DebugLocation(1, 10);
			mCONDITIONAL(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Language\\Action.g3:1:22: ELSEIF
			{
			DebugLocation(1, 22);
			mELSEIF(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Language\\Action.g3:1:29: FIRST
			{
			DebugLocation(1, 29);
			mFIRST(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Language\\Action.g3:1:35: LAST
			{
			DebugLocation(1, 35);
			mLAST(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Language\\Action.g3:1:40: LENGTH
			{
			DebugLocation(1, 40);
			mLENGTH(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Language\\Action.g3:1:47: REST
			{
			DebugLocation(1, 47);
			mREST(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Language\\Action.g3:1:52: STRIP
			{
			DebugLocation(1, 52);
			mSTRIP(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Language\\Action.g3:1:58: SUPER
			{
			DebugLocation(1, 58);
			mSUPER(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Language\\Action.g3:1:64: TRUNC
			{
			DebugLocation(1, 64);
			mTRUNC(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Language\\Action.g3:1:70: ID
			{
			DebugLocation(1, 70);
			mID(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Language\\Action.g3:1:73: INT
			{
			DebugLocation(1, 73);
			mINT(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Language\\Action.g3:1:77: STRING
			{
			DebugLocation(1, 77);
			mSTRING(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Language\\Action.g3:1:84: ANONYMOUS_TEMPLATE
			{
			DebugLocation(1, 84);
			mANONYMOUS_TEMPLATE(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Language\\Action.g3:1:103: LBRACK
			{
			DebugLocation(1, 103);
			mLBRACK(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Language\\Action.g3:1:110: RBRACK
			{
			DebugLocation(1, 110);
			mRBRACK(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Language\\Action.g3:1:117: LPAREN
			{
			DebugLocation(1, 117);
			mLPAREN(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Language\\Action.g3:1:124: RPAREN
			{
			DebugLocation(1, 124);
			mRPAREN(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Language\\Action.g3:1:131: COMMA
			{
			DebugLocation(1, 131);
			mCOMMA(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Language\\Action.g3:1:137: DOT
			{
			DebugLocation(1, 137);
			mDOT(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Language\\Action.g3:1:141: ASSIGN
			{
			DebugLocation(1, 141);
			mASSIGN(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Language\\Action.g3:1:148: COLON
			{
			DebugLocation(1, 148);
			mCOLON(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Language\\Action.g3:1:154: PLUS
			{
			DebugLocation(1, 154);
			mPLUS(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Language\\Action.g3:1:159: SEMI
			{
			DebugLocation(1, 159);
			mSEMI(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Language\\Action.g3:1:164: NOT
			{
			DebugLocation(1, 164);
			mNOT(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Language\\Action.g3:1:168: DOTDOTDOT
			{
			DebugLocation(1, 168);
			mDOTDOTDOT(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Language\\Action.g3:1:178: WS
			{
			DebugLocation(1, 178);
			mWS(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_Action_fragment();
	partial void LeaveRule_synpred1_Action_fragment();

	// $ANTLR start synpred1_Action
	private void synpred1_Action_fragment()
	{
		EnterRule_synpred1_Action_fragment();
		EnterRule("synpred1_Action_fragment", 33);
		TraceIn("synpred1_Action_fragment", 33);
		try
		{
			// Language\\Action.g3:289:5: ( ( WS_CHAR )? ID )
			DebugEnterAlt(1);
			// Language\\Action.g3:289:6: ( WS_CHAR )? ID
			{
			DebugLocation(289, 6);
			// Language\\Action.g3:289:6: ( WS_CHAR )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if (((LA19_1>='\t' && LA19_1<='\n')||LA19_1=='\r'||LA19_1==' '))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Action.g3:289:6: WS_CHAR
				{
				DebugLocation(289, 6);
				mWS_CHAR(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(289, 15);
			mID(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Action_fragment", 33);
			LeaveRule("synpred1_Action_fragment", 33);
			LeaveRule_synpred1_Action_fragment();
		}
	}
	// $ANTLR end synpred1_Action

	partial void EnterRule_synpred2_Action_fragment();
	partial void LeaveRule_synpred2_Action_fragment();

	// $ANTLR start synpred2_Action
	private void synpred2_Action_fragment()
	{
		EnterRule_synpred2_Action_fragment();
		EnterRule("synpred2_Action_fragment", 34);
		TraceIn("synpred2_Action_fragment", 34);
		try
		{
			// Language\\Action.g3:289:83: ( WS_CHAR )
			DebugEnterAlt(1);
			// Language\\Action.g3:289:84: WS_CHAR
			{
			DebugLocation(289, 84);
			mWS_CHAR(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_Action_fragment", 34);
			LeaveRule("synpred2_Action_fragment", 34);
			LeaveRule_synpred2_Action_fragment();
		}
	}
	// $ANTLR end synpred2_Action

	partial void EnterRule_synpred3_Action_fragment();
	partial void LeaveRule_synpred3_Action_fragment();

	// $ANTLR start synpred3_Action
	private void synpred3_Action_fragment()
	{
		EnterRule_synpred3_Action_fragment();
		EnterRule("synpred3_Action_fragment", 35);
		TraceIn("synpred3_Action_fragment", 35);
		try
		{
			// Language\\Action.g3:298:5: ( '\\\\{' )
			DebugEnterAlt(1);
			// Language\\Action.g3:298:6: '\\\\{'
			{
			DebugLocation(298, 6);
			Match("\\{"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred3_Action_fragment", 35);
			LeaveRule("synpred3_Action_fragment", 35);
			LeaveRule_synpred3_Action_fragment();
		}
	}
	// $ANTLR end synpred3_Action

	partial void EnterRule_synpred4_Action_fragment();
	partial void LeaveRule_synpred4_Action_fragment();

	// $ANTLR start synpred4_Action
	private void synpred4_Action_fragment()
	{
		EnterRule_synpred4_Action_fragment();
		EnterRule("synpred4_Action_fragment", 36);
		TraceIn("synpred4_Action_fragment", 36);
		try
		{
			// Language\\Action.g3:299:5: ( '\\\\}' )
			DebugEnterAlt(1);
			// Language\\Action.g3:299:6: '\\\\}'
			{
			DebugLocation(299, 6);
			Match("\\}"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred4_Action_fragment", 36);
			LeaveRule("synpred4_Action_fragment", 36);
			LeaveRule_synpred4_Action_fragment();
		}
	}
	// $ANTLR end synpred4_Action

	partial void EnterRule_synpred5_Action_fragment();
	partial void LeaveRule_synpred5_Action_fragment();

	// $ANTLR start synpred5_Action
	private void synpred5_Action_fragment()
	{
		EnterRule_synpred5_Action_fragment();
		EnterRule("synpred5_Action_fragment", 37);
		TraceIn("synpred5_Action_fragment", 37);
		try
		{
			// Language\\Action.g3:336:5: ( '\\\\{' )
			DebugEnterAlt(1);
			// Language\\Action.g3:336:6: '\\\\{'
			{
			DebugLocation(336, 6);
			Match("\\{"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred5_Action_fragment", 37);
			LeaveRule("synpred5_Action_fragment", 37);
			LeaveRule_synpred5_Action_fragment();
		}
	}
	// $ANTLR end synpred5_Action

	partial void EnterRule_synpred6_Action_fragment();
	partial void LeaveRule_synpred6_Action_fragment();

	// $ANTLR start synpred6_Action
	private void synpred6_Action_fragment()
	{
		EnterRule_synpred6_Action_fragment();
		EnterRule("synpred6_Action_fragment", 38);
		TraceIn("synpred6_Action_fragment", 38);
		try
		{
			// Language\\Action.g3:337:5: ( '\\\\}' )
			DebugEnterAlt(1);
			// Language\\Action.g3:337:6: '\\\\}'
			{
			DebugLocation(337, 6);
			Match("\\}"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred6_Action_fragment", 38);
			LeaveRule("synpred6_Action_fragment", 38);
			LeaveRule_synpred6_Action_fragment();
		}
	}
	// $ANTLR end synpred6_Action

	partial void EnterRule_synpred7_Action_fragment();
	partial void LeaveRule_synpred7_Action_fragment();

	// $ANTLR start synpred7_Action
	private void synpred7_Action_fragment()
	{
		EnterRule_synpred7_Action_fragment();
		EnterRule("synpred7_Action_fragment", 39);
		TraceIn("synpred7_Action_fragment", 39);
		try
		{
			// Language\\Action.g3:393:10: ( '\\n' )
			DebugEnterAlt(1);
			// Language\\Action.g3:393:11: '\\n'
			{
			DebugLocation(393, 11);
			Match('\n'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_Action_fragment", 39);
			LeaveRule("synpred7_Action_fragment", 39);
			LeaveRule_synpred7_Action_fragment();
		}
	}
	// $ANTLR end synpred7_Action

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA5 dfa5;
	DFA18 dfa18;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa5 = new DFA5(this, SpecialStateTransition5);
		dfa18 = new DFA18(this);
	}

	private class DFA5 : DFA
	{
		private const string DFA5_eotS =
			"\x2A\xFFFF";
		private const string DFA5_eofS =
			"\x2A\xFFFF";
		private const string DFA5_minS =
			"\x6\x0\x1\xFFFF\x13\x0\x1\xFFFF\xF\x0";
		private const string DFA5_maxS =
			"\x6\xFFFF\x1\xFFFF\x7\xFFFF\x4\x0\x1\xFFFF\x2\x0\x5\xFFFF\x1\xFFFF\x1"+
			"\x0\x6\xFFFF\x4\x0\x1\xFFFF\x3\x0";
		private const string DFA5_acceptS =
			"\x6\xFFFF\x1\x2\x13\xFFFF\x1\x1\xF\xFFFF";
		private const string DFA5_specialS =
			"\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\xFFFF\x1\x6\x1\x7\x1\x8\x1\x9"+
			"\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1\x13\x1\x14"+
			"\x1\x15\x1\x16\x1\x17\x1\x18\x1\xFFFF\x1\x19\x1\x1A\x1\x1B\x1\x1C\x1"+
			"\x1D\x1\x1E\x1\x1F\x1\x20\x1\x21\x1\x22\x1\x23\x1\x24\x1\x25\x1\x26\x1"+
			"\x27}>";
		private static readonly string[] DFA5_transitionS =
			{
				"\x9\x6\x1\x2\x1\x4\x2\x6\x1\x3\x12\x6\x1\x1\x20\x6\x1A\x5\x4\x6\x1\x5"+
				"\x1\x6\x1A\x5\xFF85\x6",
				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
				"\xA\x6\x1\x7\x36\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
				"\x9\x6\x1\xA\x1\xC\x2\x6\x1\xB\x12\x6\x1\x9\xB\x6\x1\xD\x2\x6\xB\x8"+
				"\x7\x6\x1A\x8\x4\x6\x1\x8\x1\x6\x1A\x8\x1\x6\x1\xE\xFF83\x6",
				"",
				"\x41\x6\x1A\x5\x4\x6\x1\x5\x1\x6\x1A\x5\xFF85\x6",
				"\x9\x6\x1\xA\x1\xC\x2\x6\x1\xB\x12\x6\x1\x9\xB\x6\x1\xD\x2\x6\xB\x8"+
				"\x7\x6\x1A\x8\x4\x6\x1\x8\x1\x6\x1A\x8\x1\x6\x1\xF\xFF83\x6",
				"\x2C\x6\x1\xD\x4F\x6\x1\x10\xFF83\x6",
				"\x2C\x6\x1\xD\x4F\x6\x1\x11\xFF83\x6",
				"\xA\x6\x1\x12\x21\x6\x1\xD\x4F\x6\x1\x13\xFF83\x6",
				"\x2C\x6\x1\xD\x4F\x6\x1\x14\xFF83\x6",
				"\x9\x6\x1\x16\x1\x18\x2\x6\x1\x17\x12\x6\x1\x15\x20\x6\x1A\x19\x4\x6"+
				"\x1\x19\x1\x6\x1A\x19\xFF85\x6",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x2C\x6\x1\xD\x4F\x6\x1\x1B\xFF83\x6",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x41\x6\x1A\x19\x4\x6\x1\x19\x1\x6\x1A\x19\xFF85\x6",
				"\x41\x6\x1A\x19\x4\x6\x1\x19\x1\x6\x1A\x19\xFF85\x6",
				"\xA\x6\x1\x1C\x36\x6\x1A\x19\x4\x6\x1\x19\x1\x6\x1A\x19\xFF85\x6",
				"\x41\x6\x1A\x19\x4\x6\x1\x19\x1\x6\x1A\x19\xFF85\x6",
				"\x9\x6\x1\x1F\x1\x21\x2\x6\x1\x20\x12\x6\x1\x1E\xB\x6\x1\xD\x2\x6\xB"+
				"\x1D\x7\x6\x1A\x1D\x4\x6\x1\x1D\x1\x6\x1A\x1D\x1\x6\x1\x22\xFF83\x6",
				"",
				"\x1\xFFFF",
				"\x41\x6\x1A\x19\x4\x6\x1\x19\x1\x6\x1A\x19\xFF85\x6",
				"\x9\x6\x1\x1F\x1\x21\x2\x6\x1\x20\x12\x6\x1\x1E\xB\x6\x1\xD\x2\x6\xB"+
				"\x1D\x7\x6\x1A\x1D\x4\x6\x1\x1D\x1\x6\x1A\x1D\x1\x6\x1\x23\xFF83\x6",
				"\x2C\x6\x1\xD\x4F\x6\x1\x24\xFF83\x6",
				"\x2C\x6\x1\xD\x4F\x6\x1\x25\xFF83\x6",
				"\xA\x6\x1\x26\x21\x6\x1\xD\x4F\x6\x1\x27\xFF83\x6",
				"\x2C\x6\x1\xD\x4F\x6\x1\x28\xFF83\x6",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x2C\x6\x1\xD\x4F\x6\x1\x29\xFF83\x6",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF"
			};

		private static readonly short[] DFA5_eot = DFA.UnpackEncodedString(DFA5_eotS);
		private static readonly short[] DFA5_eof = DFA.UnpackEncodedString(DFA5_eofS);
		private static readonly char[] DFA5_min = DFA.UnpackEncodedStringToUnsignedChars(DFA5_minS);
		private static readonly char[] DFA5_max = DFA.UnpackEncodedStringToUnsignedChars(DFA5_maxS);
		private static readonly short[] DFA5_accept = DFA.UnpackEncodedString(DFA5_acceptS);
		private static readonly short[] DFA5_special = DFA.UnpackEncodedString(DFA5_specialS);
		private static readonly short[][] DFA5_transition;

		static DFA5()
		{
			int numStates = DFA5_transitionS.Length;
			DFA5_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA5_transition[i] = DFA.UnpackEncodedString(DFA5_transitionS[i]);
			}
		}

		public DFA5( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 5;
			this.eot = DFA5_eot;
			this.eof = DFA5_eof;
			this.min = DFA5_min;
			this.max = DFA5_max;
			this.accept = DFA5_accept;
			this.special = DFA5_special;
			this.transition = DFA5_transition;
		}

		public override string Description { get { return "289:3: ( ( ( WS_CHAR )? ID )=> TEMPLATE_ARGS[out subtext, args] ( ( WS_CHAR )=> WS_CHAR )? |)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition5(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA5_1 = input.LA(1);
		int index5_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				if ((LA5_1==' ')) {s = 1;}

				else if ((LA5_1=='\t')) {s = 2;}

				else if ((LA5_1=='\r')) {s = 3;}

				else if ((LA5_1=='\n')) {s = 4;}

				else if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 5;}

				else if (((LA5_1>='\u0000' && LA5_1<='\b')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\u001F')||(LA5_1>='!' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 1:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 5;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 2:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 5;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 3:
			{
				if ((LA5_1=='\n')) {s = 7;}

				else if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 5;}

				else if (((LA5_1>='\u0000' && LA5_1<='\t')||(LA5_1>='\u000B' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 4:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 5;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 5:
			{
				if (((LA5_1>='/' && LA5_1<='9')||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 8;}

				else if ((LA5_1==' ')) {s = 9;}

				else if ((LA5_1=='\t')) {s = 10;}

				else if ((LA5_1=='\r')) {s = 11;}

				else if ((LA5_1=='\n')) {s = 12;}

				else if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 14;}

				else if (((LA5_1>='\u0000' && LA5_1<='\b')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\u001F')||(LA5_1>='!' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='.')||(LA5_1>=':' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||LA5_1=='{'||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 6:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 5;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 7:
			{
				if ((LA5_1==' ')) {s = 9;}

				else if ((LA5_1=='\t')) {s = 10;}

				else if ((LA5_1=='\r')) {s = 11;}

				else if ((LA5_1=='\n')) {s = 12;}

				else if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 15;}

				else if (((LA5_1>='/' && LA5_1<='9')||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 8;}

				else if (((LA5_1>='\u0000' && LA5_1<='\b')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\u001F')||(LA5_1>='!' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='.')||(LA5_1>=':' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||LA5_1=='{'||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 8:
			{
				if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 16;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 9:
			{
				if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 17;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 10:
			{
				if ((LA5_1=='\n')) {s = 18;}

				else if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 19;}

				else if (((LA5_1>='\u0000' && LA5_1<='\t')||(LA5_1>='\u000B' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 11:
			{
				if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 20;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 12:
			{
				if ((LA5_1==' ')) {s = 21;}

				else if ((LA5_1=='\t')) {s = 22;}

				else if ((LA5_1=='\r')) {s = 23;}

				else if ((LA5_1=='\n')) {s = 24;}

				else if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 25;}

				else if (((LA5_1>='\u0000' && LA5_1<='\b')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\u001F')||(LA5_1>='!' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 13:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 14:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 15:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 16:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 17:
			{
				if ((LA5_1==',')) {s = 13;}

				else if ((LA5_1=='|')) {s = 27;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 18:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 19:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 20:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 25;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 21:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 25;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 22:
			{
				if ((LA5_1=='\n')) {s = 28;}

				else if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 25;}

				else if (((LA5_1>='\u0000' && LA5_1<='\t')||(LA5_1>='\u000B' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 23:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 25;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 24:
			{
				if (((LA5_1>='/' && LA5_1<='9')||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 29;}

				else if ((LA5_1==' ')) {s = 30;}

				else if ((LA5_1=='\t')) {s = 31;}

				else if ((LA5_1=='\r')) {s = 32;}

				else if ((LA5_1=='\n')) {s = 33;}

				else if ((LA5_1=='|')) {s = 34;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='\u0000' && LA5_1<='\b')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\u001F')||(LA5_1>='!' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='.')||(LA5_1>=':' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||LA5_1=='{'||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 25:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 26:
			{
				if (((LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 25;}

				else if (((LA5_1>='\u0000' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||(LA5_1>='{' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 27:
			{
				if ((LA5_1==' ')) {s = 30;}

				else if ((LA5_1=='\t')) {s = 31;}

				else if ((LA5_1=='\r')) {s = 32;}

				else if ((LA5_1=='\n')) {s = 33;}

				else if ((LA5_1=='|')) {s = 35;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='/' && LA5_1<='9')||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z'))) {s = 29;}

				else if (((LA5_1>='\u0000' && LA5_1<='\b')||(LA5_1>='\u000B' && LA5_1<='\f')||(LA5_1>='\u000E' && LA5_1<='\u001F')||(LA5_1>='!' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='.')||(LA5_1>=':' && LA5_1<='@')||(LA5_1>='[' && LA5_1<='^')||LA5_1=='`'||LA5_1=='{'||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 28:
			{
				if ((LA5_1=='|')) {s = 36;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 29:
			{
				if ((LA5_1=='|')) {s = 37;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 30:
			{
				if ((LA5_1=='\n')) {s = 38;}

				else if ((LA5_1=='|')) {s = 39;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='\u0000' && LA5_1<='\t')||(LA5_1>='\u000B' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 31:
			{
				if ((LA5_1=='|')) {s = 40;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 32:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 33:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 34:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 35:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 36:
			{
				if ((LA5_1=='|')) {s = 41;}

				else if ((LA5_1==',')) {s = 13;}

				else if (((LA5_1>='\u0000' && LA5_1<='+')||(LA5_1>='-' && LA5_1<='{')||(LA5_1>='}' && LA5_1<='\uFFFF'))) {s = 6;}

				break;
			}
		case 37:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 38:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}
		case 39:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred1_Action_fragment))) {s = 26;}

				else if ((true)) {s = 6;}

				input.Seek(index5_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 5, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA18 : DFA
	{
		private const string DFA18_eotS =
			"\x1\xFFFF\x7\x8\x9\xFFFF\x1\x22\x6\xFFFF\x1\x23\x8\x8\x3\xFFFF\xA\x8"+
			"\x1\x36\x1\x8\x1\x38\x4\x8\x1\x3D\x1\xFFFF\x1\x8\x1\xFFFF\x1\x3F\x1\x40"+
			"\x1\x41\x1\x42\x1\xFFFF\x1\x43\x5\xFFFF";
		private const string DFA18_eofS =
			"\x44\xFFFF";
		private const string DFA18_minS =
			"\x1\x9\x1\x66\x1\x6C\x1\x69\x1\x61\x1\x65\x1\x74\x1\x72\x9\xFFFF\x1\x2E"+
			"\x6\xFFFF\x1\x2F\x1\x73\x1\x72\x1\x73\x1\x6E\x1\x73\x1\x72\x1\x70\x1"+
			"\x75\x3\xFFFF\x1\x65\x1\x73\x1\x74\x1\x67\x1\x74\x1\x69\x1\x65\x1\x6E"+
			"\x1\x69\x1\x74\x1\x2F\x1\x74\x1\x2F\x1\x70\x1\x72\x1\x63\x1\x66\x1\x2F"+
			"\x1\xFFFF\x1\x68\x1\xFFFF\x4\x2F\x1\xFFFF\x1\x2F\x5\xFFFF";
		private const string DFA18_maxS =
			"\x1\x7B\x1\x66\x1\x6C\x1\x69\x2\x65\x1\x75\x1\x72\x9\xFFFF\x1\x2E\x6"+
			"\xFFFF\x1\x7A\x1\x73\x1\x72\x1\x73\x1\x6E\x1\x73\x1\x72\x1\x70\x1\x75"+
			"\x3\xFFFF\x1\x65\x1\x73\x1\x74\x1\x67\x1\x74\x1\x69\x1\x65\x1\x6E\x1"+
			"\x69\x1\x74\x1\x7A\x1\x74\x1\x7A\x1\x70\x1\x72\x1\x63\x1\x66\x1\x7A\x1"+
			"\xFFFF\x1\x68\x1\xFFFF\x4\x7A\x1\xFFFF\x1\x7A\x5\xFFFF";
		private const string DFA18_acceptS =
			"\x8\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12\x1"+
			"\xFFFF\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x1A\x9\xFFFF\x1\x19\x1\x13"+
			"\x1\x1\x12\xFFFF\x1\x4\x1\xFFFF\x1\x6\x4\xFFFF\x1\x3\x1\xFFFF\x1\x7\x1"+
			"\x8\x1\x9\x1\x2\x1\x5";
		private const string DFA18_specialS =
			"\x44\xFFFF}>";
		private static readonly string[] DFA18_transitionS =
			{
				"\x2\x17\x2\xFFFF\x1\x17\x12\xFFFF\x1\x17\x1\x16\x1\xA\x5\xFFFF\x1\xE"+
				"\x1\xF\x1\xFFFF\x1\x14\x1\x10\x1\xFFFF\x1\x11\x1\xFFFF\xA\x9\x1\x13"+
				"\x1\x15\x1\xFFFF\x1\x12\x3\xFFFF\x1A\x8\x1\xC\x1\xFFFF\x1\xD\x1\xFFFF"+
				"\x1\x8\x1\xFFFF\x4\x8\x1\x2\x1\x3\x2\x8\x1\x1\x2\x8\x1\x4\x5\x8\x1\x5"+
				"\x1\x6\x1\x7\x6\x8\x1\xB",
				"\x1\x18",
				"\x1\x19",
				"\x1\x1A",
				"\x1\x1B\x3\xFFFF\x1\x1C",
				"\x1\x1D",
				"\x1\x1E\x1\x1F",
				"\x1\x20",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x21",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"\x1\x24",
				"\x1\x25",
				"\x1\x26",
				"\x1\x27",
				"\x1\x28",
				"\x1\x29",
				"\x1\x2A",
				"\x1\x2B",
				"",
				"",
				"",
				"\x1\x2C",
				"\x1\x2D",
				"\x1\x2E",
				"\x1\x2F",
				"\x1\x30",
				"\x1\x31",
				"\x1\x32",
				"\x1\x33",
				"\x1\x34",
				"\x1\x35",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"\x1\x37",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"\x1\x39",
				"\x1\x3A",
				"\x1\x3B",
				"\x1\x3C",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"",
				"\x1\x3E",
				"",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"",
				"\xB\x8\x7\xFFFF\x1A\x8\x4\xFFFF\x1\x8\x1\xFFFF\x1A\x8",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA18_eot = DFA.UnpackEncodedString(DFA18_eotS);
		private static readonly short[] DFA18_eof = DFA.UnpackEncodedString(DFA18_eofS);
		private static readonly char[] DFA18_min = DFA.UnpackEncodedStringToUnsignedChars(DFA18_minS);
		private static readonly char[] DFA18_max = DFA.UnpackEncodedStringToUnsignedChars(DFA18_maxS);
		private static readonly short[] DFA18_accept = DFA.UnpackEncodedString(DFA18_acceptS);
		private static readonly short[] DFA18_special = DFA.UnpackEncodedString(DFA18_specialS);
		private static readonly short[][] DFA18_transition;

		static DFA18()
		{
			int numStates = DFA18_transitionS.Length;
			DFA18_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA18_transition[i] = DFA.UnpackEncodedString(DFA18_transitionS[i]);
			}
		}

		public DFA18( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 18;
			this.eot = DFA18_eot;
			this.eof = DFA18_eof;
			this.min = DFA18_min;
			this.max = DFA18_max;
			this.accept = DFA18_accept;
			this.special = DFA18_special;
			this.transition = DFA18_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( CONDITIONAL | ELSEIF | FIRST | LAST | LENGTH | REST | STRIP | SUPER | TRUNC | ID | INT | STRING | ANONYMOUS_TEMPLATE | LBRACK | RBRACK | LPAREN | RPAREN | COMMA | DOT | ASSIGN | COLON | PLUS | SEMI | NOT | DOTDOTDOT | WS );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion

}

} // namespace  Antlr3.ST.Language 
