//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Language\\Group.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.ST.Language
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class GroupParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "ASSIGN", "AT", "BIGSTRING", "COLON", "COMMA", "DEFINED_TO_BE", "DOT", "ID", "KWDEFAULT", "KWGROUP", "KWIMPLEMENTS", "LBRACK", "LPAREN", "ML_COMMENT", "OPTIONAL", "PLUS", "RBRACK", "RPAREN", "SEMI", "SL_COMMENT", "STAR", "STRING", "WS"
	};
	public const int EOF=-1;
	public const int ANONYMOUS_TEMPLATE=4;
	public const int ASSIGN=5;
	public const int AT=6;
	public const int BIGSTRING=7;
	public const int COLON=8;
	public const int COMMA=9;
	public const int DEFINED_TO_BE=10;
	public const int DOT=11;
	public const int ID=12;
	public const int KWDEFAULT=13;
	public const int KWGROUP=14;
	public const int KWIMPLEMENTS=15;
	public const int LBRACK=16;
	public const int LPAREN=17;
	public const int ML_COMMENT=18;
	public const int OPTIONAL=19;
	public const int PLUS=20;
	public const int RBRACK=21;
	public const int RPAREN=22;
	public const int SEMI=23;
	public const int SL_COMMENT=24;
	public const int STAR=25;
	public const int STRING=26;
	public const int WS=27;

	public GroupParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public GroupParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return GroupParser.tokenNames; } }
	public override string GrammarFileName { get { return "Language\\Group.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_group();
	partial void LeaveRule_group();
	// $ANTLR start "group"
	// Language\\Group.g3:50:1: public group[StringTemplateGroup g] : 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF ;
	[GrammarRule("group")]
	public void group(StringTemplateGroup g)
	{
		EnterRule_group();
		EnterRule("group", 1);
		TraceIn("group", 1);
		IToken name = default(IToken);
		IToken s = default(IToken);
		IToken i = default(IToken);
		IToken i2 = default(IToken);


		this._group = g;

		try { DebugEnterRule(GrammarFileName, "group");
		DebugLocation(50, 1);
		try
		{
			// Language\\Group.g3:55:2: ( 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF )
			DebugEnterAlt(1);
			// Language\\Group.g3:55:4: 'group' name= ID ( COLON s= ID )? ( 'implements' i= ID ( COMMA i2= ID )* )? SEMI ( template[g] | mapdef[g] )+ EOF
			{
			DebugLocation(55, 4);
			Match(input,KWGROUP,Follow._KWGROUP_in_group75); 
			DebugLocation(55, 16);
			name=(IToken)Match(input,ID,Follow._ID_in_group79); 
			DebugLocation(55, 20);
			g.Name = (name!=null?name.Text:default(string));
			DebugLocation(56, 3);
			// Language\\Group.g3:56:3: ( COLON s= ID )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==COLON))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Group.g3:56:5: COLON s= ID
				{
				DebugLocation(56, 5);
				Match(input,COLON,Follow._COLON_in_group87); 
				DebugLocation(56, 12);
				s=(IToken)Match(input,ID,Follow._ID_in_group91); 
				DebugLocation(56, 16);
				g.SetSuperGroup((s!=null?s.Text:default(string)));

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(57, 3);
			// Language\\Group.g3:57:3: ( 'implements' i= ID ( COMMA i2= ID )* )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==KWIMPLEMENTS))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Group.g3:57:5: 'implements' i= ID ( COMMA i2= ID )*
				{
				DebugLocation(57, 5);
				Match(input,KWIMPLEMENTS,Follow._KWIMPLEMENTS_in_group102); 
				DebugLocation(57, 19);
				i=(IToken)Match(input,ID,Follow._ID_in_group106); 
				DebugLocation(57, 23);
				g.ImplementInterface((i!=null?i.Text:default(string)));
				DebugLocation(58, 4);
				// Language\\Group.g3:58:4: ( COMMA i2= ID )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if ((LA2_1==COMMA))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Group.g3:58:5: COMMA i2= ID
						{
						DebugLocation(58, 5);
						Match(input,COMMA,Follow._COMMA_in_group114); 
						DebugLocation(58, 13);
						i2=(IToken)Match(input,ID,Follow._ID_in_group118); 
						DebugLocation(58, 17);
						g.ImplementInterface((i2!=null?i2.Text:default(string)));

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }


				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(60, 3);
			Match(input,SEMI,Follow._SEMI_in_group132); 
			DebugLocation(61, 3);
			// Language\\Group.g3:61:3: ( template[g] | mapdef[g] )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=3;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==AT))
				{
					alt4 = 1;
				}
				else if ((LA4_1==ID))
				{
					int LA4_2 = input.LA(2);

					if ((LA4_2==DEFINED_TO_BE))
					{
						int LA4_3 = input.LA(3);

						if ((LA4_3==ID))
						{
							alt4 = 1;
						}
						else if ((LA4_3==LBRACK))
						{
							alt4 = 2;
						}


					}
					else if ((LA4_2==LPAREN))
					{
						alt4 = 1;
					}


				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Group.g3:61:5: template[g]
					{
					DebugLocation(61, 5);
					PushFollow(Follow._template_in_group138);
					template(g);
					PopFollow();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Group.g3:61:19: mapdef[g]
					{
					DebugLocation(61, 19);
					PushFollow(Follow._mapdef_in_group143);
					mapdef(g);
					PopFollow();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(62, 3);
			Match(input,EOF,Follow._EOF_in_group151); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("group", 1);
			LeaveRule("group", 1);
			LeaveRule_group();
		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "group"); }
		return;

	}
	// $ANTLR end "group"

	partial void EnterRule_template();
	partial void LeaveRule_template();
	// $ANTLR start "template"
	// Language\\Group.g3:65:1: template[StringTemplateGroup g] : ( ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING ) |alias= ID DEFINED_TO_BE target= ID );
	[GrammarRule("template")]
	private void template(StringTemplateGroup g)
	{
		EnterRule_template();
		EnterRule("template", 2);
		TraceIn("template", 2);
		IToken scope2 = default(IToken);
		IToken region = default(IToken);
		IToken name = default(IToken);
		IToken t = default(IToken);
		IToken bt = default(IToken);
		IToken alias = default(IToken);
		IToken target = default(IToken);


			StringTemplate st = null;
			string templateName=null;
			int line = input.LT(1).Line;

		try { DebugEnterRule(GrammarFileName, "template");
		DebugLocation(65, 1);
		try
		{
			// Language\\Group.g3:72:2: ( ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING ) |alias= ID DEFINED_TO_BE target= ID )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==AT))
			{
				alt8 = 1;
			}
			else if ((LA8_1==ID))
			{
				int LA8_2 = input.LA(2);

				if ((LA8_2==DEFINED_TO_BE))
				{
					alt8 = 2;
				}
				else if ((LA8_2==LPAREN))
				{
					alt8 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Group.g3:72:4: ( AT scope2= ID DOT region= ID |name= ID ) LPAREN ( args[st] |) RPAREN DEFINED_TO_BE (t= STRING |bt= BIGSTRING )
				{
				DebugLocation(72, 4);
				// Language\\Group.g3:72:4: ( AT scope2= ID DOT region= ID |name= ID )
				int alt5=2;
				try { DebugEnterSubRule(5);
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==AT))
				{
					alt5 = 1;
				}
				else if ((LA5_1==ID))
				{
					alt5 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Group.g3:72:6: AT scope2= ID DOT region= ID
					{
					DebugLocation(72, 6);
					Match(input,AT,Follow._AT_in_template170); 
					DebugLocation(72, 15);
					scope2=(IToken)Match(input,ID,Follow._ID_in_template174); 
					DebugLocation(72, 19);
					Match(input,DOT,Follow._DOT_in_template176); 
					DebugLocation(72, 29);
					region=(IToken)Match(input,ID,Follow._ID_in_template180); 
					DebugLocation(73, 4);

									templateName = g.GetMangledRegionName((scope2!=null?scope2.Text:default(string)),(region!=null?region.Text:default(string)));
									if ( g.IsDefinedInThisGroup(templateName) )
									{
										g.Error("group "+g.Name+" line "+line+": redefinition of template region: @"+
											(scope2!=null?scope2.Text:default(string))+"."+(region!=null?region.Text:default(string)));
										st = new StringTemplate(); // create bogus template to fill in
									}
									else
									{
										bool err = false;
										// @template.region() ::= "..."
										StringTemplate scopeST = g.LookupTemplate((scope2!=null?scope2.Text:default(string)));
										if ( scopeST == null )
										{
											g.Error("group "+g.Name+" line "+line+": reference to region within undefined template: "+
												(scope2!=null?scope2.Text:default(string)));
											err=true;
										}
										else if ( !scopeST.ContainsRegionName((region!=null?region.Text:default(string))) )
										{
											g.Error("group "+g.Name+" line "+line+": template "+(scope2!=null?scope2.Text:default(string))+" has no region called "+
												(region!=null?region.Text:default(string)));
											err=true;
										}
										if ( err )
										{
											st = new StringTemplate();
										}
										else
										{
											st = g.DefineRegionTemplate((scope2!=null?scope2.Text:default(string)),
																		(region!=null?region.Text:default(string)),
																		null,
																		RegionType.Explicit);
										}
									}
								

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Group.g3:111:5: name= ID
					{
					DebugLocation(111, 9);
					name=(IToken)Match(input,ID,Follow._ID_in_template193); 
					DebugLocation(111, 13);
					templateName = (name!=null?name.Text:default(string));
					DebugLocation(112, 4);

									if ( g.IsDefinedInThisGroup(templateName) )
									{
										g.Error("redefinition of template: "+templateName);
										st = new StringTemplate(); // create bogus template to fill in
									}
									else
									{
										st = g.DefineTemplate(templateName, null);
									}
								

					}
					break;

				}
				} finally { DebugExitSubRule(5); }

				DebugLocation(124, 3);
				if ( st!=null ) {st.GroupFileLine = line;}
				DebugLocation(125, 3);
				Match(input,LPAREN,Follow._LPAREN_in_template212); 
				DebugLocation(126, 4);
				// Language\\Group.g3:126:4: ( args[st] |)
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==ID))
				{
					alt6 = 1;
				}
				else if ((LA6_1==RPAREN))
				{
					alt6 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Group.g3:126:5: args[st]
					{
					DebugLocation(126, 5);
					PushFollow(Follow._args_in_template218);
					args(st);
					PopFollow();


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Group.g3:126:14: 
					{
					DebugLocation(126, 14);
					st.DefineEmptyFormalArgumentList();

					}
					break;

				}
				} finally { DebugExitSubRule(6); }

				DebugLocation(127, 3);
				Match(input,RPAREN,Follow._RPAREN_in_template226); 
				DebugLocation(128, 3);
				Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_template230); 
				DebugLocation(129, 3);
				// Language\\Group.g3:129:3: (t= STRING |bt= BIGSTRING )
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==STRING))
				{
					alt7 = 1;
				}
				else if ((LA7_1==BIGSTRING))
				{
					alt7 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Group.g3:129:5: t= STRING
					{
					DebugLocation(129, 6);
					t=(IToken)Match(input,STRING,Follow._STRING_in_template238); 
					DebugLocation(129, 18);
					st.Template = (t!=null?t.Text:default(string));

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Group.g3:130:5: bt= BIGSTRING
					{
					DebugLocation(130, 7);
					bt=(IToken)Match(input,BIGSTRING,Follow._BIGSTRING_in_template252); 
					DebugLocation(130, 18);
					st.Template = (bt!=null?bt.Text:default(string));

					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Group.g3:133:6: alias= ID DEFINED_TO_BE target= ID
				{
				DebugLocation(133, 11);
				alias=(IToken)Match(input,ID,Follow._ID_in_template268); 
				DebugLocation(133, 15);
				Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_template270); 
				DebugLocation(133, 35);
				target=(IToken)Match(input,ID,Follow._ID_in_template274); 
				DebugLocation(134, 3);
				g.DefineTemplateAlias((alias!=null?alias.Text:default(string)), (target!=null?target.Text:default(string)));

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("template", 2);
			LeaveRule("template", 2);
			LeaveRule_template();
		}
		DebugLocation(135, 1);
		} finally { DebugExitRule(GrammarFileName, "template"); }
		return;

	}
	// $ANTLR end "template"

	partial void EnterRule_args();
	partial void LeaveRule_args();
	// $ANTLR start "args"
	// Language\\Group.g3:137:1: args[StringTemplate st] : arg[$st] ( COMMA arg[$st] )* ;
	[GrammarRule("args")]
	private void args(StringTemplate st)
	{
		EnterRule_args();
		EnterRule("args", 3);
		TraceIn("args", 3);
		try { DebugEnterRule(GrammarFileName, "args");
		DebugLocation(137, 1);
		try
		{
			// Language\\Group.g3:138:2: ( arg[$st] ( COMMA arg[$st] )* )
			DebugEnterAlt(1);
			// Language\\Group.g3:138:4: arg[$st] ( COMMA arg[$st] )*
			{
			DebugLocation(138, 4);
			PushFollow(Follow._arg_in_args290);
			arg(st);
			PopFollow();

			DebugLocation(138, 13);
			// Language\\Group.g3:138:13: ( COMMA arg[$st] )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==COMMA))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Group.g3:138:15: COMMA arg[$st]
					{
					DebugLocation(138, 15);
					Match(input,COMMA,Follow._COMMA_in_args295); 
					DebugLocation(138, 21);
					PushFollow(Follow._arg_in_args297);
					arg(st);
					PopFollow();


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("args", 3);
			LeaveRule("args", 3);
			LeaveRule_args();
		}
		DebugLocation(139, 1);
		} finally { DebugExitRule(GrammarFileName, "args"); }
		return;

	}
	// $ANTLR end "args"

	partial void EnterRule_arg();
	partial void LeaveRule_arg();
	// $ANTLR start "arg"
	// Language\\Group.g3:141:1: arg[StringTemplate st] : name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )? ;
	[GrammarRule("arg")]
	private void arg(StringTemplate st)
	{
		EnterRule_arg();
		EnterRule("arg", 4);
		TraceIn("arg", 4);
		IToken name = default(IToken);
		IToken s = default(IToken);
		IToken bs = default(IToken);


			StringTemplate defaultValue = null;

		try { DebugEnterRule(GrammarFileName, "arg");
		DebugLocation(141, 1);
		try
		{
			// Language\\Group.g3:146:2: (name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )? )
			DebugEnterAlt(1);
			// Language\\Group.g3:146:4: name= ID ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )?
			{
			DebugLocation(146, 8);
			name=(IToken)Match(input,ID,Follow._ID_in_arg320); 
			DebugLocation(147, 3);
			// Language\\Group.g3:147:3: ( ASSIGN s= STRING | ASSIGN bs= ANONYMOUS_TEMPLATE )?
			int alt10=3;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==ASSIGN))
			{
				int LA10_2 = input.LA(2);

				if ((LA10_2==STRING))
				{
					alt10 = 1;
				}
				else if ((LA10_2==ANONYMOUS_TEMPLATE))
				{
					alt10 = 2;
				}
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Group.g3:147:5: ASSIGN s= STRING
				{
				DebugLocation(147, 5);
				Match(input,ASSIGN,Follow._ASSIGN_in_arg326); 
				DebugLocation(147, 13);
				s=(IToken)Match(input,STRING,Follow._STRING_in_arg330); 
				DebugLocation(148, 4);

								defaultValue=new StringTemplate("$_val_$");
								defaultValue.SetAttribute("_val_", (s!=null?s.Text:default(string)));
								defaultValue.DefineFormalArgument("_val_");
								defaultValue.Name = "<"+st.Name+"'s arg "+(name!=null?name.Text:default(string))+" default value subtemplate>";
							

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Group.g3:154:5: ASSIGN bs= ANONYMOUS_TEMPLATE
				{
				DebugLocation(154, 5);
				Match(input,ASSIGN,Follow._ASSIGN_in_arg341); 
				DebugLocation(154, 14);
				bs=(IToken)Match(input,ANONYMOUS_TEMPLATE,Follow._ANONYMOUS_TEMPLATE_in_arg345); 
				DebugLocation(155, 4);

								defaultValue=new StringTemplate(st.Group, (bs!=null?bs.Text:default(string)));
								defaultValue.Name = "<"+st.Name+"'s arg "+(name!=null?name.Text:default(string))+" default value subtemplate>";
							

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(160, 3);
			st.DefineFormalArgument((name!=null?name.Text:default(string)), defaultValue);

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arg", 4);
			LeaveRule("arg", 4);
			LeaveRule_arg();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "arg"); }
		return;

	}
	// $ANTLR end "arg"

	partial void EnterRule_mapdef();
	partial void LeaveRule_mapdef();
	// $ANTLR start "mapdef"
	// Language\\Group.g3:163:1: mapdef[StringTemplateGroup g] : name= ID DEFINED_TO_BE m= map ;
	[GrammarRule("mapdef")]
	private void mapdef(StringTemplateGroup g)
	{
		EnterRule_mapdef();
		EnterRule("mapdef", 5);
		TraceIn("mapdef", 5);
		IToken name = default(IToken);
		IDictionary<string, StringTemplate> m = default(IDictionary<string, StringTemplate>);

		try { DebugEnterRule(GrammarFileName, "mapdef");
		DebugLocation(163, 1);
		try
		{
			// Language\\Group.g3:164:2: (name= ID DEFINED_TO_BE m= map )
			DebugEnterAlt(1);
			// Language\\Group.g3:164:4: name= ID DEFINED_TO_BE m= map
			{
			DebugLocation(164, 8);
			name=(IToken)Match(input,ID,Follow._ID_in_mapdef373); 
			DebugLocation(165, 3);
			Match(input,DEFINED_TO_BE,Follow._DEFINED_TO_BE_in_mapdef377); 
			DebugLocation(165, 18);
			PushFollow(Follow._map_in_mapdef381);
			m=map();
			PopFollow();

			DebugLocation(166, 3);

						if ( g.GetMap((name!=null?name.Text:default(string)))!=null )
						{
							g.Error("redefinition of map: "+(name!=null?name.Text:default(string)));
						}
						else if ( g.IsDefinedInThisGroup((name!=null?name.Text:default(string))) )
						{
							g.Error("redefinition of template as map: "+(name!=null?name.Text:default(string)));
						}
						else
						{
							g.DefineMap((name!=null?name.Text:default(string)), m);
						}
					

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mapdef", 5);
			LeaveRule("mapdef", 5);
			LeaveRule_mapdef();
		}
		DebugLocation(180, 1);
		} finally { DebugExitRule(GrammarFileName, "mapdef"); }
		return;

	}
	// $ANTLR end "mapdef"

	partial void EnterRule_map();
	partial void LeaveRule_map();
	// $ANTLR start "map"
	// Language\\Group.g3:182:1: map returns [IDictionary<string, StringTemplate> mapping = new Dictionary<string, StringTemplate>()] : LBRACK mapPairs[mapping] RBRACK ;
	[GrammarRule("map")]
	private IDictionary<string, StringTemplate> map()
	{
		EnterRule_map();
		EnterRule("map", 6);
		TraceIn("map", 6);
		IDictionary<string, StringTemplate> mapping =  new Dictionary<string, StringTemplate>();


		try { DebugEnterRule(GrammarFileName, "map");
		DebugLocation(182, 1);
		try
		{
			// Language\\Group.g3:183:2: ( LBRACK mapPairs[mapping] RBRACK )
			DebugEnterAlt(1);
			// Language\\Group.g3:183:6: LBRACK mapPairs[mapping] RBRACK
			{
			DebugLocation(183, 6);
			Match(input,LBRACK,Follow._LBRACK_in_map402); 
			DebugLocation(183, 13);
			PushFollow(Follow._mapPairs_in_map404);
			mapPairs(mapping);
			PopFollow();

			DebugLocation(183, 31);
			Match(input,RBRACK,Follow._RBRACK_in_map407); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("map", 6);
			LeaveRule("map", 6);
			LeaveRule_map();
		}
		DebugLocation(184, 1);
		} finally { DebugExitRule(GrammarFileName, "map"); }
		return mapping;

	}
	// $ANTLR end "map"

	partial void EnterRule_mapPairs();
	partial void LeaveRule_mapPairs();
	// $ANTLR start "mapPairs"
	// Language\\Group.g3:186:1: mapPairs[IDictionary<string, StringTemplate> mapping] : ( keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )? | defaultValuePair[mapping] );
	[GrammarRule("mapPairs")]
	private void mapPairs(IDictionary<string, StringTemplate> mapping)
	{
		EnterRule_mapPairs();
		EnterRule("mapPairs", 7);
		TraceIn("mapPairs", 7);
		try { DebugEnterRule(GrammarFileName, "mapPairs");
		DebugLocation(186, 1);
		try
		{
			// Language\\Group.g3:187:2: ( keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )? | defaultValuePair[mapping] )
			int alt13=2;
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==STRING))
			{
				alt13 = 1;
			}
			else if ((LA13_1==KWDEFAULT))
			{
				alt13 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Group.g3:187:4: keyValuePair[mapping] ( COMMA keyValuePair[mapping] )* ( COMMA defaultValuePair[mapping] )?
				{
				DebugLocation(187, 4);
				PushFollow(Follow._keyValuePair_in_mapPairs420);
				keyValuePair(mapping);
				PopFollow();

				DebugLocation(187, 26);
				// Language\\Group.g3:187:26: ( COMMA keyValuePair[mapping] )*
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==COMMA))
					{
						int LA11_2 = input.LA(2);

						if ((LA11_2==STRING))
						{
							alt11 = 1;
						}


					}


					} finally { DebugExitDecision(11); }
					switch ( alt11 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Group.g3:187:27: COMMA keyValuePair[mapping]
						{
						DebugLocation(187, 27);
						Match(input,COMMA,Follow._COMMA_in_mapPairs424); 
						DebugLocation(187, 33);
						PushFollow(Follow._keyValuePair_in_mapPairs426);
						keyValuePair(mapping);
						PopFollow();


						}
						break;

					default:
						goto loop11;
					}
				}

				loop11:
					;

				} finally { DebugExitSubRule(11); }

				DebugLocation(188, 3);
				// Language\\Group.g3:188:3: ( COMMA defaultValuePair[mapping] )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==COMMA))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Group.g3:188:4: COMMA defaultValuePair[mapping]
					{
					DebugLocation(188, 4);
					Match(input,COMMA,Follow._COMMA_in_mapPairs434); 
					DebugLocation(188, 10);
					PushFollow(Follow._defaultValuePair_in_mapPairs436);
					defaultValuePair(mapping);
					PopFollow();


					}
					break;

				}
				} finally { DebugExitSubRule(12); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Group.g3:189:4: defaultValuePair[mapping]
				{
				DebugLocation(189, 4);
				PushFollow(Follow._defaultValuePair_in_mapPairs444);
				defaultValuePair(mapping);
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mapPairs", 7);
			LeaveRule("mapPairs", 7);
			LeaveRule_mapPairs();
		}
		DebugLocation(190, 1);
		} finally { DebugExitRule(GrammarFileName, "mapPairs"); }
		return;

	}
	// $ANTLR end "mapPairs"

	partial void EnterRule_defaultValuePair();
	partial void LeaveRule_defaultValuePair();
	// $ANTLR start "defaultValuePair"
	// Language\\Group.g3:192:1: defaultValuePair[IDictionary<string, StringTemplate> mapping] : 'default' COLON v= keyValue ;
	[GrammarRule("defaultValuePair")]
	private void defaultValuePair(IDictionary<string, StringTemplate> mapping)
	{
		EnterRule_defaultValuePair();
		EnterRule("defaultValuePair", 8);
		TraceIn("defaultValuePair", 8);
		StringTemplate v = default(StringTemplate);

		try { DebugEnterRule(GrammarFileName, "defaultValuePair");
		DebugLocation(192, 1);
		try
		{
			// Language\\Group.g3:193:2: ( 'default' COLON v= keyValue )
			DebugEnterAlt(1);
			// Language\\Group.g3:193:4: 'default' COLON v= keyValue
			{
			DebugLocation(193, 4);
			Match(input,KWDEFAULT,Follow._KWDEFAULT_in_defaultValuePair458); 
			DebugLocation(193, 14);
			Match(input,COLON,Follow._COLON_in_defaultValuePair460); 
			DebugLocation(193, 21);
			PushFollow(Follow._keyValue_in_defaultValuePair464);
			v=keyValue();
			PopFollow();

			DebugLocation(194, 3);
			mapping[ASTExpr.DefaultMapValueName] = v;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("defaultValuePair", 8);
			LeaveRule("defaultValuePair", 8);
			LeaveRule_defaultValuePair();
		}
		DebugLocation(195, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultValuePair"); }
		return;

	}
	// $ANTLR end "defaultValuePair"

	partial void EnterRule_keyValuePair();
	partial void LeaveRule_keyValuePair();
	// $ANTLR start "keyValuePair"
	// Language\\Group.g3:197:1: keyValuePair[IDictionary<string, StringTemplate> mapping] : key= STRING COLON v= keyValue ;
	[GrammarRule("keyValuePair")]
	private void keyValuePair(IDictionary<string, StringTemplate> mapping)
	{
		EnterRule_keyValuePair();
		EnterRule("keyValuePair", 9);
		TraceIn("keyValuePair", 9);
		IToken key = default(IToken);
		StringTemplate v = default(StringTemplate);

		try { DebugEnterRule(GrammarFileName, "keyValuePair");
		DebugLocation(197, 1);
		try
		{
			// Language\\Group.g3:198:2: (key= STRING COLON v= keyValue )
			DebugEnterAlt(1);
			// Language\\Group.g3:198:4: key= STRING COLON v= keyValue
			{
			DebugLocation(198, 7);
			key=(IToken)Match(input,STRING,Follow._STRING_in_keyValuePair482); 
			DebugLocation(198, 15);
			Match(input,COLON,Follow._COLON_in_keyValuePair484); 
			DebugLocation(198, 22);
			PushFollow(Follow._keyValue_in_keyValuePair488);
			v=keyValue();
			PopFollow();

			DebugLocation(198, 32);
			mapping[(key!=null?key.Text:default(string))] = v;

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("keyValuePair", 9);
			LeaveRule("keyValuePair", 9);
			LeaveRule_keyValuePair();
		}
		DebugLocation(199, 1);
		} finally { DebugExitRule(GrammarFileName, "keyValuePair"); }
		return;

	}
	// $ANTLR end "keyValuePair"

	partial void EnterRule_keyValue();
	partial void LeaveRule_keyValue();
	// $ANTLR start "keyValue"
	// Language\\Group.g3:201:1: keyValue returns [StringTemplate value] : (s1= BIGSTRING |s2= STRING |k= ID {...}?|);
	[GrammarRule("keyValue")]
	private StringTemplate keyValue()
	{
		EnterRule_keyValue();
		EnterRule("keyValue", 10);
		TraceIn("keyValue", 10);
		StringTemplate value = default(StringTemplate);


		IToken s1 = default(IToken);
		IToken s2 = default(IToken);
		IToken k = default(IToken);

		try { DebugEnterRule(GrammarFileName, "keyValue");
		DebugLocation(201, 1);
		try
		{
			// Language\\Group.g3:202:2: (s1= BIGSTRING |s2= STRING |k= ID {...}?|)
			int alt14=4;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case BIGSTRING:
				{
				alt14 = 1;
				}
				break;
			case STRING:
				{
				alt14 = 2;
				}
				break;
			case ID:
				{
				alt14 = 3;
				}
				break;
			case COMMA:
			case RBRACK:
				{
				alt14 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Group.g3:202:4: s1= BIGSTRING
				{
				DebugLocation(202, 6);
				s1=(IToken)Match(input,BIGSTRING,Follow._BIGSTRING_in_keyValue507); 
				DebugLocation(202, 17);
				value = new StringTemplate(_group,(s1!=null?s1.Text:default(string)));

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Group.g3:203:4: s2= STRING
				{
				DebugLocation(203, 6);
				s2=(IToken)Match(input,STRING,Follow._STRING_in_keyValue516); 
				DebugLocation(203, 15);
				value = new StringTemplate(_group,(s2!=null?s2.Text:default(string)));

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Group.g3:204:4: k= ID {...}?
				{
				DebugLocation(204, 5);
				k=(IToken)Match(input,ID,Follow._ID_in_keyValue526); 
				DebugLocation(204, 11);
				if (!(((k!=null?k.Text:default(string)) == "key")))
				{
					throw new FailedPredicateException(input, "keyValue", "$k.text == \"key\"");
				}
				DebugLocation(205, 7);
				value = ASTExpr.MapKeyValue;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Group.g3:207:2: 
				{
				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("keyValue", 10);
			LeaveRule("keyValue", 10);
			LeaveRule_keyValue();
		}
		DebugLocation(207, 1);
		} finally { DebugExitRule(GrammarFileName, "keyValue"); }
		return value;

	}
	// $ANTLR end "keyValue"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _KWGROUP_in_group75 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_group79 = new BitSet(new ulong[]{0x808100UL});
		public static readonly BitSet _COLON_in_group87 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_group91 = new BitSet(new ulong[]{0x808000UL});
		public static readonly BitSet _KWIMPLEMENTS_in_group102 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_group106 = new BitSet(new ulong[]{0x800200UL});
		public static readonly BitSet _COMMA_in_group114 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_group118 = new BitSet(new ulong[]{0x800200UL});
		public static readonly BitSet _SEMI_in_group132 = new BitSet(new ulong[]{0x1040UL});
		public static readonly BitSet _template_in_group138 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _mapdef_in_group143 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_group151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AT_in_template170 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_template174 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _DOT_in_template176 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_template180 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _ID_in_template193 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _LPAREN_in_template212 = new BitSet(new ulong[]{0x401000UL});
		public static readonly BitSet _args_in_template218 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _RPAREN_in_template226 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _DEFINED_TO_BE_in_template230 = new BitSet(new ulong[]{0x4000080UL});
		public static readonly BitSet _STRING_in_template238 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIGSTRING_in_template252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_template268 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _DEFINED_TO_BE_in_template270 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ID_in_template274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arg_in_args290 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_args295 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _arg_in_args297 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _ID_in_arg320 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _ASSIGN_in_arg326 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _STRING_in_arg330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_arg341 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ANONYMOUS_TEMPLATE_in_arg345 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_mapdef373 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _DEFINED_TO_BE_in_mapdef377 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _map_in_mapdef381 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_map402 = new BitSet(new ulong[]{0x4002000UL});
		public static readonly BitSet _mapPairs_in_map404 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _RBRACK_in_map407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _keyValuePair_in_mapPairs420 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_mapPairs424 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _keyValuePair_in_mapPairs426 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COMMA_in_mapPairs434 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _defaultValuePair_in_mapPairs436 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _defaultValuePair_in_mapPairs444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _KWDEFAULT_in_defaultValuePair458 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_defaultValuePair460 = new BitSet(new ulong[]{0x4001080UL});
		public static readonly BitSet _keyValue_in_defaultValuePair464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_keyValuePair482 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _COLON_in_keyValuePair484 = new BitSet(new ulong[]{0x4001080UL});
		public static readonly BitSet _keyValue_in_keyValuePair488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BIGSTRING_in_keyValue507 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_keyValue516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_keyValue526 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.ST.Language
