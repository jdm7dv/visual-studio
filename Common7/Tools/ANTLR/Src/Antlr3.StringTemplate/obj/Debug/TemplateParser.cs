//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Language\\Template.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.ST.Language
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class TemplateParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "COMMENT", "ELSE", "ELSEIF", "ENDIF", "ESC", "ESC_CHAR", "EXPR", "HEX", "IF", "IF_EXPR", "INDENT", "LINE_BREAK", "LITERAL", "NESTED_PARENS", "NEWLINE", "REGION_DEF", "REGION_REF", "SUBTEMPLATE", "TEMPLATE"
	};
	public const int EOF=-1;
	public const int ACTION=4;
	public const int COMMENT=5;
	public const int ELSE=6;
	public const int ELSEIF=7;
	public const int ENDIF=8;
	public const int ESC=9;
	public const int ESC_CHAR=10;
	public const int EXPR=11;
	public const int HEX=12;
	public const int IF=13;
	public const int IF_EXPR=14;
	public const int INDENT=15;
	public const int LINE_BREAK=16;
	public const int LITERAL=17;
	public const int NESTED_PARENS=18;
	public const int NEWLINE=19;
	public const int REGION_DEF=20;
	public const int REGION_REF=21;
	public const int SUBTEMPLATE=22;
	public const int TEMPLATE=23;

	public TemplateParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public TemplateParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return TemplateParser.tokenNames; } }
	public override string GrammarFileName { get { return "Language\\Template.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_template();
	partial void LeaveRule_template();
	// $ANTLR start "template"
	// Language\\Template.g3:45:1: public template[StringTemplate self] : (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )? ;
	[GrammarRule("template")]
	public void template(StringTemplate self)
	{
		EnterRule_template();
		EnterRule("template", 1);
		TraceIn("template", 1);
		IToken s = default(IToken);
		IToken nl = default(IToken);


			this.self = self;

		try { DebugEnterRule(GrammarFileName, "template");
		DebugLocation(45, 1);
		try
		{
			// Language\\Template.g3:50:2: ( (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )? )
			DebugEnterAlt(1);
			// Language\\Template.g3:50:4: (s= LITERAL |nl= NEWLINE | action[self] )* ( EOF )?
			{
			DebugLocation(50, 4);
			// Language\\Template.g3:50:4: (s= LITERAL |nl= NEWLINE | action[self] )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=4;
				try { DebugEnterDecision(1, false);
				switch (input.LA(1))
				{
				case LITERAL:
					{
					alt1 = 1;
					}
					break;
				case NEWLINE:
					{
					alt1 = 2;
					}
					break;
				case ACTION:
				case IF:
				case REGION_DEF:
				case REGION_REF:
					{
					alt1 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:50:6: s= LITERAL
					{
					DebugLocation(50, 7);
					s=(IToken)Match(input,LITERAL,Follow._LITERAL_in_template61); 
					DebugLocation(50, 17);
					self.AddChunk(new StringRef(self,(s!=null?s.Text:default(string))));

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:51:5: nl= NEWLINE
					{
					DebugLocation(51, 7);
					nl=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_template72); 
					DebugLocation(52, 4);

									int next = input.LA(1);
									if ( next!=ELSE && next!=ENDIF )
									{
										self.AddChunk(new NewlineRef(self,(nl!=null?nl.Text:default(string))));
									}
								

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:59:5: action[self]
					{
					DebugLocation(59, 5);
					PushFollow(Follow._action_in_template83);
					action(self);
					PopFollow();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(61, 3);
			// Language\\Template.g3:61:3: ( EOF )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_1 = input.LA(1);

			if ((LA2_1==EOF))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:61:3: EOF
				{
				DebugLocation(61, 3);
				Match(input,EOF,Follow._EOF_in_template93); 

				}
				break;

			}
			} finally { DebugExitSubRule(2); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("template", 1);
			LeaveRule("template", 1);
			LeaveRule_template();
		}
		DebugLocation(62, 1);
		} finally { DebugExitRule(GrammarFileName, "template"); }
		return;

	}
	// $ANTLR end "template"

	partial void EnterRule_action();
	partial void LeaveRule_action();
	// $ANTLR start "action"
	// Language\\Template.g3:64:1: action[StringTemplate self] : (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF );
	[GrammarRule("action")]
	private void action(StringTemplate self)
	{
		EnterRule_action();
		EnterRule("action", 2);
		TraceIn("action", 2);
		IToken a = default(IToken);
		IToken i = default(IToken);
		IToken ei = default(IToken);
		IToken rr = default(IToken);
		IToken rd = default(IToken);

		try { DebugEnterRule(GrammarFileName, "action");
		DebugLocation(64, 1);
		try
		{
			// Language\\Template.g3:65:2: (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF )
			int alt5=4;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case ACTION:
				{
				alt5 = 1;
				}
				break;
			case IF:
				{
				alt5 = 2;
				}
				break;
			case REGION_REF:
				{
				alt5 = 3;
				}
				break;
			case REGION_DEF:
				{
				alt5 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:65:4: a= ACTION
				{
				DebugLocation(65, 5);
				a=(IToken)Match(input,ACTION,Follow._ACTION_in_action108); 
				DebugLocation(66, 3);

							string indent = ((ChunkToken)a).Indentation;
							ASTExpr c = self.ParseAction((a!=null?a.Text:default(string)));
							c.Indentation = indent;
							self.AddChunk(c);
						

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Template.g3:73:4: i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF
				{
				DebugLocation(73, 5);
				i=(IToken)Match(input,IF,Follow._IF_in_action120); 
				DebugLocation(74, 3);

							ConditionalExpr c = (ConditionalExpr)self.ParseAction((i!=null?i.Text:default(string)));
							// create and precompile the subtemplate
							StringTemplate subtemplate = new StringTemplate(self.Group, null);
							subtemplate.EnclosingInstance = self;
							subtemplate.Name = (i!=null?i.Text:default(string)) + "_subtemplate";
							self.AddChunk(c);
						
				DebugLocation(83, 3);
				PushFollow(Follow._template_in_action129);
				template(subtemplate);
				PopFollow();

				DebugLocation(83, 25);
				if ( c!=null ) c.Subtemplate = subtemplate;
				DebugLocation(85, 3);
				// Language\\Template.g3:85:3: (ei= ELSEIF template[elseIfSubtemplate] )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_1 = input.LA(1);

					if ((LA3_1==ELSEIF))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:85:5: ei= ELSEIF template[elseIfSubtemplate]
						{
						DebugLocation(85, 7);
						ei=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_action141); 
						DebugLocation(86, 4);

										ASTExpr ec = self.ParseAction((ei!=null?ei.Text:default(string)));
										// create and precompile the subtemplate
										StringTemplate elseIfSubtemplate = new StringTemplate(self.Group, null);
										elseIfSubtemplate.EnclosingInstance = self;
										elseIfSubtemplate.Name = (ei!=null?ei.Text:default(string)) + "_subtemplate";
									
						DebugLocation(94, 4);
						PushFollow(Follow._template_in_action152);
						template(elseIfSubtemplate);
						PopFollow();

						DebugLocation(96, 4);
						if ( c!=null ) c.AddElseIfSubtemplate(ec, elseIfSubtemplate);

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }

				DebugLocation(99, 3);
				// Language\\Template.g3:99:3: ( ELSE template[elseSubtemplate] )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==ELSE))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:99:5: ELSE template[elseSubtemplate]
					{
					DebugLocation(99, 5);
					Match(input,ELSE,Follow._ELSE_in_action171); 
					DebugLocation(100, 4);

									// create and precompile the subtemplate
									StringTemplate elseSubtemplate = new StringTemplate(self.Group, null);
									elseSubtemplate.EnclosingInstance = self;
									elseSubtemplate.Name = "else_subtemplate";
								
					DebugLocation(107, 4);
					PushFollow(Follow._template_in_action182);
					template(elseSubtemplate);
					PopFollow();

					DebugLocation(108, 4);
					if ( c!=null ) c.ElseSubtemplate = elseSubtemplate;

					}
					break;

				}
				} finally { DebugExitSubRule(4); }

				DebugLocation(111, 3);
				Match(input,ENDIF,Follow._ENDIF_in_action198); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Template.g3:113:4: rr= REGION_REF
				{
				DebugLocation(113, 6);
				rr=(IToken)Match(input,REGION_REF,Follow._REGION_REF_in_action206); 
				DebugLocation(114, 3);

							// define implicit template and
							// convert <@r()> to <region__enclosingTemplate__r()>
							string regionName = (rr!=null?rr.Text:default(string));
							string mangledRef = null;
							bool err = false;
							// watch out for <@super.r()>; that does NOT def implicit region
							// convert to <super.region__enclosingTemplate__r()>
							string regionNamePrefix = "super.";
							if ( regionName.StartsWith(regionNamePrefix) )
							{
								//System.Console.Out.WriteLine( "super region ref " + regionName );
								string regionRef = regionName.Substring(regionNamePrefix.Length, regionName.Length - regionNamePrefix.Length);
								string templateScope = self.Group.GetUnMangledTemplateName(self.Name);
								StringTemplate scopeST = self.Group.LookupTemplate(templateScope);
								if ( scopeST==null )
								{
									self.Group.Error("reference to region within undefined template: "+templateScope);
									err=true;
								}
								if ( !scopeST.ContainsRegionName(regionRef) )
								{
									self.Group.Error("template "+templateScope+" has no region called "+regionRef);
									err=true;
								}
								else
								{
									mangledRef = self.Group.GetMangledRegionName(templateScope,regionRef);
									mangledRef = "super."+mangledRef;
								}
							}
							else
							{
								//System.out.println("region ref "+regionName);
								StringTemplate regionST = self.Group.DefineImplicitRegionTemplate(self,regionName);
								mangledRef = regionST.Name;
							}

							if ( !err )
							{
								// treat as regular action: mangled template include
								string indent = ((ChunkToken)rr).Indentation;
								ASTExpr c = self.ParseAction(mangledRef+"()");
								c.Indentation = indent;
								self.AddChunk(c);
							}
						

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Template.g3:162:4: rd= REGION_DEF
				{
				DebugLocation(162, 6);
				rd=(IToken)Match(input,REGION_DEF,Follow._REGION_DEF_in_action218); 
				DebugLocation(163, 3);

							string combinedNameTemplateStr = (rd!=null?rd.Text:default(string));
							int indexOfDefSymbol = combinedNameTemplateStr.IndexOf("::=");
							if ( indexOfDefSymbol>=1 )
							{
								string regionName = combinedNameTemplateStr.Substring(0, indexOfDefSymbol);
								int startIndex = indexOfDefSymbol + 3;
								string template = combinedNameTemplateStr.Substring(startIndex, combinedNameTemplateStr.Length - startIndex);
								StringTemplate regionST = self.Group.DefineRegionTemplate(self,regionName,template,RegionType.Embedded);
								// treat as regular action: mangled template include
								string indent = ((ChunkToken)rd).Indentation;
								ASTExpr c = self.ParseAction(regionST.Name+"()");
								c.Indentation = indent;
								self.AddChunk(c);
							}
							else
							{
								self.Error("embedded region definition screwed up");
							}
						

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("action", 2);
			LeaveRule("action", 2);
			LeaveRule_action();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "action"); }
		return;

	}
	// $ANTLR end "action"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LITERAL_in_template61 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _NEWLINE_in_template72 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _action_in_template83 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_template93 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ACTION_in_action108 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_action120 = new BitSet(new ulong[]{0x3A21D0UL});
		public static readonly BitSet _template_in_action129 = new BitSet(new ulong[]{0x1C0UL});
		public static readonly BitSet _ELSEIF_in_action141 = new BitSet(new ulong[]{0x3A21D0UL});
		public static readonly BitSet _template_in_action152 = new BitSet(new ulong[]{0x1C0UL});
		public static readonly BitSet _ELSE_in_action171 = new BitSet(new ulong[]{0x3A2110UL});
		public static readonly BitSet _template_in_action182 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ENDIF_in_action198 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REGION_REF_in_action206 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REGION_DEF_in_action218 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Antlr3.ST.Language
