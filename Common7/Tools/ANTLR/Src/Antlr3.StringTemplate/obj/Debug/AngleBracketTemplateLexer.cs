//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Language\\AngleBracketTemplateLexer.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.ST.Language
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class AngleBracketTemplateLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ACTION=4;
	public const int COMMENT=5;
	public const int ELSE=6;
	public const int ELSEIF=7;
	public const int ENDIF=8;
	public const int ESC=9;
	public const int ESC_CHAR=10;
	public const int EXPR=11;
	public const int HEX=12;
	public const int IF=13;
	public const int IF_EXPR=14;
	public const int INDENT=15;
	public const int LINE_BREAK=16;
	public const int LITERAL=17;
	public const int NESTED_PARENS=18;
	public const int NEWLINE=19;
	public const int REGION_DEF=20;
	public const int REGION_REF=21;
	public const int SUBTEMPLATE=22;
	public const int TEMPLATE=23;

	// delegates
	// delegators

	private AngleBracketTemplateLexer()
	{
		OnCreated();
	}

	private AngleBracketTemplateLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	private AngleBracketTemplateLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Language\\AngleBracketTemplateLexer.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_NEWLINE();
	partial void LeaveRule_NEWLINE();

	// $ANTLR start "NEWLINE"
	[GrammarRule("NEWLINE")]
	private void mNEWLINE()
	{
		EnterRule_NEWLINE();
		EnterRule("NEWLINE", 1);
		TraceIn("NEWLINE", 1);
		try
		{
			int _type = NEWLINE;
			int _channel = DefaultTokenChannel;
			// Language\\AngleBracketTemplateLexer.g3:44:2: ( ( '\\r' )? '\\n' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:44:4: ( '\\r' )? '\\n'
			{
			DebugLocation(44, 4);
			// Language\\AngleBracketTemplateLexer.g3:44:4: ( '\\r' )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1=='\r'))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:44:5: '\\r'
				{
				DebugLocation(44, 5);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(44, 12);
			Match('\n'); if (state.failed) return;
			DebugLocation(44, 17);
			if (state.backtracking == 0)
			{
				currentIndent=null;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEWLINE", 1);
			LeaveRule("NEWLINE", 1);
			LeaveRule_NEWLINE();
		}
	}
	// $ANTLR end "NEWLINE"

	partial void EnterRule_ACTION();
	partial void LeaveRule_ACTION();

	// $ANTLR start "ACTION"
	[GrammarRule("ACTION")]
	private void mACTION()
	{
		EnterRule_ACTION();
		EnterRule("ACTION", 2);
		TraceIn("ACTION", 2);
		try
		{
			int _type = ACTION;
			int _channel = DefaultTokenChannel;
			CommonToken exp = default(CommonToken);
			int ch = 0;


				int startCol = CharPositionInLine;
				System.Text.StringBuilder buf = null;
				string subtext = string.Empty;
				char uc = '\0';
				System.Text.StringBuilder builder = null;
				bool atLeft = false;
				string t = null;

			// Language\\AngleBracketTemplateLexer.g3:59:2: ( ( LINE_BREAK )=> LINE_BREAK | ( '<\\\\' )=> '<' ( ESC_CHAR[out uc] )+ '>' | ( '<!' )=> COMMENT | ( options {k=1; } : ( '<if' )=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? | ( '<elseif' )=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? | ( '<else' )=> '<else>' ( ( '\\r' )? '\\n' )? | ( '<endif' )=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? | ( '<@' )=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' ) )
			int alt26=4;
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1=='<'))
			{
				int LA26_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_AngleBracketTemplateLexer_fragment)))
				{
					alt26 = 1;
				}
				else if ((EvaluatePredicate(synpred2_AngleBracketTemplateLexer_fragment)))
				{
					alt26 = 2;
				}
				else if ((EvaluatePredicate(synpred3_AngleBracketTemplateLexer_fragment)))
				{
					alt26 = 3;
				}
				else if ((true))
				{
					alt26 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 26, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:59:4: ( LINE_BREAK )=> LINE_BREAK
				{
				DebugLocation(59, 20);
				mLINE_BREAK(); if (state.failed) return;
				DebugLocation(59, 31);
				if (state.backtracking == 0)
				{
					_channel = Hidden;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\AngleBracketTemplateLexer.g3:60:4: ( '<\\\\' )=> '<' ( ESC_CHAR[out uc] )+ '>'
				{
				DebugLocation(62, 3);
				if (state.backtracking == 0)
				{

								buf = new System.Text.StringBuilder();
								uc = '\0';
							
				}
				DebugLocation(66, 3);
				Match('<'); if (state.failed) return;
				DebugLocation(66, 7);
				// Language\\AngleBracketTemplateLexer.g3:66:7: ( ESC_CHAR[out uc] )+
				int cnt2=0;
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if ((LA2_1=='\\'))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:66:8: ESC_CHAR[out uc]
						{
						DebugLocation(66, 8);
						mESC_CHAR(out uc); if (state.failed) return;
						DebugLocation(66, 25);
						if (state.backtracking == 0)
						{
							buf.Append(uc);
						}

						}
						break;

					default:
						if (cnt2 >= 1)
							goto loop2;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee2 = new EarlyExitException( 2, input );
						DebugRecognitionException(eee2);
						throw eee2;
					}
					cnt2++;
				}
				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(66, 46);
				Match('>'); if (state.failed) return;
				DebugLocation(67, 3);
				if (state.backtracking == 0)
				{

								Text = buf.ToString();
								_type = LITERAL;
							
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\AngleBracketTemplateLexer.g3:71:4: ( '<!' )=> COMMENT
				{
				DebugLocation(71, 14);
				mCOMMENT(); if (state.failed) return;
				DebugLocation(71, 22);
				if (state.backtracking == 0)
				{
					_channel = Hidden;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\AngleBracketTemplateLexer.g3:72:4: ( options {k=1; } : ( '<if' )=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? | ( '<elseif' )=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? | ( '<else' )=> '<else>' ( ( '\\r' )? '\\n' )? | ( '<endif' )=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? | ( '<@' )=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
				{
				DebugLocation(72, 4);
				// Language\\AngleBracketTemplateLexer.g3:72:4: ( options {k=1; } : ( '<if' )=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? | ( '<elseif' )=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )? | ( '<else' )=> '<else>' ( ( '\\r' )? '\\n' )? | ( '<endif' )=> '<endif>' ({...}? => ( '\\r' )? '\\n' )? | ( '<@' )=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? ) | '<' EXPR[out subtext] '>' )
				int alt25=6;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1=='<'))
				{
					int LA25_2 = input.LA(2);

					if ((EvaluatePredicate(synpred4_AngleBracketTemplateLexer_fragment)))
					{
						alt25 = 1;
					}
					else if ((EvaluatePredicate(synpred5_AngleBracketTemplateLexer_fragment)))
					{
						alt25 = 2;
					}
					else if ((EvaluatePredicate(synpred6_AngleBracketTemplateLexer_fragment)))
					{
						alt25 = 3;
					}
					else if ((EvaluatePredicate(synpred7_AngleBracketTemplateLexer_fragment)))
					{
						alt25 = 4;
					}
					else if ((EvaluatePredicate(synpred8_AngleBracketTemplateLexer_fragment)))
					{
						alt25 = 5;
					}
					else if ((true))
					{
						alt25 = 6;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 25, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:73:4: ( '<if' )=> '<if' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
					{
					DebugLocation(74, 4);
					Match("<if"); if (state.failed) return;

					DebugLocation(74, 10);
					// Language\\AngleBracketTemplateLexer.g3:74:10: ( ' ' )*
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_1 = input.LA(1);

						if ((LA3_1==' '))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch ( alt3 )
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:74:11: ' '
							{
							DebugLocation(74, 11);
							Match(' '); if (state.failed) return;

							}
							break;

						default:
							goto loop3;
						}
					}

					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(74, 17);
					Match('('); if (state.failed) return;
					DebugLocation(74, 24);
					int expStart175 = CharIndex;
					int expStartLine175 = Line;
					int expStartCharPos175 = CharPositionInLine;
					mIF_EXPR(); if (state.failed) return;
					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart175, CharIndex-1);
					exp.Line = expStartLine175;
					exp.CharPositionInLine = expStartCharPos175;
					DebugLocation(74, 33);
					Match(")>"); if (state.failed) return;

					DebugLocation(75, 4);
					// Language\\AngleBracketTemplateLexer.g3:75:4: ( ( '\\r' )? '\\n' )?
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1=='\n'||LA5_1=='\r'))
					{
						alt5 = 1;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:75:6: ( '\\r' )? '\\n'
						{
						DebugLocation(75, 6);
						// Language\\AngleBracketTemplateLexer.g3:75:6: ( '\\r' )?
						int alt4=2;
						try { DebugEnterSubRule(4);
						try { DebugEnterDecision(4, false);
						int LA4_1 = input.LA(1);

						if ((LA4_1=='\r'))
						{
							alt4 = 1;
						}
						} finally { DebugExitDecision(4); }
						switch (alt4)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:75:7: '\\r'
							{
							DebugLocation(75, 7);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(4); }

						DebugLocation(75, 14);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(5); }

					DebugLocation(76, 4);
					if (state.backtracking == 0)
					{

										Text = "if(" + (exp!=null?exp.Text:default(string)) + ")";
										_type = TemplateParser.IF;
									
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\AngleBracketTemplateLexer.g3:80:5: ( '<elseif' )=> '<elseif' ( ' ' )* '(' exp= IF_EXPR ')>' ( ( '\\r' )? '\\n' )?
					{
					DebugLocation(81, 4);
					Match("<elseif"); if (state.failed) return;

					DebugLocation(81, 14);
					// Language\\AngleBracketTemplateLexer.g3:81:14: ( ' ' )*
					try { DebugEnterSubRule(6);
					while (true)
					{
						int alt6=2;
						try { DebugEnterDecision(6, false);
						int LA6_1 = input.LA(1);

						if ((LA6_1==' '))
						{
							alt6 = 1;
						}


						} finally { DebugExitDecision(6); }
						switch ( alt6 )
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:81:15: ' '
							{
							DebugLocation(81, 15);
							Match(' '); if (state.failed) return;

							}
							break;

						default:
							goto loop6;
						}
					}

					loop6:
						;

					} finally { DebugExitSubRule(6); }

					DebugLocation(81, 21);
					Match('('); if (state.failed) return;
					DebugLocation(81, 28);
					int expStart224 = CharIndex;
					int expStartLine224 = Line;
					int expStartCharPos224 = CharPositionInLine;
					mIF_EXPR(); if (state.failed) return;
					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart224, CharIndex-1);
					exp.Line = expStartLine224;
					exp.CharPositionInLine = expStartCharPos224;
					DebugLocation(81, 37);
					Match(")>"); if (state.failed) return;

					DebugLocation(82, 4);
					// Language\\AngleBracketTemplateLexer.g3:82:4: ( ( '\\r' )? '\\n' )?
					int alt8=2;
					try { DebugEnterSubRule(8);
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1=='\n'||LA8_1=='\r'))
					{
						alt8 = 1;
					}
					} finally { DebugExitDecision(8); }
					switch (alt8)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:82:6: ( '\\r' )? '\\n'
						{
						DebugLocation(82, 6);
						// Language\\AngleBracketTemplateLexer.g3:82:6: ( '\\r' )?
						int alt7=2;
						try { DebugEnterSubRule(7);
						try { DebugEnterDecision(7, false);
						int LA7_1 = input.LA(1);

						if ((LA7_1=='\r'))
						{
							alt7 = 1;
						}
						} finally { DebugExitDecision(7); }
						switch (alt7)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:82:7: '\\r'
							{
							DebugLocation(82, 7);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(7); }

						DebugLocation(82, 14);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(8); }

					DebugLocation(83, 4);
					if (state.backtracking == 0)
					{

										Text = "elseif(" + (exp!=null?exp.Text:default(string)) + ")";
										_type = TemplateParser.ELSEIF;
									
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\AngleBracketTemplateLexer.g3:87:5: ( '<else' )=> '<else>' ( ( '\\r' )? '\\n' )?
					{
					DebugLocation(88, 4);
					Match("<else>"); if (state.failed) return;

					DebugLocation(89, 4);
					// Language\\AngleBracketTemplateLexer.g3:89:4: ( ( '\\r' )? '\\n' )?
					int alt10=2;
					try { DebugEnterSubRule(10);
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1=='\n'||LA10_1=='\r'))
					{
						alt10 = 1;
					}
					} finally { DebugExitDecision(10); }
					switch (alt10)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:89:6: ( '\\r' )? '\\n'
						{
						DebugLocation(89, 6);
						// Language\\AngleBracketTemplateLexer.g3:89:6: ( '\\r' )?
						int alt9=2;
						try { DebugEnterSubRule(9);
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if ((LA9_1=='\r'))
						{
							alt9 = 1;
						}
						} finally { DebugExitDecision(9); }
						switch (alt9)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:89:7: '\\r'
							{
							DebugLocation(89, 7);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(9); }

						DebugLocation(89, 14);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(10); }

					DebugLocation(90, 4);
					if (state.backtracking == 0)
					{

										Text = "else";
										_type = TemplateParser.ELSE;
									
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\AngleBracketTemplateLexer.g3:94:5: ( '<endif' )=> '<endif>' ({...}? => ( '\\r' )? '\\n' )?
					{
					DebugLocation(95, 4);
					Match("<endif>"); if (state.failed) return;

					DebugLocation(96, 4);
					// Language\\AngleBracketTemplateLexer.g3:96:4: ({...}? => ( '\\r' )? '\\n' )?
					int alt12=2;
					try { DebugEnterSubRule(12);
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if ((LA12_1=='\n'||LA12_1=='\r') && ((startCol==0)))
					{
						alt12 = 1;
					}
					} finally { DebugExitDecision(12); }
					switch (alt12)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:96:6: {...}? => ( '\\r' )? '\\n'
						{
						DebugLocation(96, 6);
						if (!((startCol==0)))
						{
							if (state.backtracking>0) {state.failed=true; return;}
							throw new FailedPredicateException(input, "ACTION", "startCol==0");
						}
						DebugLocation(96, 24);
						// Language\\AngleBracketTemplateLexer.g3:96:24: ( '\\r' )?
						int alt11=2;
						try { DebugEnterSubRule(11);
						try { DebugEnterDecision(11, false);
						int LA11_1 = input.LA(1);

						if ((LA11_1=='\r'))
						{
							alt11 = 1;
						}
						} finally { DebugExitDecision(11); }
						switch (alt11)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:96:25: '\\r'
							{
							DebugLocation(96, 25);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(11); }

						DebugLocation(96, 32);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(12); }

					DebugLocation(97, 4);
					if (state.backtracking == 0)
					{

										Text = "endif";
										_type = TemplateParser.ENDIF;
									
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Language\\AngleBracketTemplateLexer.g3:103:4: ( '<@' )=> '<@' (ch=~ ( '>' | '(' ) )+ ( '()>' | '>' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
					{
					DebugLocation(104, 4);
					if (state.backtracking == 0)
					{

										builder = new System.Text.StringBuilder();
									
					}
					DebugLocation(107, 4);
					Match("<@"); if (state.failed) return;

					DebugLocation(108, 4);
					// Language\\AngleBracketTemplateLexer.g3:108:4: (ch=~ ( '>' | '(' ) )+
					int cnt13=0;
					try { DebugEnterSubRule(13);
					while (true)
					{
						int alt13=2;
						try { DebugEnterDecision(13, false);
						int LA13_1 = input.LA(1);

						if (((LA13_1>='\u0000' && LA13_1<='\'')||(LA13_1>=')' && LA13_1<='=')||(LA13_1>='?' && LA13_1<='\uFFFF')))
						{
							alt13 = 1;
						}


						} finally { DebugExitDecision(13); }
						switch (alt13)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:108:6: ch=~ ( '>' | '(' )
							{
							DebugLocation(108, 8);
							ch= input.LA(1);
							input.Consume();
							state.failed=false;
							DebugLocation(108, 20);
							if (state.backtracking == 0)
							{
								builder.Append((char)ch);
							}

							}
							break;

						default:
							if (cnt13 >= 1)
								goto loop13;

							if (state.backtracking>0) {state.failed=true; return;}
							EarlyExitException eee13 = new EarlyExitException( 13, input );
							DebugRecognitionException(eee13);
							throw eee13;
						}
						cnt13++;
					}
					loop13:
						;

					} finally { DebugExitSubRule(13); }

					DebugLocation(109, 4);
					if (state.backtracking == 0)
					{
						 t = builder.ToString(); 
					}
					DebugLocation(110, 4);
					// Language\\AngleBracketTemplateLexer.g3:110:4: ( '()>' | '>' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )? )
					int alt24=2;
					try { DebugEnterSubRule(24);
					try { DebugEnterDecision(24, false);
					int LA24_1 = input.LA(1);

					if ((LA24_1=='('))
					{
						alt24 = 1;
					}
					else if ((LA24_1=='>'))
					{
						alt24 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(24); }
					switch (alt24)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:110:6: '()>'
						{
						DebugLocation(110, 6);
						Match("()>"); if (state.failed) return;

						DebugLocation(111, 5);
						if (state.backtracking == 0)
						{

												_type = TemplateParser.REGION_REF;
											
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\AngleBracketTemplateLexer.g3:114:6: '>' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( '<@end>' | . ) ({...}? => ( '\\r' )? '\\n' )?
						{
						DebugLocation(114, 6);
						Match('>'); if (state.failed) return;
						DebugLocation(115, 5);
						if (state.backtracking == 0)
						{

												_type = TemplateParser.REGION_DEF;
												builder.Append("::=");
											
						}
						DebugLocation(119, 5);
						// Language\\AngleBracketTemplateLexer.g3:119:5: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )?
						int alt15=2;
						try { DebugEnterSubRule(15);
						try { DebugEnterDecision(15, false);
						int LA15_1 = input.LA(1);

						if ((LA15_1=='\r'))
						{
							int LA15_2 = input.LA(2);

							if ((LA15_2=='\n'))
							{
								int LA15_3 = input.LA(3);

								if ((EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)))
								{
									alt15 = 1;
								}
							}
						}
						else if ((LA15_1=='\n'))
						{
							int LA15_2 = input.LA(2);

							if ((EvaluatePredicate(synpred9_AngleBracketTemplateLexer_fragment)))
							{
								alt15 = 1;
							}
						}
						} finally { DebugExitDecision(15); }
						switch (alt15)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:119:7: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
							{
							DebugLocation(119, 22);
							// Language\\AngleBracketTemplateLexer.g3:119:22: ( '\\r' )?
							int alt14=2;
							try { DebugEnterSubRule(14);
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if ((LA14_1=='\r'))
							{
								alt14 = 1;
							}
							} finally { DebugExitDecision(14); }
							switch (alt14)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\AngleBracketTemplateLexer.g3:119:23: '\\r'
								{
								DebugLocation(119, 23);
								Match('\r'); if (state.failed) return;

								}
								break;

							}
							} finally { DebugExitSubRule(14); }

							DebugLocation(119, 30);
							Match('\n'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(15); }

						DebugLocation(120, 5);
						if (state.backtracking == 0)
						{

												atLeft = false;
											
						}
						DebugLocation(123, 5);
						// Language\\AngleBracketTemplateLexer.g3:123:5: ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+
						int cnt18=0;
						try { DebugEnterSubRule(18);
						while (true)
						{
							int alt18=2;
							try { DebugEnterDecision(18, false);
							int LA18_1 = input.LA(1);

							if ((LA18_1=='\r'))
							{
								int LA18_2 = input.LA(2);

								if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}
							else if ((LA18_1=='\n'))
							{
								int LA18_2 = input.LA(2);

								if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}
							else if ((LA18_1=='<'))
							{
								int LA18_2 = input.LA(2);

								if ((LA18_2=='@'))
								{
									int LA18_3 = input.LA(3);

									if ((LA18_3=='e'))
									{
										int LA18_4 = input.LA(4);

										if ((LA18_4=='n'))
										{
											int LA18_5 = input.LA(5);

											if ((LA18_5=='d'))
											{
												int LA18_6 = input.LA(6);

												if ((LA18_6=='>'))
												{
													int LA18_7 = input.LA(7);

													if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
													{
														alt18 = 1;
													}


												}

												else
												{
													alt18 = 1;
												}


											}

											else
											{
												alt18 = 1;
											}


										}

										else
										{
											alt18 = 1;
										}


									}

									else
									{
										alt18 = 1;
									}


								}
								else if ((LA18_2=='\r'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if ((LA18_2=='\n'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if (((LA18_2>='\u0000' && LA18_2<='\t')||(LA18_2>='\u000B' && LA18_2<='\f')||(LA18_2>='\u000E' && LA18_2<='?')||(LA18_2>='A' && LA18_2<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}
							else if (((LA18_1>='\u0000' && LA18_1<='\t')||(LA18_1>='\u000B' && LA18_1<='\f')||(LA18_1>='\u000E' && LA18_1<=';')||(LA18_1>='=' && LA18_1<='\uFFFF')))
							{
								int LA18_2 = input.LA(2);

								if ((LA18_2=='\r'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if ((LA18_2=='\n'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if (((LA18_2>='\u0000' && LA18_2<='\t')||(LA18_2>='\u000B' && LA18_2<='\f')||(LA18_2>='\u000E' && LA18_2<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}


							} finally { DebugExitDecision(18); }
							switch (alt18)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\AngleBracketTemplateLexer.g3:123:7: {...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . )
								{
								DebugLocation(123, 7);
								if (!((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									if (state.backtracking>0) {state.failed=true; return;}
									throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
								}
								DebugLocation(124, 6);
								// Language\\AngleBracketTemplateLexer.g3:124:6: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . )
								int alt17=2;
								try { DebugEnterSubRule(17);
								try { DebugEnterDecision(17, false);
								int LA17_1 = input.LA(1);

								if ((LA17_1=='\r'))
								{
									int LA17_2 = input.LA(2);

									if ((EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)))
									{
										alt17 = 1;
									}
									else if ((true))
									{
										alt17 = 2;
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return;}
										NoViableAltException nvae = new NoViableAltException("", 17, 1, input, 2);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else if ((LA17_1=='\n'))
								{
									int LA17_2 = input.LA(2);

									if ((EvaluatePredicate(synpred10_AngleBracketTemplateLexer_fragment)))
									{
										alt17 = 1;
									}
									else if ((true))
									{
										alt17 = 2;
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return;}
										NoViableAltException nvae = new NoViableAltException("", 17, 2, input, 2);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else if (((LA17_1>='\u0000' && LA17_1<='\t')||(LA17_1>='\u000B' && LA17_1<='\f')||(LA17_1>='\u000E' && LA17_1<='\uFFFF')))
								{
									alt17 = 2;
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return;}
									NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
									DebugRecognitionException(nvae);
									throw nvae;
								}
								} finally { DebugExitDecision(17); }
								switch (alt17)
								{
								case 1:
									DebugEnterAlt(1);
									// Language\\AngleBracketTemplateLexer.g3:124:8: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
									{
									DebugLocation(124, 23);
									// Language\\AngleBracketTemplateLexer.g3:124:23: ( '\\r' )?
									int alt16=2;
									try { DebugEnterSubRule(16);
									try { DebugEnterDecision(16, false);
									int LA16_1 = input.LA(1);

									if ((LA16_1=='\r'))
									{
										alt16 = 1;
									}
									} finally { DebugExitDecision(16); }
									switch (alt16)
									{
									case 1:
										DebugEnterAlt(1);
										// Language\\AngleBracketTemplateLexer.g3:124:24: '\\r'
										{
										DebugLocation(124, 24);
										Match('\r'); if (state.failed) return;
										DebugLocation(124, 29);
										if (state.backtracking == 0)
										{
											builder.Append('\r');
										}

										}
										break;

									}
									} finally { DebugExitSubRule(16); }

									DebugLocation(124, 55);
									Match('\n'); if (state.failed) return;
									DebugLocation(124, 60);
									if (state.backtracking == 0)
									{
										builder.Append('\n'); atLeft = true;
									}

									}
									break;
								case 2:
									DebugEnterAlt(2);
									// Language\\AngleBracketTemplateLexer.g3:125:8: ch= .
									{
									DebugLocation(125, 10);

									ch = input.LA(1);

									MatchAny(); if (state.failed) return;
									DebugLocation(125, 13);
									if (state.backtracking == 0)
									{
										builder.Append((char)ch); atLeft = false;
									}

									}
									break;

								}
								} finally { DebugExitSubRule(17); }


								}
								break;

							default:
								if (cnt18 >= 1)
									goto loop18;

								if (state.backtracking>0) {state.failed=true; return;}
								EarlyExitException eee18 = new EarlyExitException( 18, input );
								DebugRecognitionException(eee18);
								throw eee18;
							}
							cnt18++;
						}
						loop18:
							;

						} finally { DebugExitSubRule(18); }

						DebugLocation(128, 5);
						// Language\\AngleBracketTemplateLexer.g3:128:5: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )?
						int alt20=2;
						try { DebugEnterSubRule(20);
						try { DebugEnterDecision(20, false);
						int LA20_1 = input.LA(1);

						if ((LA20_1=='\r'))
						{
							int LA20_2 = input.LA(2);

							if ((LA20_2=='\n'))
							{
								int LA20_3 = input.LA(3);

								if ((LA20_3=='<') && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
								{
									alt20 = 1;
								}
								else if (((LA20_3>='\u0000' && LA20_3<=';')||(LA20_3>='=' && LA20_3<='\uFFFF')) && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
								{
									alt20 = 1;
								}
							}
						}
						else if ((LA20_1=='\n'))
						{
							int LA20_2 = input.LA(2);

							if ((LA20_2=='<') && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
							{
								alt20 = 1;
							}
							else if ((LA20_2=='\r'))
							{
								int LA20_3 = input.LA(3);

								if ((EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
								{
									alt20 = 1;
								}
							}
							else if ((LA20_2=='\n'))
							{
								int LA20_3 = input.LA(3);

								if ((EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
								{
									alt20 = 1;
								}
							}
							else if (((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<=';')||(LA20_2>='=' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred11_AngleBracketTemplateLexer_fragment)))
							{
								alt20 = 1;
							}
						}
						} finally { DebugExitDecision(20); }
						switch (alt20)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:128:7: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
							{
							DebugLocation(128, 22);
							// Language\\AngleBracketTemplateLexer.g3:128:22: ( '\\r' )?
							int alt19=2;
							try { DebugEnterSubRule(19);
							try { DebugEnterDecision(19, false);
							int LA19_1 = input.LA(1);

							if ((LA19_1=='\r'))
							{
								alt19 = 1;
							}
							} finally { DebugExitDecision(19); }
							switch (alt19)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\AngleBracketTemplateLexer.g3:128:23: '\\r'
								{
								DebugLocation(128, 23);
								Match('\r'); if (state.failed) return;

								}
								break;

							}
							} finally { DebugExitSubRule(19); }

							DebugLocation(128, 30);
							Match('\n'); if (state.failed) return;
							DebugLocation(128, 35);
							if (state.backtracking == 0)
							{
								atLeft = true;
							}

							}
							break;

						}
						} finally { DebugExitSubRule(20); }

						DebugLocation(129, 5);
						// Language\\AngleBracketTemplateLexer.g3:129:5: ( '<@end>' | . )
						int alt21=2;
						try { DebugEnterSubRule(21);
						try { DebugEnterDecision(21, false);
						int LA21_1 = input.LA(1);

						if ((LA21_1=='<'))
						{
							int LA21_2 = input.LA(2);

							if ((LA21_2=='@'))
							{
								alt21 = 1;
							}
							else
							{
								alt21 = 2;
							}
						}
						else if (((LA21_1>='\u0000' && LA21_1<=';')||(LA21_1>='=' && LA21_1<='\uFFFF')))
						{
							alt21 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(21); }
						switch (alt21)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:129:7: '<@end>'
							{
							DebugLocation(129, 7);
							Match("<@end>"); if (state.failed) return;


							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Language\\AngleBracketTemplateLexer.g3:130:7: .
							{
							DebugLocation(130, 7);
							MatchAny(); if (state.failed) return;
							DebugLocation(130, 9);
							if (state.backtracking == 0)
							{
								self.Error("missing region "+t+" <@end> tag");
							}

							}
							break;

						}
						} finally { DebugExitSubRule(21); }

						DebugLocation(132, 5);
						// Language\\AngleBracketTemplateLexer.g3:132:5: ({...}? => ( '\\r' )? '\\n' )?
						int alt23=2;
						try { DebugEnterSubRule(23);
						try { DebugEnterDecision(23, false);
						int LA23_1 = input.LA(1);

						if ((LA23_1=='\n'||LA23_1=='\r') && ((atLeft)))
						{
							alt23 = 1;
						}
						} finally { DebugExitDecision(23); }
						switch (alt23)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:132:7: {...}? => ( '\\r' )? '\\n'
							{
							DebugLocation(132, 7);
							if (!((atLeft)))
							{
								if (state.backtracking>0) {state.failed=true; return;}
								throw new FailedPredicateException(input, "ACTION", "atLeft");
							}
							DebugLocation(132, 20);
							// Language\\AngleBracketTemplateLexer.g3:132:20: ( '\\r' )?
							int alt22=2;
							try { DebugEnterSubRule(22);
							try { DebugEnterDecision(22, false);
							int LA22_1 = input.LA(1);

							if ((LA22_1=='\r'))
							{
								alt22 = 1;
							}
							} finally { DebugExitDecision(22); }
							switch (alt22)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\AngleBracketTemplateLexer.g3:132:21: '\\r'
								{
								DebugLocation(132, 21);
								Match('\r'); if (state.failed) return;

								}
								break;

							}
							} finally { DebugExitSubRule(22); }

							DebugLocation(132, 28);
							Match('\n'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(23); }


						}
						break;

					}
					} finally { DebugExitSubRule(24); }

					DebugLocation(134, 4);
					if (state.backtracking == 0)
					{

										Text = builder.ToString();
									
					}

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Language\\AngleBracketTemplateLexer.g3:137:5: '<' EXPR[out subtext] '>'
					{
					DebugLocation(137, 5);
					Match('<'); if (state.failed) return;
					DebugLocation(137, 9);
					mEXPR(out subtext); if (state.failed) return;
					DebugLocation(137, 27);
					Match('>'); if (state.failed) return;
					DebugLocation(138, 4);
					if (state.backtracking == 0)
					{
						 Text = subtext; 
					}

					}
					break;

				}
				} finally { DebugExitSubRule(25); }

				DebugLocation(140, 3);
				if (state.backtracking == 0)
				{

								//ChunkToken t = new ChunkToken(_type, Text, currentIndent);
								//state.token = t; //$ setToken(t);
								state.token = new ChunkToken(_type, Text, currentIndent);
							
				}

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ACTION", 2);
			LeaveRule("ACTION", 2);
			LeaveRule_ACTION();
		}
	}
	// $ANTLR end "ACTION"

	partial void EnterRule_LITERAL();
	partial void LeaveRule_LITERAL();

	// $ANTLR start "LITERAL"
	[GrammarRule("LITERAL")]
	private void mLITERAL()
	{
		EnterRule_LITERAL();
		EnterRule("LITERAL", 3);
		TraceIn("LITERAL", 3);
		try
		{
			int _type = LITERAL;
			int _channel = DefaultTokenChannel;
			CommonToken ind = default(CommonToken);
			int ch = 0;


				System.Text.StringBuilder builder = new System.Text.StringBuilder();
				int loopStartIndex = 0;
				int col = 0;

			// Language\\AngleBracketTemplateLexer.g3:154:2: ( ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:154:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
			{
			DebugLocation(154, 4);
			// Language\\AngleBracketTemplateLexer.g3:154:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
			int cnt28=0;
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=4;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1=='\\'))
				{
					alt28 = 1;
				}
				else if ((LA28_1=='\t'||LA28_1==' '))
				{
					alt28 = 2;
				}
				else if (((LA28_1>='\u0000' && LA28_1<='\b')||(LA28_1>='\u000B' && LA28_1<='\f')||(LA28_1>='\u000E' && LA28_1<='\u001F')||(LA28_1>='!' && LA28_1<=';')||(LA28_1>='=' && LA28_1<='[')||(LA28_1>=']' && LA28_1<='\uFFFF')))
				{
					alt28 = 3;
				}


				} finally { DebugExitDecision(28); }
				switch (alt28)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:154:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
					{
					DebugLocation(154, 6);
					// Language\\AngleBracketTemplateLexer.g3:154:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:154:8: '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
					{
					DebugLocation(154, 8);
					Match('\\'); if (state.failed) return;
					DebugLocation(155, 5);
					// Language\\AngleBracketTemplateLexer.g3:155:5: ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
					int alt27=4;
					try { DebugEnterSubRule(27);
					try { DebugEnterDecision(27, false);
					int LA27_1 = input.LA(1);

					if ((LA27_1=='<'))
					{
						alt27 = 1;
					}
					else if ((LA27_1=='>'))
					{
						alt27 = 2;
					}
					else if ((LA27_1=='\\'))
					{
						alt27 = 3;
					}
					else if (((LA27_1>='\u0000' && LA27_1<=';')||LA27_1=='='||(LA27_1>='?' && LA27_1<='[')||(LA27_1>=']' && LA27_1<='\uFFFF')))
					{
						alt27 = 4;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(27); }
					switch (alt27)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:155:7: '<'
						{
						DebugLocation(155, 7);
						Match('<'); if (state.failed) return;
						DebugLocation(155, 11);
						if (state.backtracking == 0)
						{
							 builder.Append('<'); 
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\AngleBracketTemplateLexer.g3:156:7: '>'
						{
						DebugLocation(156, 7);
						Match('>'); if (state.failed) return;
						DebugLocation(156, 11);
						if (state.backtracking == 0)
						{
							 builder.Append('>'); 
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Language\\AngleBracketTemplateLexer.g3:157:7: '\\\\'
						{
						DebugLocation(157, 7);
						Match('\\'); if (state.failed) return;
						DebugLocation(157, 12);
						if (state.backtracking == 0)
						{
							 builder.Append('\\'); 
						}

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// Language\\AngleBracketTemplateLexer.g3:158:7: ch=~ ( '<' | '>' | '\\\\' )
						{
						DebugLocation(158, 9);
						ch= input.LA(1);
						input.Consume();
						state.failed=false;
						DebugLocation(158, 26);
						if (state.backtracking == 0)
						{
							 builder.Append( "\\" + (char)ch ); 
						}

						}
						break;

					}
					} finally { DebugExitSubRule(27); }


					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\AngleBracketTemplateLexer.g3:161:5: ind= INDENT
					{
					DebugLocation(161, 8);
					int indStart690 = CharIndex;
					int indStartLine690 = Line;
					int indStartCharPos690 = CharPositionInLine;
					mINDENT(); if (state.failed) return;
					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart690, CharIndex-1);
					ind.Line = indStartLine690;
					ind.CharPositionInLine = indStartCharPos690;
					DebugLocation(162, 4);
					if (state.backtracking == 0)
					{

										loopStartIndex = builder.Length;
										col = CharPositionInLine - (ind!=null?ind.Text:default(string)).Length;

										builder.Append( (ind!=null?ind.Text:default(string)) );
										if ( col==0 && input.LA(1)=='<' )
										{
											// store indent in ASTExpr not in a literal
											currentIndent=(ind!=null?ind.Text:default(string));
											builder.Length = loopStartIndex; // reset length to wack text
										}
										else
										{
											currentIndent=null;
										}
									
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\AngleBracketTemplateLexer.g3:178:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
					{
					DebugLocation(178, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(178, 39);
					if (state.backtracking == 0)
					{
						 builder.Append( (char)ch ); 
					}

					}
					break;

				default:
					if (cnt28 >= 1)
						goto loop28;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee28 = new EarlyExitException( 28, input );
					DebugRecognitionException(eee28);
					throw eee28;
				}
				cnt28++;
			}
			loop28:
				;

			} finally { DebugExitSubRule(28); }

			DebugLocation(180, 3);
			if (state.backtracking == 0)
			{

							Text = builder.ToString();
							if ( Text.Length == 0 )
							{
								_channel = Hidden;
							}
						
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LITERAL", 3);
			LeaveRule("LITERAL", 3);
			LeaveRule_LITERAL();
		}
	}
	// $ANTLR end "LITERAL"

	partial void EnterRule_INDENT();
	partial void LeaveRule_INDENT();

	// $ANTLR start "INDENT"
	[GrammarRule("INDENT")]
	private void mINDENT()
	{
		EnterRule_INDENT();
		EnterRule("INDENT", 4);
		TraceIn("INDENT", 4);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:191:2: ( ( ' ' | '\\t' )+ )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:191:4: ( ' ' | '\\t' )+
			{
			DebugLocation(191, 4);
			// Language\\AngleBracketTemplateLexer.g3:191:4: ( ' ' | '\\t' )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1=='\t'||LA29_1==' '))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:
					{
					DebugLocation(191, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

		}
		finally
		{
			TraceOut("INDENT", 4);
			LeaveRule("INDENT", 4);
			LeaveRule_INDENT();
		}
	}
	// $ANTLR end "INDENT"

	partial void EnterRule_EXPR();
	partial void LeaveRule_EXPR();

	// $ANTLR start "EXPR"
	[GrammarRule("EXPR")]
	private void mEXPR(out string _text)
	{
		EnterRule_EXPR();
		EnterRule("EXPR", 5);
		TraceIn("EXPR", 5);
		try
		{
			CommonToken st = default(CommonToken);
			CommonToken ESC1 = default(CommonToken);
			int ch = 0;


				string subtext = string.Empty;
				_text = string.Empty;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\AngleBracketTemplateLexer.g3:202:2: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:202:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
			{
			DebugLocation(202, 4);
			// Language\\AngleBracketTemplateLexer.g3:202:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
			int cnt32=0;
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=5;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1=='\\'))
				{
					alt32 = 1;
				}
				else if ((LA32_1=='{'))
				{
					alt32 = 2;
				}
				else if ((LA32_1=='+'||LA32_1=='='))
				{
					alt32 = 3;
				}
				else if (((LA32_1>='\u0000' && LA32_1<='*')||(LA32_1>=',' && LA32_1<='<')||(LA32_1>='?' && LA32_1<='[')||(LA32_1>=']' && LA32_1<='z')||(LA32_1>='|' && LA32_1<='\uFFFF')))
				{
					alt32 = 4;
				}


				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:202:6: ESC
					{
					DebugLocation(202, 6);
					int ESC1Start769 = CharIndex;
					int ESC1StartLine769 = Line;
					int ESC1StartCharPos769 = CharPositionInLine;
					mESC(); if (state.failed) return;
					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start769, CharIndex-1);
					ESC1.Line = ESC1StartLine769;
					ESC1.CharPositionInLine = ESC1StartCharPos769;
					DebugLocation(202, 18);
					if (state.backtracking == 0)
					{
						builder.Append((ESC1!=null?ESC1.Text:default(string)));
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\AngleBracketTemplateLexer.g3:203:5: st= SUBTEMPLATE
					{
					DebugLocation(203, 7);
					int stStart787 = CharIndex;
					int stStartLine787 = Line;
					int stStartCharPos787 = CharPositionInLine;
					mSUBTEMPLATE(); if (state.failed) return;
					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart787, CharIndex-1);
					st.Line = stStartLine787;
					st.CharPositionInLine = stStartCharPos787;
					DebugLocation(203, 25);
					if (state.backtracking == 0)
					{
						builder.Append((st!=null?st.Text:default(string)));
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\AngleBracketTemplateLexer.g3:204:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
					{
					DebugLocation(204, 5);
					// Language\\AngleBracketTemplateLexer.g3:204:5: ( '=' | '+' )
					int alt30=2;
					try { DebugEnterSubRule(30);
					try { DebugEnterDecision(30, false);
					int LA30_1 = input.LA(1);

					if ((LA30_1=='='))
					{
						alt30 = 1;
					}
					else if ((LA30_1=='+'))
					{
						alt30 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 30, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(30); }
					switch (alt30)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:204:7: '='
						{
						DebugLocation(204, 7);
						Match('='); if (state.failed) return;
						DebugLocation(204, 18);
						if (state.backtracking == 0)
						{
							builder.Append('=');
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\AngleBracketTemplateLexer.g3:205:6: '+'
						{
						DebugLocation(205, 6);
						Match('+'); if (state.failed) return;
						DebugLocation(205, 17);
						if (state.backtracking == 0)
						{
							builder.Append('+');
						}

						}
						break;

					}
					} finally { DebugExitSubRule(30); }

					DebugLocation(207, 4);
					// Language\\AngleBracketTemplateLexer.g3:207:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
					int alt31=3;
					try { DebugEnterSubRule(31);
					try { DebugEnterDecision(31, false);
					int LA31_1 = input.LA(1);

					if ((LA31_1=='\"'||LA31_1=='<'))
					{
						alt31 = 1;
					}
					else if ((LA31_1=='{'))
					{
						alt31 = 2;
					}
					else if (((LA31_1>='\u0000' && LA31_1<='!')||(LA31_1>='#' && LA31_1<=';')||(LA31_1>='=' && LA31_1<='z')||(LA31_1>='|' && LA31_1<='\uFFFF')))
					{
						alt31 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(31); }
					switch (alt31)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:207:6: TEMPLATE[out subtext]
						{
						DebugLocation(207, 6);
						mTEMPLATE(out subtext); if (state.failed) return;
						DebugLocation(207, 30);
						if (state.backtracking == 0)
						{
							builder.Append(subtext);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\AngleBracketTemplateLexer.g3:208:6: st= SUBTEMPLATE
						{
						DebugLocation(208, 8);
						int stStart853 = CharIndex;
						int stStartLine853 = Line;
						int stStartCharPos853 = CharPositionInLine;
						mSUBTEMPLATE(); if (state.failed) return;
						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart853, CharIndex-1);
						st.Line = stStartLine853;
						st.CharPositionInLine = stStartCharPos853;
						DebugLocation(208, 25);
						if (state.backtracking == 0)
						{
							builder.Append((st!=null?st.Text:default(string)));
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Language\\AngleBracketTemplateLexer.g3:209:6: ch=~ ( '\"' | '<' | '{' )
						{
						DebugLocation(209, 8);
						ch= input.LA(1);
						input.Consume();
						state.failed=false;
						DebugLocation(209, 27);
						if (state.backtracking == 0)
						{
							builder.Append((char)ch);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(31); }


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\AngleBracketTemplateLexer.g3:211:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
					{
					DebugLocation(211, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(211, 34);
					if (state.backtracking == 0)
					{
						builder.Append((char)ch);
					}

					}
					break;

				default:
					if (cnt32 >= 1)
						goto loop32;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee32 = new EarlyExitException( 32, input );
					DebugRecognitionException(eee32);
					throw eee32;
				}
				cnt32++;
			}
			loop32:
				;

			} finally { DebugExitSubRule(32); }

			DebugLocation(213, 3);
			if (state.backtracking == 0)
			{
				_text = builder.ToString();
			}

			}

		}
		finally
		{
			TraceOut("EXPR", 5);
			LeaveRule("EXPR", 5);
			LeaveRule_EXPR();
		}
	}
	// $ANTLR end "EXPR"

	partial void EnterRule_TEMPLATE();
	partial void LeaveRule_TEMPLATE();

	// $ANTLR start "TEMPLATE"
	[GrammarRule("TEMPLATE")]
	private void mTEMPLATE(out string _text)
	{
		EnterRule_TEMPLATE();
		EnterRule("TEMPLATE", 6);
		TraceIn("TEMPLATE", 6);
		try
		{
			CommonToken ESC2 = default(CommonToken);
			int ch = 0;


				_text = string.Empty;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\AngleBracketTemplateLexer.g3:223:2: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( options {k=2; } : ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n' | ( '>' ~ '>' |~ '>' )=>ch= . )* '>>' )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1=='\"'))
			{
				alt38 = 1;
			}
			else if ((LA38_1=='<'))
			{
				alt38 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:223:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
				{
				DebugLocation(223, 4);
				Match('\"'); if (state.failed) return;
				DebugLocation(224, 3);
				if (state.backtracking == 0)
				{
					builder.Append('"');
				}
				DebugLocation(225, 3);
				// Language\\AngleBracketTemplateLexer.g3:225:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=3;
					try { DebugEnterDecision(33, false);
					int LA33_1 = input.LA(1);

					if ((LA33_1=='\\'))
					{
						alt33 = 1;
					}
					else if (((LA33_1>='\u0000' && LA33_1<='!')||(LA33_1>='#' && LA33_1<='[')||(LA33_1>=']' && LA33_1<='\uFFFF')))
					{
						alt33 = 2;
					}


					} finally { DebugExitDecision(33); }
					switch ( alt33 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:225:5: ESC
						{
						DebugLocation(225, 5);
						int ESC2Start946 = CharIndex;
						int ESC2StartLine946 = Line;
						int ESC2StartCharPos946 = CharPositionInLine;
						mESC(); if (state.failed) return;
						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start946, CharIndex-1);
						ESC2.Line = ESC2StartLine946;
						ESC2.CharPositionInLine = ESC2StartCharPos946;
						DebugLocation(225, 14);
						if (state.backtracking == 0)
						{
							builder.Append((ESC2!=null?ESC2.Text:default(string)));
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\AngleBracketTemplateLexer.g3:226:5: ch=~ ( '\\\\' | '\"' )
						{
						DebugLocation(226, 7);
						ch= input.LA(1);
						input.Consume();
						state.failed=false;
						DebugLocation(226, 22);
						if (state.backtracking == 0)
						{
							builder.Append((char)ch);
						}

						}
						break;

					default:
						goto loop33;
					}
				}

				loop33:
					;

				} finally { DebugExitSubRule(33); }

				DebugLocation(228, 3);
				Match('\"'); if (state.failed) return;
				DebugLocation(229, 3);
				if (state.backtracking == 0)
				{

								builder.Append('"');
								_text = builder.ToString();
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\AngleBracketTemplateLexer.g3:233:4: '<<' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( options {k=2; } : ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n' | ( '>' ~ '>' |~ '>' )=>ch= . )* '>>'
				{
				DebugLocation(233, 4);
				Match("<<"); if (state.failed) return;

				DebugLocation(234, 3);
				if (state.backtracking == 0)
				{

								builder.Append("<<");
							
				}
				DebugLocation(237, 3);
				// Language\\AngleBracketTemplateLexer.g3:237:3: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )?
				int alt35=2;
				try { DebugEnterSubRule(35);
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1=='\r'))
				{
					int LA35_2 = input.LA(2);

					if ((LA35_2=='\n'))
					{
						int LA35_3 = input.LA(3);

						if ((EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)))
						{
							alt35 = 1;
						}
					}
				}
				else if ((LA35_1=='\n'))
				{
					int LA35_2 = input.LA(2);

					if ((EvaluatePredicate(synpred12_AngleBracketTemplateLexer_fragment)))
					{
						alt35 = 1;
					}
				}
				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:237:5: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
					{
					DebugLocation(237, 20);
					// Language\\AngleBracketTemplateLexer.g3:237:20: ( '\\r' )?
					int alt34=2;
					try { DebugEnterSubRule(34);
					try { DebugEnterDecision(34, false);
					int LA34_1 = input.LA(1);

					if ((LA34_1=='\r'))
					{
						alt34 = 1;
					}
					} finally { DebugExitDecision(34); }
					switch (alt34)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:237:21: '\\r'
						{
						DebugLocation(237, 21);
						Match('\r'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(34); }

					DebugLocation(237, 28);
					Match('\n'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(35); }

				DebugLocation(238, 3);
				// Language\\AngleBracketTemplateLexer.g3:238:3: ( options {k=2; } : ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n' | ( '>' ~ '>' |~ '>' )=>ch= . )*
				try { DebugEnterSubRule(37);
				while (true)
				{
					int alt37=3;
					try { DebugEnterDecision(37, false);
					int LA37_1 = input.LA(1);

					if ((LA37_1=='>'))
					{
						int LA37_2 = input.LA(2);

						if ((LA37_2=='>'))
						{
							int LA37_3 = input.LA(3);

							if ((EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
							{
								alt37 = 2;
							}


						}
						else if ((LA37_2=='\r') && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 2;
						}
						else if ((LA37_2=='\n') && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 2;
						}
						else if (((LA37_2>='\u0000' && LA37_2<='\t')||(LA37_2>='\u000B' && LA37_2<='\f')||(LA37_2>='\u000E' && LA37_2<='=')||(LA37_2>='?' && LA37_2<='\uFFFF')) && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 2;
						}


					}
					else if ((LA37_1=='\r'))
					{
						int LA37_2 = input.LA(2);

						if ((EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 1;
						}
						else if ((EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 2;
						}


					}
					else if ((LA37_1=='\n'))
					{
						int LA37_2 = input.LA(2);

						if ((EvaluatePredicate(synpred13_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 1;
						}
						else if ((EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
						{
							alt37 = 2;
						}


					}
					else if (((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (EvaluatePredicate(synpred14_AngleBracketTemplateLexer_fragment)))
					{
						alt37 = 2;
					}


					} finally { DebugExitDecision(37); }
					switch ( alt37 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\AngleBracketTemplateLexer.g3:239:4: ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n'
						{
						DebugLocation(239, 22);
						// Language\\AngleBracketTemplateLexer.g3:239:22: ( '\\r' )?
						int alt36=2;
						try { DebugEnterSubRule(36);
						try { DebugEnterDecision(36, false);
						int LA36_1 = input.LA(1);

						if ((LA36_1=='\r'))
						{
							alt36 = 1;
						}
						} finally { DebugExitDecision(36); }
						switch (alt36)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\AngleBracketTemplateLexer.g3:239:23: '\\r'
							{
							DebugLocation(239, 23);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(36); }

						DebugLocation(239, 30);
						Match('\n'); if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\AngleBracketTemplateLexer.g3:240:5: ( '>' ~ '>' |~ '>' )=>ch= .
						{
						DebugLocation(240, 28);

						ch = input.LA(1);

						MatchAny(); if (state.failed) return;
						DebugLocation(240, 31);
						if (state.backtracking == 0)
						{
							builder.Append((char)ch);
						}

						}
						break;

					default:
						goto loop37;
					}
				}

				loop37:
					;

				} finally { DebugExitSubRule(37); }

				DebugLocation(242, 3);
				Match(">>"); if (state.failed) return;

				DebugLocation(243, 3);
				if (state.backtracking == 0)
				{

								builder.Append(">>");
								_text = builder.ToString();
							
				}

				}
				break;

			}
		}
		finally
		{
			TraceOut("TEMPLATE", 6);
			LeaveRule("TEMPLATE", 6);
			LeaveRule_TEMPLATE();
		}
	}
	// $ANTLR end "TEMPLATE"

	partial void EnterRule_IF_EXPR();
	partial void LeaveRule_IF_EXPR();

	// $ANTLR start "IF_EXPR"
	[GrammarRule("IF_EXPR")]
	private void mIF_EXPR()
	{
		EnterRule_IF_EXPR();
		EnterRule("IF_EXPR", 7);
		TraceIn("IF_EXPR", 7);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:251:2: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:251:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
			{
			DebugLocation(251, 4);
			// Language\\AngleBracketTemplateLexer.g3:251:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
			int cnt39=0;
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=5;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1=='\\'))
				{
					alt39 = 1;
				}
				else if ((LA39_1=='{'))
				{
					alt39 = 2;
				}
				else if ((LA39_1=='('))
				{
					alt39 = 3;
				}
				else if (((LA39_1>='\u0000' && LA39_1<='\'')||(LA39_1>='*' && LA39_1<='[')||(LA39_1>=']' && LA39_1<='z')||(LA39_1>='|' && LA39_1<='\uFFFF')))
				{
					alt39 = 4;
				}


				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:251:6: ESC
					{
					DebugLocation(251, 6);
					mESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\AngleBracketTemplateLexer.g3:252:5: SUBTEMPLATE
					{
					DebugLocation(252, 5);
					mSUBTEMPLATE(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\AngleBracketTemplateLexer.g3:253:5: NESTED_PARENS
					{
					DebugLocation(253, 5);
					mNESTED_PARENS(); if (state.failed) return;

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\AngleBracketTemplateLexer.g3:254:5: ~ ( '\\\\' | '{' | '(' | ')' )
					{
					DebugLocation(254, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt39 >= 1)
						goto loop39;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee39 = new EarlyExitException( 39, input );
					DebugRecognitionException(eee39);
					throw eee39;
				}
				cnt39++;
			}
			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

		}
		finally
		{
			TraceOut("IF_EXPR", 7);
			LeaveRule("IF_EXPR", 7);
			LeaveRule_IF_EXPR();
		}
	}
	// $ANTLR end "IF_EXPR"

	partial void EnterRule_ESC_CHAR();
	partial void LeaveRule_ESC_CHAR();

	// $ANTLR start "ESC_CHAR"
	[GrammarRule("ESC_CHAR")]
	private void mESC_CHAR(out char uc)
	{
		EnterRule_ESC_CHAR();
		EnterRule("ESC_CHAR", 8);
		TraceIn("ESC_CHAR", 8);
		try
		{
			CommonToken a = default(CommonToken);
			CommonToken b = default(CommonToken);
			CommonToken c = default(CommonToken);
			CommonToken d = default(CommonToken);


				uc = '\0';

			// Language\\AngleBracketTemplateLexer.g3:264:2: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:264:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
			{
			DebugLocation(264, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(265, 3);
			// Language\\AngleBracketTemplateLexer.g3:265:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
			int alt40=5;
			try { DebugEnterSubRule(40);
			try { DebugEnterDecision(40, false);
			switch (input.LA(1))
			{
			case 'n':
				{
				alt40 = 1;
				}
				break;
			case 'r':
				{
				alt40 = 2;
				}
				break;
			case 't':
				{
				alt40 = 3;
				}
				break;
			case ' ':
				{
				alt40 = 4;
				}
				break;
			case 'u':
				{
				alt40 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 40, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:265:5: 'n'
				{
				DebugLocation(265, 5);
				Match('n'); if (state.failed) return;
				DebugLocation(265, 9);
				if (state.backtracking == 0)
				{
					uc = '\n';
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\AngleBracketTemplateLexer.g3:266:5: 'r'
				{
				DebugLocation(266, 5);
				Match('r'); if (state.failed) return;
				DebugLocation(266, 9);
				if (state.backtracking == 0)
				{
					uc = '\r';
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\AngleBracketTemplateLexer.g3:267:5: 't'
				{
				DebugLocation(267, 5);
				Match('t'); if (state.failed) return;
				DebugLocation(267, 9);
				if (state.backtracking == 0)
				{
					uc = '\t';
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\AngleBracketTemplateLexer.g3:268:5: ' '
				{
				DebugLocation(268, 5);
				Match(' '); if (state.failed) return;
				DebugLocation(268, 9);
				if (state.backtracking == 0)
				{
					uc = ' ';
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Language\\AngleBracketTemplateLexer.g3:269:5: 'u' a= HEX b= HEX c= HEX d= HEX
				{
				DebugLocation(269, 5);
				Match('u'); if (state.failed) return;
				DebugLocation(269, 10);
				int aStart1194 = CharIndex;
				int aStartLine1194 = Line;
				int aStartCharPos1194 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1194, CharIndex-1);
				a.Line = aStartLine1194;
				a.CharPositionInLine = aStartCharPos1194;
				DebugLocation(269, 16);
				int bStart1198 = CharIndex;
				int bStartLine1198 = Line;
				int bStartCharPos1198 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1198, CharIndex-1);
				b.Line = bStartLine1198;
				b.CharPositionInLine = bStartCharPos1198;
				DebugLocation(269, 22);
				int cStart1202 = CharIndex;
				int cStartLine1202 = Line;
				int cStartCharPos1202 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1202, CharIndex-1);
				c.Line = cStartLine1202;
				c.CharPositionInLine = cStartCharPos1202;
				DebugLocation(269, 28);
				int dStart1206 = CharIndex;
				int dStartLine1206 = Line;
				int dStartCharPos1206 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1206, CharIndex-1);
				d.Line = dStartLine1206;
				d.CharPositionInLine = dStartCharPos1206;
				DebugLocation(270, 4);
				if (state.backtracking == 0)
				{
					 uc = (char)int.Parse((a!=null?a.Text:default(string))+(b!=null?b.Text:default(string))+(c!=null?c.Text:default(string))+(d!=null?d.Text:default(string)), System.Globalization.NumberStyles.AllowHexSpecifier); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(40); }


			}

		}
		finally
		{
			TraceOut("ESC_CHAR", 8);
			LeaveRule("ESC_CHAR", 8);
			LeaveRule_ESC_CHAR();
		}
	}
	// $ANTLR end "ESC_CHAR"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	private void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 9);
		TraceIn("ESC", 9);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:277:2: ( '\\\\' . )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:277:4: '\\\\' .
			{
			DebugLocation(277, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(277, 9);
			MatchAny(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ESC", 9);
			LeaveRule("ESC", 9);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_HEX();
	partial void LeaveRule_HEX();

	// $ANTLR start "HEX"
	[GrammarRule("HEX")]
	private void mHEX()
	{
		EnterRule_HEX();
		EnterRule("HEX", 10);
		TraceIn("HEX", 10);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:282:2: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:
			{
			DebugLocation(282, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HEX", 10);
			LeaveRule("HEX", 10);
			LeaveRule_HEX();
		}
	}
	// $ANTLR end "HEX"

	partial void EnterRule_SUBTEMPLATE();
	partial void LeaveRule_SUBTEMPLATE();

	// $ANTLR start "SUBTEMPLATE"
	[GrammarRule("SUBTEMPLATE")]
	private void mSUBTEMPLATE()
	{
		EnterRule_SUBTEMPLATE();
		EnterRule("SUBTEMPLATE", 11);
		TraceIn("SUBTEMPLATE", 11);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:287:2: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:287:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
			{
			DebugLocation(287, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(288, 3);
			// Language\\AngleBracketTemplateLexer.g3:288:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=4;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1=='{'))
				{
					alt41 = 1;
				}
				else if ((LA41_1=='\\'))
				{
					alt41 = 2;
				}
				else if (((LA41_1>='\u0000' && LA41_1<='[')||(LA41_1>=']' && LA41_1<='z')||LA41_1=='|'||(LA41_1>='~' && LA41_1<='\uFFFF')))
				{
					alt41 = 3;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:288:5: SUBTEMPLATE
					{
					DebugLocation(288, 5);
					mSUBTEMPLATE(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\AngleBracketTemplateLexer.g3:289:5: ESC
					{
					DebugLocation(289, 5);
					mESC(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\AngleBracketTemplateLexer.g3:290:5: ~ ( '{' | '\\\\' | '}' )
					{
					DebugLocation(290, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }

			DebugLocation(292, 3);
			Match('}'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("SUBTEMPLATE", 11);
			LeaveRule("SUBTEMPLATE", 11);
			LeaveRule_SUBTEMPLATE();
		}
	}
	// $ANTLR end "SUBTEMPLATE"

	partial void EnterRule_NESTED_PARENS();
	partial void LeaveRule_NESTED_PARENS();

	// $ANTLR start "NESTED_PARENS"
	[GrammarRule("NESTED_PARENS")]
	private void mNESTED_PARENS()
	{
		EnterRule_NESTED_PARENS();
		EnterRule("NESTED_PARENS", 12);
		TraceIn("NESTED_PARENS", 12);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:297:2: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:297:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
			{
			DebugLocation(297, 4);
			Match('('); if (state.failed) return;
			DebugLocation(298, 3);
			// Language\\AngleBracketTemplateLexer.g3:298:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
			int cnt42=0;
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=4;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1=='('))
				{
					alt42 = 1;
				}
				else if ((LA42_1=='\\'))
				{
					alt42 = 2;
				}
				else if (((LA42_1>='\u0000' && LA42_1<='\'')||(LA42_1>='*' && LA42_1<='[')||(LA42_1>=']' && LA42_1<='\uFFFF')))
				{
					alt42 = 3;
				}


				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:298:5: NESTED_PARENS
					{
					DebugLocation(298, 5);
					mNESTED_PARENS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\AngleBracketTemplateLexer.g3:299:5: ESC
					{
					DebugLocation(299, 5);
					mESC(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\AngleBracketTemplateLexer.g3:300:5: ~ ( '(' | '\\\\' | ')' )
					{
					DebugLocation(300, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt42 >= 1)
						goto loop42;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee42 = new EarlyExitException( 42, input );
					DebugRecognitionException(eee42);
					throw eee42;
				}
				cnt42++;
			}
			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(302, 3);
			Match(')'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("NESTED_PARENS", 12);
			LeaveRule("NESTED_PARENS", 12);
			LeaveRule_NESTED_PARENS();
		}
	}
	// $ANTLR end "NESTED_PARENS"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 13);
		TraceIn("COMMENT", 13);
		try
		{

			    int startCol = CharPositionInLine;

			// Language\\AngleBracketTemplateLexer.g3:311:2: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:311:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
			{
			DebugLocation(311, 4);
			Match("<!"); if (state.failed) return;

			DebugLocation(311, 9);
			// Language\\AngleBracketTemplateLexer.g3:311:9: ( . )*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1=='!'))
				{
					int LA43_2 = input.LA(2);

					if ((LA43_2=='>'))
					{
						alt43 = 2;
					}
					else if (((LA43_2>='\u0000' && LA43_2<='=')||(LA43_2>='?' && LA43_2<='\uFFFF')))
					{
						alt43 = 1;
					}


				}
				else if (((LA43_1>='\u0000' && LA43_1<=' ')||(LA43_1>='\"' && LA43_1<='\uFFFF')))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:311:9: .
					{
					DebugLocation(311, 9);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }

			DebugLocation(311, 12);
			Match("!>"); if (state.failed) return;

			DebugLocation(312, 3);
			// Language\\AngleBracketTemplateLexer.g3:312:3: ({...}? => ( '\\r' )? '\\n' )?
			int alt45=2;
			try { DebugEnterSubRule(45);
			try { DebugEnterDecision(45, false);
			int LA45_1 = input.LA(1);

			if ((LA45_1=='\n'||LA45_1=='\r') && ((startCol==0)))
			{
				alt45 = 1;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:312:5: {...}? => ( '\\r' )? '\\n'
				{
				DebugLocation(312, 5);
				if (!((startCol==0)))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "COMMENT", "startCol==0");
				}
				DebugLocation(312, 23);
				// Language\\AngleBracketTemplateLexer.g3:312:23: ( '\\r' )?
				int alt44=2;
				try { DebugEnterSubRule(44);
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1=='\r'))
				{
					alt44 = 1;
				}
				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\AngleBracketTemplateLexer.g3:312:24: '\\r'
					{
					DebugLocation(312, 24);
					Match('\r'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(44); }

				DebugLocation(312, 31);
				Match('\n'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(45); }


			}

		}
		finally
		{
			TraceOut("COMMENT", 13);
			LeaveRule("COMMENT", 13);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_LINE_BREAK();
	partial void LeaveRule_LINE_BREAK();

	// $ANTLR start "LINE_BREAK"
	[GrammarRule("LINE_BREAK")]
	private void mLINE_BREAK()
	{
		EnterRule_LINE_BREAK();
		EnterRule("LINE_BREAK", 14);
		TraceIn("LINE_BREAK", 14);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:317:2: ( '<\\\\\\\\>' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )? )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:317:4: '<\\\\\\\\>' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )?
			{
			DebugLocation(317, 4);
			Match("<\\\\>"); if (state.failed) return;

			DebugLocation(317, 13);
			// Language\\AngleBracketTemplateLexer.g3:317:13: ( INDENT )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1=='\t'||LA46_1==' '))
			{
				alt46 = 1;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:317:13: INDENT
				{
				DebugLocation(317, 13);
				mINDENT(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(46); }

			DebugLocation(317, 21);
			// Language\\AngleBracketTemplateLexer.g3:317:21: ( '\\r' )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1=='\r'))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:317:21: '\\r'
				{
				DebugLocation(317, 21);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(47); }

			DebugLocation(317, 27);
			Match('\n'); if (state.failed) return;
			DebugLocation(317, 32);
			// Language\\AngleBracketTemplateLexer.g3:317:32: ( INDENT )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1=='\t'||LA48_1==' '))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:317:32: INDENT
				{
				DebugLocation(317, 32);
				mINDENT(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(48); }


			}

		}
		finally
		{
			TraceOut("LINE_BREAK", 14);
			LeaveRule("LINE_BREAK", 14);
			LeaveRule_LINE_BREAK();
		}
	}
	// $ANTLR end "LINE_BREAK"

	public override void mTokens()
	{
		// Language\\AngleBracketTemplateLexer.g3:1:8: ( NEWLINE | ACTION | LITERAL )
		int alt49=3;
		try { DebugEnterDecision(49, false);
		int LA49_1 = input.LA(1);

		if ((LA49_1=='\n'||LA49_1=='\r'))
		{
			alt49 = 1;
		}
		else if ((LA49_1=='<'))
		{
			alt49 = 2;
		}
		else if (((LA49_1>='\u0000' && LA49_1<='\t')||(LA49_1>='\u000B' && LA49_1<='\f')||(LA49_1>='\u000E' && LA49_1<=';')||(LA49_1>='=' && LA49_1<='\uFFFF')))
		{
			alt49 = 3;
		}
		else
		{
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
			DebugRecognitionException(nvae);
			throw nvae;
		}
		} finally { DebugExitDecision(49); }
		switch (alt49)
		{
		case 1:
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:1:10: NEWLINE
			{
			DebugLocation(1, 10);
			mNEWLINE(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Language\\AngleBracketTemplateLexer.g3:1:18: ACTION
			{
			DebugLocation(1, 18);
			mACTION(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Language\\AngleBracketTemplateLexer.g3:1:25: LITERAL
			{
			DebugLocation(1, 25);
			mLITERAL(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred1_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred1_AngleBracketTemplateLexer
	private void synpred1_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred1_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred1_AngleBracketTemplateLexer_fragment", 16);
		TraceIn("synpred1_AngleBracketTemplateLexer_fragment", 16);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:59:4: ( LINE_BREAK )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:59:5: LINE_BREAK
			{
			DebugLocation(59, 5);
			mLINE_BREAK(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_AngleBracketTemplateLexer_fragment", 16);
			LeaveRule("synpred1_AngleBracketTemplateLexer_fragment", 16);
			LeaveRule_synpred1_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred1_AngleBracketTemplateLexer

	partial void EnterRule_synpred2_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred2_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred2_AngleBracketTemplateLexer
	private void synpred2_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred2_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred2_AngleBracketTemplateLexer_fragment", 17);
		TraceIn("synpred2_AngleBracketTemplateLexer_fragment", 17);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:60:4: ( '<\\\\' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:60:5: '<\\\\'
			{
			DebugLocation(60, 5);
			Match("<\\"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred2_AngleBracketTemplateLexer_fragment", 17);
			LeaveRule("synpred2_AngleBracketTemplateLexer_fragment", 17);
			LeaveRule_synpred2_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred2_AngleBracketTemplateLexer

	partial void EnterRule_synpred3_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred3_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred3_AngleBracketTemplateLexer
	private void synpred3_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred3_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred3_AngleBracketTemplateLexer_fragment", 18);
		TraceIn("synpred3_AngleBracketTemplateLexer_fragment", 18);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:71:4: ( '<!' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:71:5: '<!'
			{
			DebugLocation(71, 5);
			Match("<!"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred3_AngleBracketTemplateLexer_fragment", 18);
			LeaveRule("synpred3_AngleBracketTemplateLexer_fragment", 18);
			LeaveRule_synpred3_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred3_AngleBracketTemplateLexer

	partial void EnterRule_synpred4_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred4_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred4_AngleBracketTemplateLexer
	private void synpred4_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred4_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred4_AngleBracketTemplateLexer_fragment", 19);
		TraceIn("synpred4_AngleBracketTemplateLexer_fragment", 19);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:73:4: ( '<if' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:73:5: '<if'
			{
			DebugLocation(73, 5);
			Match("<if"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred4_AngleBracketTemplateLexer_fragment", 19);
			LeaveRule("synpred4_AngleBracketTemplateLexer_fragment", 19);
			LeaveRule_synpred4_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred4_AngleBracketTemplateLexer

	partial void EnterRule_synpred5_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred5_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred5_AngleBracketTemplateLexer
	private void synpred5_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred5_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred5_AngleBracketTemplateLexer_fragment", 20);
		TraceIn("synpred5_AngleBracketTemplateLexer_fragment", 20);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:80:5: ( '<elseif' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:80:6: '<elseif'
			{
			DebugLocation(80, 6);
			Match("<elseif"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred5_AngleBracketTemplateLexer_fragment", 20);
			LeaveRule("synpred5_AngleBracketTemplateLexer_fragment", 20);
			LeaveRule_synpred5_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred5_AngleBracketTemplateLexer

	partial void EnterRule_synpred6_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred6_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred6_AngleBracketTemplateLexer
	private void synpred6_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred6_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred6_AngleBracketTemplateLexer_fragment", 21);
		TraceIn("synpred6_AngleBracketTemplateLexer_fragment", 21);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:87:5: ( '<else' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:87:6: '<else'
			{
			DebugLocation(87, 6);
			Match("<else"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred6_AngleBracketTemplateLexer_fragment", 21);
			LeaveRule("synpred6_AngleBracketTemplateLexer_fragment", 21);
			LeaveRule_synpred6_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred6_AngleBracketTemplateLexer

	partial void EnterRule_synpred7_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred7_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred7_AngleBracketTemplateLexer
	private void synpred7_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred7_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred7_AngleBracketTemplateLexer_fragment", 22);
		TraceIn("synpred7_AngleBracketTemplateLexer_fragment", 22);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:94:5: ( '<endif' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:94:6: '<endif'
			{
			DebugLocation(94, 6);
			Match("<endif"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred7_AngleBracketTemplateLexer_fragment", 22);
			LeaveRule("synpred7_AngleBracketTemplateLexer_fragment", 22);
			LeaveRule_synpred7_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred7_AngleBracketTemplateLexer

	partial void EnterRule_synpred8_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred8_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred8_AngleBracketTemplateLexer
	private void synpred8_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred8_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred8_AngleBracketTemplateLexer_fragment", 23);
		TraceIn("synpred8_AngleBracketTemplateLexer_fragment", 23);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:103:4: ( '<@' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:103:5: '<@'
			{
			DebugLocation(103, 5);
			Match("<@"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred8_AngleBracketTemplateLexer_fragment", 23);
			LeaveRule("synpred8_AngleBracketTemplateLexer_fragment", 23);
			LeaveRule_synpred8_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred8_AngleBracketTemplateLexer

	partial void EnterRule_synpred9_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred9_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred9_AngleBracketTemplateLexer
	private void synpred9_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred9_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred9_AngleBracketTemplateLexer_fragment", 24);
		TraceIn("synpred9_AngleBracketTemplateLexer_fragment", 24);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:119:7: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:
			{
			DebugLocation(119, 7);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred9_AngleBracketTemplateLexer_fragment", 24);
			LeaveRule("synpred9_AngleBracketTemplateLexer_fragment", 24);
			LeaveRule_synpred9_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred9_AngleBracketTemplateLexer

	partial void EnterRule_synpred10_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred10_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred10_AngleBracketTemplateLexer
	private void synpred10_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred10_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred10_AngleBracketTemplateLexer_fragment", 25);
		TraceIn("synpred10_AngleBracketTemplateLexer_fragment", 25);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:124:8: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:
			{
			DebugLocation(124, 8);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred10_AngleBracketTemplateLexer_fragment", 25);
			LeaveRule("synpred10_AngleBracketTemplateLexer_fragment", 25);
			LeaveRule_synpred10_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred10_AngleBracketTemplateLexer

	partial void EnterRule_synpred11_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred11_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred11_AngleBracketTemplateLexer
	private void synpred11_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred11_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred11_AngleBracketTemplateLexer_fragment", 26);
		TraceIn("synpred11_AngleBracketTemplateLexer_fragment", 26);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:128:7: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:
			{
			DebugLocation(128, 7);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred11_AngleBracketTemplateLexer_fragment", 26);
			LeaveRule("synpred11_AngleBracketTemplateLexer_fragment", 26);
			LeaveRule_synpred11_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred11_AngleBracketTemplateLexer

	partial void EnterRule_synpred12_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred12_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred12_AngleBracketTemplateLexer
	private void synpred12_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred12_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred12_AngleBracketTemplateLexer_fragment", 27);
		TraceIn("synpred12_AngleBracketTemplateLexer_fragment", 27);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:237:5: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:
			{
			DebugLocation(237, 5);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred12_AngleBracketTemplateLexer_fragment", 27);
			LeaveRule("synpred12_AngleBracketTemplateLexer_fragment", 27);
			LeaveRule_synpred12_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred12_AngleBracketTemplateLexer

	partial void EnterRule_synpred13_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred13_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred13_AngleBracketTemplateLexer
	private void synpred13_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred13_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred13_AngleBracketTemplateLexer_fragment", 28);
		TraceIn("synpred13_AngleBracketTemplateLexer_fragment", 28);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:239:4: ( ( '\\r' )? '\\n>>' )
			DebugEnterAlt(1);
			// Language\\AngleBracketTemplateLexer.g3:239:5: ( '\\r' )? '\\n>>'
			{
			DebugLocation(239, 5);
			// Language\\AngleBracketTemplateLexer.g3:239:5: ( '\\r' )?
			int alt50=2;
			try { DebugEnterSubRule(50);
			try { DebugEnterDecision(50, false);
			int LA50_1 = input.LA(1);

			if ((LA50_1=='\r'))
			{
				alt50 = 1;
			}
			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:239:5: '\\r'
				{
				DebugLocation(239, 5);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(50); }

			DebugLocation(239, 11);
			Match("\n>>"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred13_AngleBracketTemplateLexer_fragment", 28);
			LeaveRule("synpred13_AngleBracketTemplateLexer_fragment", 28);
			LeaveRule_synpred13_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred13_AngleBracketTemplateLexer

	partial void EnterRule_synpred14_AngleBracketTemplateLexer_fragment();
	partial void LeaveRule_synpred14_AngleBracketTemplateLexer_fragment();

	// $ANTLR start synpred14_AngleBracketTemplateLexer
	private void synpred14_AngleBracketTemplateLexer_fragment()
	{
		EnterRule_synpred14_AngleBracketTemplateLexer_fragment();
		EnterRule("synpred14_AngleBracketTemplateLexer_fragment", 29);
		TraceIn("synpred14_AngleBracketTemplateLexer_fragment", 29);
		try
		{
			// Language\\AngleBracketTemplateLexer.g3:240:5: ( '>' ~ '>' |~ '>' )
			int alt51=2;
			try { DebugEnterDecision(51, false);
			int LA51_1 = input.LA(1);

			if ((LA51_1=='>'))
			{
				alt51 = 1;
			}
			else if (((LA51_1>='\u0000' && LA51_1<='=')||(LA51_1>='?' && LA51_1<='\uFFFF')))
			{
				alt51 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 51, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\AngleBracketTemplateLexer.g3:240:6: '>' ~ '>'
				{
				DebugLocation(240, 6);
				Match('>'); if (state.failed) return;
				DebugLocation(240, 10);
				if ((input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF'))
				{
					input.Consume();
				state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					Recover(mse);
					throw mse;
				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\AngleBracketTemplateLexer.g3:240:17: ~ '>'
				{
				DebugLocation(240, 17);
				if ((input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF'))
				{
					input.Consume();
				state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					Recover(mse);
					throw mse;
				}


				}
				break;

			}
		}
		finally
		{
			TraceOut("synpred14_AngleBracketTemplateLexer_fragment", 29);
			LeaveRule("synpred14_AngleBracketTemplateLexer_fragment", 29);
			LeaveRule_synpred14_AngleBracketTemplateLexer_fragment();
		}
	}
	// $ANTLR end synpred14_AngleBracketTemplateLexer

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}

} // namespace Antlr3.ST.Language
