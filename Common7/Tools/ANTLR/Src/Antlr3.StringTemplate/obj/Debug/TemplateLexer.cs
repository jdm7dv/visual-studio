//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 Language\\Template.g3 2013-06-14 09:39:34

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Antlr3.ST.Language
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class TemplateLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ACTION=4;
	public const int COMMENT=5;
	public const int ELSE=6;
	public const int ELSEIF=7;
	public const int ENDIF=8;
	public const int ESC=9;
	public const int ESC_CHAR=10;
	public const int EXPR=11;
	public const int HEX=12;
	public const int IF=13;
	public const int IF_EXPR=14;
	public const int INDENT=15;
	public const int LINE_BREAK=16;
	public const int LITERAL=17;
	public const int NESTED_PARENS=18;
	public const int NEWLINE=19;
	public const int REGION_DEF=20;
	public const int REGION_REF=21;
	public const int SUBTEMPLATE=22;
	public const int TEMPLATE=23;

	// delegates
	// delegators

	private TemplateLexer()
	{
		OnCreated();
	}

	private TemplateLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	private TemplateLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Language\\Template.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 1);
		TraceIn("IF", 1);
		try
		{
			// Language\\Template.g3:191:13: ()
			DebugEnterAlt(1);
			// Language\\Template.g3:191:15: 
			{
			}

		}
		finally
		{
			TraceOut("IF", 1);
			LeaveRule("IF", 1);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_ELSEIF();
	partial void LeaveRule_ELSEIF();

	// $ANTLR start "ELSEIF"
	[GrammarRule("ELSEIF")]
	private void mELSEIF()
	{
		EnterRule_ELSEIF();
		EnterRule("ELSEIF", 2);
		TraceIn("ELSEIF", 2);
		try
		{
			// Language\\Template.g3:192:17: ()
			DebugEnterAlt(1);
			// Language\\Template.g3:192:19: 
			{
			}

		}
		finally
		{
			TraceOut("ELSEIF", 2);
			LeaveRule("ELSEIF", 2);
			LeaveRule_ELSEIF();
		}
	}
	// $ANTLR end "ELSEIF"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 3);
		TraceIn("ELSE", 3);
		try
		{
			// Language\\Template.g3:193:15: ()
			DebugEnterAlt(1);
			// Language\\Template.g3:193:17: 
			{
			}

		}
		finally
		{
			TraceOut("ELSE", 3);
			LeaveRule("ELSE", 3);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_ENDIF();
	partial void LeaveRule_ENDIF();

	// $ANTLR start "ENDIF"
	[GrammarRule("ENDIF")]
	private void mENDIF()
	{
		EnterRule_ENDIF();
		EnterRule("ENDIF", 4);
		TraceIn("ENDIF", 4);
		try
		{
			// Language\\Template.g3:194:16: ()
			DebugEnterAlt(1);
			// Language\\Template.g3:194:18: 
			{
			}

		}
		finally
		{
			TraceOut("ENDIF", 4);
			LeaveRule("ENDIF", 4);
			LeaveRule_ENDIF();
		}
	}
	// $ANTLR end "ENDIF"

	partial void EnterRule_REGION_DEF();
	partial void LeaveRule_REGION_DEF();

	// $ANTLR start "REGION_DEF"
	[GrammarRule("REGION_DEF")]
	private void mREGION_DEF()
	{
		EnterRule_REGION_DEF();
		EnterRule("REGION_DEF", 5);
		TraceIn("REGION_DEF", 5);
		try
		{
			// Language\\Template.g3:195:21: ()
			DebugEnterAlt(1);
			// Language\\Template.g3:195:23: 
			{
			}

		}
		finally
		{
			TraceOut("REGION_DEF", 5);
			LeaveRule("REGION_DEF", 5);
			LeaveRule_REGION_DEF();
		}
	}
	// $ANTLR end "REGION_DEF"

	partial void EnterRule_REGION_REF();
	partial void LeaveRule_REGION_REF();

	// $ANTLR start "REGION_REF"
	[GrammarRule("REGION_REF")]
	private void mREGION_REF()
	{
		EnterRule_REGION_REF();
		EnterRule("REGION_REF", 6);
		TraceIn("REGION_REF", 6);
		try
		{
			// Language\\Template.g3:196:21: ()
			DebugEnterAlt(1);
			// Language\\Template.g3:196:23: 
			{
			}

		}
		finally
		{
			TraceOut("REGION_REF", 6);
			LeaveRule("REGION_REF", 6);
			LeaveRule_REGION_REF();
		}
	}
	// $ANTLR end "REGION_REF"

	partial void EnterRule_NEWLINE();
	partial void LeaveRule_NEWLINE();

	// $ANTLR start "NEWLINE"
	[GrammarRule("NEWLINE")]
	private void mNEWLINE()
	{
		EnterRule_NEWLINE();
		EnterRule("NEWLINE", 7);
		TraceIn("NEWLINE", 7);
		try
		{
			int _type = NEWLINE;
			int _channel = DefaultTokenChannel;
			// Language\\Template.g3:199:2: ( ( '\\r' )? '\\n' )
			DebugEnterAlt(1);
			// Language\\Template.g3:199:4: ( '\\r' )? '\\n'
			{
			DebugLocation(199, 4);
			// Language\\Template.g3:199:4: ( '\\r' )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1=='\r'))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:199:5: '\\r'
				{
				DebugLocation(199, 5);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(199, 12);
			Match('\n'); if (state.failed) return;
			DebugLocation(199, 17);
			if (state.backtracking == 0)
			{
				currentIndent=null;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEWLINE", 7);
			LeaveRule("NEWLINE", 7);
			LeaveRule_NEWLINE();
		}
	}
	// $ANTLR end "NEWLINE"

	partial void EnterRule_ACTION();
	partial void LeaveRule_ACTION();

	// $ANTLR start "ACTION"
	[GrammarRule("ACTION")]
	private void mACTION()
	{
		EnterRule_ACTION();
		EnterRule("ACTION", 8);
		TraceIn("ACTION", 8);
		try
		{
			int _type = ACTION;
			int _channel = DefaultTokenChannel;
			CommonToken exp = default(CommonToken);
			int ch = 0;


				int startCol = CharPositionInLine;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();
				System.Text.StringBuilder buf = null;
				string subtext = string.Empty;
				char uc = '\0';
				bool atLeft = false;
				string t = null;

			// Language\\Template.g3:213:2: ( ( options {k=1; } : ( LINE_BREAK )=> LINE_BREAK | ( '$\\\\' )=> '$' ( ESC_CHAR[out uc] )+ '$' | ( '$!' )=> COMMENT | ( ( '$if' ( ' ' | '(' ) )=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$elseif' ( ' ' | '(' ) )=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$else$' )=> '$else$' ( ( '\\r' )? '\\n' )? | ( '$endif$' )=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? | ( '$@' )=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
			DebugEnterAlt(1);
			// Language\\Template.g3:213:4: ( options {k=1; } : ( LINE_BREAK )=> LINE_BREAK | ( '$\\\\' )=> '$' ( ESC_CHAR[out uc] )+ '$' | ( '$!' )=> COMMENT | ( ( '$if' ( ' ' | '(' ) )=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$elseif' ( ' ' | '(' ) )=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$else$' )=> '$else$' ( ( '\\r' )? '\\n' )? | ( '$endif$' )=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? | ( '$@' )=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
			{
			DebugLocation(213, 4);
			// Language\\Template.g3:213:4: ( options {k=1; } : ( LINE_BREAK )=> LINE_BREAK | ( '$\\\\' )=> '$' ( ESC_CHAR[out uc] )+ '$' | ( '$!' )=> COMMENT | ( ( '$if' ( ' ' | '(' ) )=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$elseif' ( ' ' | '(' ) )=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$else$' )=> '$else$' ( ( '\\r' )? '\\n' )? | ( '$endif$' )=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? | ( '$@' )=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
			int alt26=4;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1=='$'))
			{
				int LA26_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_Template_fragment)))
				{
					alt26 = 1;
				}
				else if ((EvaluatePredicate(synpred2_Template_fragment)))
				{
					alt26 = 2;
				}
				else if ((EvaluatePredicate(synpred3_Template_fragment)))
				{
					alt26 = 3;
				}
				else if ((true))
				{
					alt26 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 26, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:214:4: ( LINE_BREAK )=> LINE_BREAK
				{
				DebugLocation(214, 20);
				mLINE_BREAK(); if (state.failed) return;
				DebugLocation(214, 31);
				if (state.backtracking == 0)
				{
					_channel = Hidden;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Template.g3:215:5: ( '$\\\\' )=> '$' ( ESC_CHAR[out uc] )+ '$'
				{
				DebugLocation(217, 4);
				Match('$'); if (state.failed) return;
				DebugLocation(217, 8);
				// Language\\Template.g3:217:8: ( ESC_CHAR[out uc] )+
				int cnt2=0;
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if ((LA2_1=='\\'))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:217:9: ESC_CHAR[out uc]
						{
						DebugLocation(217, 9);
						mESC_CHAR(out uc); if (state.failed) return;
						DebugLocation(217, 26);
						if (state.backtracking == 0)
						{
							builder.Append(uc);
						}

						}
						break;

					default:
						if (cnt2 >= 1)
							goto loop2;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee2 = new EarlyExitException( 2, input );
						DebugRecognitionException(eee2);
						throw eee2;
					}
					cnt2++;
				}
				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(217, 51);
				Match('$'); if (state.failed) return;
				DebugLocation(218, 4);
				if (state.backtracking == 0)
				{

									Text = builder.ToString();
									_type = LITERAL;
								
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Template.g3:222:5: ( '$!' )=> COMMENT
				{
				DebugLocation(222, 15);
				mCOMMENT(); if (state.failed) return;
				DebugLocation(223, 4);
				if (state.backtracking == 0)
				{
					 _channel = Hidden; 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Template.g3:224:5: ( ( '$if' ( ' ' | '(' ) )=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$elseif' ( ' ' | '(' ) )=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$else$' )=> '$else$' ( ( '\\r' )? '\\n' )? | ( '$endif$' )=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? | ( '$@' )=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
				{
				DebugLocation(224, 5);
				// Language\\Template.g3:224:5: ( ( '$if' ( ' ' | '(' ) )=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$elseif' ( ' ' | '(' ) )=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? | ( '$else$' )=> '$else$' ( ( '\\r' )? '\\n' )? | ( '$endif$' )=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? | ( '$@' )=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
				int alt25=6;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1=='$'))
				{
					int LA25_2 = input.LA(2);

					if ((EvaluatePredicate(synpred4_Template_fragment)))
					{
						alt25 = 1;
					}
					else if ((EvaluatePredicate(synpred5_Template_fragment)))
					{
						alt25 = 2;
					}
					else if ((EvaluatePredicate(synpred6_Template_fragment)))
					{
						alt25 = 3;
					}
					else if ((EvaluatePredicate(synpred7_Template_fragment)))
					{
						alt25 = 4;
					}
					else if ((EvaluatePredicate(synpred8_Template_fragment)))
					{
						alt25 = 5;
					}
					else if ((true))
					{
						alt25 = 6;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 25, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:224:7: ( '$if' ( ' ' | '(' ) )=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
					{
					DebugLocation(225, 5);
					Match("$if"); if (state.failed) return;

					DebugLocation(225, 11);
					// Language\\Template.g3:225:11: ( ' ' )*
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_1 = input.LA(1);

						if ((LA3_1==' '))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch ( alt3 )
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:225:12: ' '
							{
							DebugLocation(225, 12);
							Match(' '); if (state.failed) return;

							}
							break;

						default:
							goto loop3;
						}
					}

					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(225, 18);
					Match('('); if (state.failed) return;
					DebugLocation(225, 25);
					int expStart220 = CharIndex;
					int expStartLine220 = Line;
					int expStartCharPos220 = CharPositionInLine;
					mIF_EXPR(); if (state.failed) return;
					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart220, CharIndex-1);
					exp.Line = expStartLine220;
					exp.CharPositionInLine = expStartCharPos220;
					DebugLocation(225, 34);
					Match(")$"); if (state.failed) return;

					DebugLocation(226, 5);
					if (state.backtracking == 0)
					{

											Text = "if(" + (exp!=null?exp.Text:default(string)) + ")";
											_type = TemplateParser.IF;
										
					}
					DebugLocation(230, 5);
					// Language\\Template.g3:230:5: ( ( '\\r' )? '\\n' )?
					int alt5=2;
					try { DebugEnterSubRule(5);
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if ((LA5_1=='\n'||LA5_1=='\r'))
					{
						alt5 = 1;
					}
					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:230:7: ( '\\r' )? '\\n'
						{
						DebugLocation(230, 7);
						// Language\\Template.g3:230:7: ( '\\r' )?
						int alt4=2;
						try { DebugEnterSubRule(4);
						try { DebugEnterDecision(4, false);
						int LA4_1 = input.LA(1);

						if ((LA4_1=='\r'))
						{
							alt4 = 1;
						}
						} finally { DebugExitDecision(4); }
						switch (alt4)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:230:8: '\\r'
							{
							DebugLocation(230, 8);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(4); }

						DebugLocation(230, 15);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(5); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:231:6: ( '$elseif' ( ' ' | '(' ) )=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
					{
					DebugLocation(232, 5);
					Match("$elseif"); if (state.failed) return;

					DebugLocation(232, 15);
					// Language\\Template.g3:232:15: ( ' ' )*
					try { DebugEnterSubRule(6);
					while (true)
					{
						int alt6=2;
						try { DebugEnterDecision(6, false);
						int LA6_1 = input.LA(1);

						if ((LA6_1==' '))
						{
							alt6 = 1;
						}


						} finally { DebugExitDecision(6); }
						switch ( alt6 )
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:232:16: ' '
							{
							DebugLocation(232, 16);
							Match(' '); if (state.failed) return;

							}
							break;

						default:
							goto loop6;
						}
					}

					loop6:
						;

					} finally { DebugExitSubRule(6); }

					DebugLocation(232, 22);
					Match('('); if (state.failed) return;
					DebugLocation(232, 29);
					int expStart279 = CharIndex;
					int expStartLine279 = Line;
					int expStartCharPos279 = CharPositionInLine;
					mIF_EXPR(); if (state.failed) return;
					exp = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, expStart279, CharIndex-1);
					exp.Line = expStartLine279;
					exp.CharPositionInLine = expStartCharPos279;
					DebugLocation(232, 38);
					Match(")$"); if (state.failed) return;

					DebugLocation(233, 5);
					if (state.backtracking == 0)
					{

											Text = "elseif(" + (exp!=null?exp.Text:default(string)) + ")";
											_type = TemplateParser.ELSEIF;
										
					}
					DebugLocation(237, 5);
					// Language\\Template.g3:237:5: ( ( '\\r' )? '\\n' )?
					int alt8=2;
					try { DebugEnterSubRule(8);
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if ((LA8_1=='\n'||LA8_1=='\r'))
					{
						alt8 = 1;
					}
					} finally { DebugExitDecision(8); }
					switch (alt8)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:237:7: ( '\\r' )? '\\n'
						{
						DebugLocation(237, 7);
						// Language\\Template.g3:237:7: ( '\\r' )?
						int alt7=2;
						try { DebugEnterSubRule(7);
						try { DebugEnterDecision(7, false);
						int LA7_1 = input.LA(1);

						if ((LA7_1=='\r'))
						{
							alt7 = 1;
						}
						} finally { DebugExitDecision(7); }
						switch (alt7)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:237:8: '\\r'
							{
							DebugLocation(237, 8);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(7); }

						DebugLocation(237, 15);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(8); }


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:238:6: ( '$else$' )=> '$else$' ( ( '\\r' )? '\\n' )?
					{
					DebugLocation(239, 5);
					Match("$else$"); if (state.failed) return;

					DebugLocation(240, 5);
					if (state.backtracking == 0)
					{

											Text = "else";
											_type = (TemplateParser.ELSE);
										
					}
					DebugLocation(244, 5);
					// Language\\Template.g3:244:5: ( ( '\\r' )? '\\n' )?
					int alt10=2;
					try { DebugEnterSubRule(10);
					try { DebugEnterDecision(10, false);
					int LA10_1 = input.LA(1);

					if ((LA10_1=='\n'||LA10_1=='\r'))
					{
						alt10 = 1;
					}
					} finally { DebugExitDecision(10); }
					switch (alt10)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:244:7: ( '\\r' )? '\\n'
						{
						DebugLocation(244, 7);
						// Language\\Template.g3:244:7: ( '\\r' )?
						int alt9=2;
						try { DebugEnterSubRule(9);
						try { DebugEnterDecision(9, false);
						int LA9_1 = input.LA(1);

						if ((LA9_1=='\r'))
						{
							alt9 = 1;
						}
						} finally { DebugExitDecision(9); }
						switch (alt9)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:244:8: '\\r'
							{
							DebugLocation(244, 8);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(9); }

						DebugLocation(244, 15);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(10); }


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\Template.g3:245:6: ( '$endif$' )=> '$endif$' ({...}? => ( '\\r' )? '\\n' )?
					{
					DebugLocation(246, 5);
					Match("$endif$"); if (state.failed) return;

					DebugLocation(247, 5);
					if (state.backtracking == 0)
					{

											Text = "endif";
											_type = TemplateParser.ENDIF;
										
					}
					DebugLocation(251, 5);
					// Language\\Template.g3:251:5: ({...}? => ( '\\r' )? '\\n' )?
					int alt12=2;
					try { DebugEnterSubRule(12);
					try { DebugEnterDecision(12, false);
					int LA12_1 = input.LA(1);

					if ((LA12_1=='\n'||LA12_1=='\r') && ((startCol==0)))
					{
						alt12 = 1;
					}
					} finally { DebugExitDecision(12); }
					switch (alt12)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:251:7: {...}? => ( '\\r' )? '\\n'
						{
						DebugLocation(251, 7);
						if (!((startCol==0)))
						{
							if (state.backtracking>0) {state.failed=true; return;}
							throw new FailedPredicateException(input, "ACTION", "startCol==0");
						}
						DebugLocation(251, 25);
						// Language\\Template.g3:251:25: ( '\\r' )?
						int alt11=2;
						try { DebugEnterSubRule(11);
						try { DebugEnterDecision(11, false);
						int LA11_1 = input.LA(1);

						if ((LA11_1=='\r'))
						{
							alt11 = 1;
						}
						} finally { DebugExitDecision(11); }
						switch (alt11)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:251:26: '\\r'
							{
							DebugLocation(251, 26);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(11); }

						DebugLocation(251, 33);
						Match('\n'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(12); }


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// Language\\Template.g3:255:5: ( '$@' )=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
					{
					DebugLocation(256, 5);
					if (state.backtracking == 0)
					{

											builder = new System.Text.StringBuilder();
										
					}
					DebugLocation(259, 5);
					Match("$@"); if (state.failed) return;

					DebugLocation(259, 10);
					// Language\\Template.g3:259:10: (ch=~ ( '$' | '(' ) )+
					int cnt13=0;
					try { DebugEnterSubRule(13);
					while (true)
					{
						int alt13=2;
						try { DebugEnterDecision(13, false);
						int LA13_1 = input.LA(1);

						if (((LA13_1>='\u0000' && LA13_1<='#')||(LA13_1>='%' && LA13_1<='\'')||(LA13_1>=')' && LA13_1<='\uFFFF')))
						{
							alt13 = 1;
						}


						} finally { DebugExitDecision(13); }
						switch (alt13)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:259:12: ch=~ ( '$' | '(' )
							{
							DebugLocation(259, 14);
							ch= input.LA(1);
							input.Consume();
							state.failed=false;
							DebugLocation(259, 26);
							if (state.backtracking == 0)
							{
								builder.Append((char)ch);
							}

							}
							break;

						default:
							if (cnt13 >= 1)
								goto loop13;

							if (state.backtracking>0) {state.failed=true; return;}
							EarlyExitException eee13 = new EarlyExitException( 13, input );
							DebugRecognitionException(eee13);
							throw eee13;
						}
						cnt13++;
					}
					loop13:
						;

					} finally { DebugExitSubRule(13); }

					DebugLocation(260, 5);
					if (state.backtracking == 0)
					{
						 t = builder.ToString(); 
					}
					DebugLocation(261, 5);
					// Language\\Template.g3:261:5: ( '()$' | '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
					int alt24=2;
					try { DebugEnterSubRule(24);
					try { DebugEnterDecision(24, false);
					int LA24_1 = input.LA(1);

					if ((LA24_1=='('))
					{
						alt24 = 1;
					}
					else if ((LA24_1=='$'))
					{
						alt24 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 24, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(24); }
					switch (alt24)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:261:7: '()$'
						{
						DebugLocation(261, 7);
						Match("()$"); if (state.failed) return;

						DebugLocation(262, 6);
						if (state.backtracking == 0)
						{

													_type = TemplateParser.REGION_REF;
												
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\Template.g3:265:7: '$' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+ ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( '$@end$' )=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
						{
						DebugLocation(265, 7);
						Match('$'); if (state.failed) return;
						DebugLocation(266, 6);
						if (state.backtracking == 0)
						{

													_type = TemplateParser.REGION_DEF;
													builder.Append("::=");
												
						}
						DebugLocation(270, 6);
						// Language\\Template.g3:270:6: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )?
						int alt15=2;
						try { DebugEnterSubRule(15);
						try { DebugEnterDecision(15, false);
						int LA15_1 = input.LA(1);

						if ((LA15_1=='\r'))
						{
							int LA15_2 = input.LA(2);

							if ((LA15_2=='\n'))
							{
								int LA15_3 = input.LA(3);

								if ((EvaluatePredicate(synpred9_Template_fragment)))
								{
									alt15 = 1;
								}
							}
						}
						else if ((LA15_1=='\n'))
						{
							int LA15_2 = input.LA(2);

							if ((EvaluatePredicate(synpred9_Template_fragment)))
							{
								alt15 = 1;
							}
						}
						} finally { DebugExitDecision(15); }
						switch (alt15)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:270:8: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
							{
							DebugLocation(270, 23);
							// Language\\Template.g3:270:23: ( '\\r' )?
							int alt14=2;
							try { DebugEnterSubRule(14);
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if ((LA14_1=='\r'))
							{
								alt14 = 1;
							}
							} finally { DebugExitDecision(14); }
							switch (alt14)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\Template.g3:270:24: '\\r'
								{
								DebugLocation(270, 24);
								Match('\r'); if (state.failed) return;

								}
								break;

							}
							} finally { DebugExitSubRule(14); }

							DebugLocation(270, 31);
							Match('\n'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(15); }

						DebugLocation(271, 6);
						if (state.backtracking == 0)
						{
							atLeft = false;
						}
						DebugLocation(272, 6);
						// Language\\Template.g3:272:6: ({...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . ) )+
						int cnt18=0;
						try { DebugEnterSubRule(18);
						while (true)
						{
							int alt18=2;
							try { DebugEnterDecision(18, false);
							int LA18_1 = input.LA(1);

							if ((LA18_1=='\r'))
							{
								int LA18_2 = input.LA(2);

								if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}
							else if ((LA18_1=='\n'))
							{
								int LA18_2 = input.LA(2);

								if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}
							else if ((LA18_1=='$'))
							{
								int LA18_2 = input.LA(2);

								if ((LA18_2=='@'))
								{
									int LA18_3 = input.LA(3);

									if ((LA18_3=='e'))
									{
										int LA18_4 = input.LA(4);

										if ((LA18_4=='n'))
										{
											int LA18_5 = input.LA(5);

											if ((LA18_5=='d'))
											{
												int LA18_6 = input.LA(6);

												if ((LA18_6=='$'))
												{
													int LA18_7 = input.LA(7);

													if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
													{
														alt18 = 1;
													}


												}

												else
												{
													alt18 = 1;
												}


											}

											else
											{
												alt18 = 1;
											}


										}

										else
										{
											alt18 = 1;
										}


									}

									else
									{
										alt18 = 1;
									}


								}
								else if ((LA18_2=='\r'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if ((LA18_2=='\n'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if (((LA18_2>='\u0000' && LA18_2<='\t')||(LA18_2>='\u000B' && LA18_2<='\f')||(LA18_2>='\u000E' && LA18_2<='?')||(LA18_2>='A' && LA18_2<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}
							else if (((LA18_1>='\u0000' && LA18_1<='\t')||(LA18_1>='\u000B' && LA18_1<='\f')||(LA18_1>='\u000E' && LA18_1<='#')||(LA18_1>='%' && LA18_1<='\uFFFF')))
							{
								int LA18_2 = input.LA(2);

								if ((LA18_2=='\r'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if ((LA18_2=='\n'))
								{
									int LA18_3 = input.LA(3);

									if (((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
									{
										alt18 = 1;
									}


								}
								else if (((LA18_2>='\u0000' && LA18_2<='\t')||(LA18_2>='\u000B' && LA18_2<='\f')||(LA18_2>='\u000E' && LA18_2<='\uFFFF')) && ((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									alt18 = 1;
								}


							}


							} finally { DebugExitDecision(18); }
							switch (alt18)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\Template.g3:272:8: {...}? => ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . )
								{
								DebugLocation(272, 8);
								if (!((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))))
								{
									if (state.backtracking>0) {state.failed=true; return;}
									throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
								}
								DebugLocation(273, 7);
								// Language\\Template.g3:273:7: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' |ch= . )
								int alt17=2;
								try { DebugEnterSubRule(17);
								try { DebugEnterDecision(17, false);
								int LA17_1 = input.LA(1);

								if ((LA17_1=='\r'))
								{
									int LA17_2 = input.LA(2);

									if ((EvaluatePredicate(synpred10_Template_fragment)))
									{
										alt17 = 1;
									}
									else if ((true))
									{
										alt17 = 2;
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return;}
										NoViableAltException nvae = new NoViableAltException("", 17, 1, input, 2);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else if ((LA17_1=='\n'))
								{
									int LA17_2 = input.LA(2);

									if ((EvaluatePredicate(synpred10_Template_fragment)))
									{
										alt17 = 1;
									}
									else if ((true))
									{
										alt17 = 2;
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return;}
										NoViableAltException nvae = new NoViableAltException("", 17, 2, input, 2);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else if (((LA17_1>='\u0000' && LA17_1<='\t')||(LA17_1>='\u000B' && LA17_1<='\f')||(LA17_1>='\u000E' && LA17_1<='\uFFFF')))
								{
									alt17 = 2;
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return;}
									NoViableAltException nvae = new NoViableAltException("", 17, 0, input, 1);
									DebugRecognitionException(nvae);
									throw nvae;
								}
								} finally { DebugExitDecision(17); }
								switch (alt17)
								{
								case 1:
									DebugEnterAlt(1);
									// Language\\Template.g3:273:9: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
									{
									DebugLocation(273, 24);
									// Language\\Template.g3:273:24: ( '\\r' )?
									int alt16=2;
									try { DebugEnterSubRule(16);
									try { DebugEnterDecision(16, false);
									int LA16_1 = input.LA(1);

									if ((LA16_1=='\r'))
									{
										alt16 = 1;
									}
									} finally { DebugExitDecision(16); }
									switch (alt16)
									{
									case 1:
										DebugEnterAlt(1);
										// Language\\Template.g3:273:25: '\\r'
										{
										DebugLocation(273, 25);
										Match('\r'); if (state.failed) return;
										DebugLocation(273, 30);
										if (state.backtracking == 0)
										{
											builder.Append('\r');
										}

										}
										break;

									}
									} finally { DebugExitSubRule(16); }

									DebugLocation(273, 56);
									Match('\n'); if (state.failed) return;
									DebugLocation(273, 61);
									if (state.backtracking == 0)
									{
										builder.Append('\n'); atLeft = true;
									}

									}
									break;
								case 2:
									DebugEnterAlt(2);
									// Language\\Template.g3:274:9: ch= .
									{
									DebugLocation(274, 11);

									ch = input.LA(1);

									MatchAny(); if (state.failed) return;
									DebugLocation(274, 14);
									if (state.backtracking == 0)
									{
										builder.Append((char)ch); atLeft = false;
									}

									}
									break;

								}
								} finally { DebugExitSubRule(17); }


								}
								break;

							default:
								if (cnt18 >= 1)
									goto loop18;

								if (state.backtracking>0) {state.failed=true; return;}
								EarlyExitException eee18 = new EarlyExitException( 18, input );
								DebugRecognitionException(eee18);
								throw eee18;
							}
							cnt18++;
						}
						loop18:
							;

						} finally { DebugExitSubRule(18); }

						DebugLocation(277, 6);
						// Language\\Template.g3:277:6: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )?
						int alt20=2;
						try { DebugEnterSubRule(20);
						try { DebugEnterDecision(20, false);
						int LA20_1 = input.LA(1);

						if ((LA20_1=='\r'))
						{
							int LA20_2 = input.LA(2);

							if ((LA20_2=='\n'))
							{
								int LA20_3 = input.LA(3);

								if ((LA20_3=='$') && (EvaluatePredicate(synpred11_Template_fragment)))
								{
									alt20 = 1;
								}
								else if (((LA20_3>='\u0000' && LA20_3<='#')||(LA20_3>='%' && LA20_3<='\uFFFF')) && (EvaluatePredicate(synpred11_Template_fragment)))
								{
									alt20 = 1;
								}
							}
						}
						else if ((LA20_1=='\n'))
						{
							int LA20_2 = input.LA(2);

							if ((LA20_2=='$') && (EvaluatePredicate(synpred11_Template_fragment)))
							{
								alt20 = 1;
							}
							else if ((LA20_2=='\r'))
							{
								int LA20_3 = input.LA(3);

								if ((EvaluatePredicate(synpred11_Template_fragment)))
								{
									alt20 = 1;
								}
							}
							else if ((LA20_2=='\n'))
							{
								int LA20_3 = input.LA(3);

								if ((EvaluatePredicate(synpred11_Template_fragment)))
								{
									alt20 = 1;
								}
							}
							else if (((LA20_2>='\u0000' && LA20_2<='\t')||(LA20_2>='\u000B' && LA20_2<='\f')||(LA20_2>='\u000E' && LA20_2<='#')||(LA20_2>='%' && LA20_2<='\uFFFF')) && (EvaluatePredicate(synpred11_Template_fragment)))
							{
								alt20 = 1;
							}
						}
						} finally { DebugExitDecision(20); }
						switch (alt20)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:277:8: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
							{
							DebugLocation(277, 23);
							// Language\\Template.g3:277:23: ( '\\r' )?
							int alt19=2;
							try { DebugEnterSubRule(19);
							try { DebugEnterDecision(19, false);
							int LA19_1 = input.LA(1);

							if ((LA19_1=='\r'))
							{
								alt19 = 1;
							}
							} finally { DebugExitDecision(19); }
							switch (alt19)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\Template.g3:277:24: '\\r'
								{
								DebugLocation(277, 24);
								Match('\r'); if (state.failed) return;

								}
								break;

							}
							} finally { DebugExitSubRule(19); }

							DebugLocation(277, 31);
							Match('\n'); if (state.failed) return;
							DebugLocation(277, 36);
							if (state.backtracking == 0)
							{
								atLeft = true;
							}

							}
							break;

						}
						} finally { DebugExitSubRule(20); }

						DebugLocation(278, 6);
						// Language\\Template.g3:278:6: ( ( '$@end$' )=> '$@end$' | . )
						int alt21=2;
						try { DebugEnterSubRule(21);
						try { DebugEnterDecision(21, false);
						int LA21_1 = input.LA(1);

						if ((LA21_1=='$'))
						{
							int LA21_2 = input.LA(2);

							if ((LA21_2=='@') && (EvaluatePredicate(synpred12_Template_fragment)))
							{
								alt21 = 1;
							}
							else
							{
								alt21 = 2;
							}
						}
						else if (((LA21_1>='\u0000' && LA21_1<='#')||(LA21_1>='%' && LA21_1<='\uFFFF')))
						{
							alt21 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(21); }
						switch (alt21)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:278:8: ( '$@end$' )=> '$@end$'
							{
							DebugLocation(278, 22);
							Match("$@end$"); if (state.failed) return;


							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Language\\Template.g3:279:8: .
							{
							DebugLocation(279, 8);
							MatchAny(); if (state.failed) return;
							DebugLocation(279, 10);
							if (state.backtracking == 0)
							{
								self.Error("missing region "+t+" $@end$ tag");
							}

							}
							break;

						}
						} finally { DebugExitSubRule(21); }

						DebugLocation(281, 6);
						// Language\\Template.g3:281:6: ({...}? ( '\\r' )? '\\n' )?
						int alt23=2;
						try { DebugEnterSubRule(23);
						try { DebugEnterDecision(23, false);
						int LA23_1 = input.LA(1);

						if ((LA23_1=='\n'||LA23_1=='\r'))
						{
							alt23 = 1;
						}
						} finally { DebugExitDecision(23); }
						switch (alt23)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:281:8: {...}? ( '\\r' )? '\\n'
							{
							DebugLocation(281, 8);
							if (!((atLeft)))
							{
								if (state.backtracking>0) {state.failed=true; return;}
								throw new FailedPredicateException(input, "ACTION", "atLeft");
							}
							DebugLocation(281, 18);
							// Language\\Template.g3:281:18: ( '\\r' )?
							int alt22=2;
							try { DebugEnterSubRule(22);
							try { DebugEnterDecision(22, false);
							int LA22_1 = input.LA(1);

							if ((LA22_1=='\r'))
							{
								alt22 = 1;
							}
							} finally { DebugExitDecision(22); }
							switch (alt22)
							{
							case 1:
								DebugEnterAlt(1);
								// Language\\Template.g3:281:19: '\\r'
								{
								DebugLocation(281, 19);
								Match('\r'); if (state.failed) return;

								}
								break;

							}
							} finally { DebugExitSubRule(22); }

							DebugLocation(281, 26);
							Match('\n'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(23); }


						}
						break;

					}
					} finally { DebugExitSubRule(24); }

					DebugLocation(283, 5);
					if (state.backtracking == 0)
					{

											Text = builder.ToString();
										
					}

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// Language\\Template.g3:286:6: '$' EXPR[out subtext] '$'
					{
					DebugLocation(286, 6);
					Match('$'); if (state.failed) return;
					DebugLocation(286, 10);
					mEXPR(out subtext); if (state.failed) return;
					DebugLocation(286, 28);
					Match('$'); if (state.failed) return;
					DebugLocation(287, 5);
					if (state.backtracking == 0)
					{
						 Text = subtext; 
					}

					}
					break;

				}
				} finally { DebugExitSubRule(25); }

				DebugLocation(289, 4);
				if (state.backtracking == 0)
				{

									//ChunkToken t = new ChunkToken(_type, Text, currentIndent);
									//state.token = t;
									state.token = new ChunkToken(_type, Text, currentIndent);
								
				}

				}
				break;

			}
			} finally { DebugExitSubRule(26); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ACTION", 8);
			LeaveRule("ACTION", 8);
			LeaveRule_ACTION();
		}
	}
	// $ANTLR end "ACTION"

	partial void EnterRule_LITERAL();
	partial void LeaveRule_LITERAL();

	// $ANTLR start "LITERAL"
	[GrammarRule("LITERAL")]
	private void mLITERAL()
	{
		EnterRule_LITERAL();
		EnterRule("LITERAL", 9);
		TraceIn("LITERAL", 9);
		try
		{
			int _type = LITERAL;
			int _channel = DefaultTokenChannel;
			CommonToken ind = default(CommonToken);
			int ch = 0;


				int loopStartIndex = Text.Length;
				int col = CharPositionInLine;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\Template.g3:304:2: ( ( '\\\\' ( ( EOF )=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
			DebugEnterAlt(1);
			// Language\\Template.g3:304:4: ( '\\\\' ( ( EOF )=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
			{
			DebugLocation(304, 4);
			// Language\\Template.g3:304:4: ( '\\\\' ( ( EOF )=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=4;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1=='\\'))
				{
					alt29 = 1;
				}
				else if ((LA29_1=='\t'||LA29_1==' '))
				{
					alt29 = 2;
				}
				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='#')||(LA29_1>='%' && LA29_1<='[')||(LA29_1>=']' && LA29_1<='\uFFFF')))
				{
					alt29 = 3;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:304:6: '\\\\' ( ( EOF )=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) )
					{
					DebugLocation(304, 6);
					Match('\\'); if (state.failed) return;
					DebugLocation(305, 4);
					// Language\\Template.g3:305:4: ( ( EOF )=> EOF | ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) )
					int alt28=2;
					try { DebugEnterSubRule(28);
					try { DebugEnterDecision(28, false);
					int LA28_1 = input.LA(1);

					if ((LA28_1=='\\'))
					{
						int LA28_2 = input.LA(2);

						if ((EvaluatePredicate(synpred13_Template_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 28, 2, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA28_1=='\t'||LA28_1==' '))
					{
						int LA28_2 = input.LA(2);

						if ((EvaluatePredicate(synpred13_Template_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 28, 3, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if (((LA28_1>='\u0000' && LA28_1<='\b')||(LA28_1>='\u000B' && LA28_1<='\f')||(LA28_1>='\u000E' && LA28_1<='\u001F')||(LA28_1>='!' && LA28_1<='#')||(LA28_1>='%' && LA28_1<='[')||(LA28_1>=']' && LA28_1<='\uFFFF')))
					{
						int LA28_2 = input.LA(2);

						if ((EvaluatePredicate(synpred13_Template_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 28, 4, input, 2);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else if ((LA28_1=='\n'||LA28_1=='\r'||LA28_1=='$'))
					{
						alt28 = 2;
					}
					else
					{
						alt28 = 1;
					}
					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:305:6: ( EOF )=> EOF
						{
						DebugLocation(305, 15);
						Match(EOF); if (state.failed) return;
						DebugLocation(305, 20);
						if (state.backtracking == 0)
						{
							builder.Append("\\");
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\Template.g3:306:6: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
						{
						DebugLocation(306, 6);
						// Language\\Template.g3:306:6: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
						int alt27=3;
						try { DebugEnterSubRule(27);
						try { DebugEnterDecision(27, false);
						int LA27_1 = input.LA(1);

						if ((LA27_1=='$'))
						{
							alt27 = 1;
						}
						else if ((LA27_1=='\\'))
						{
							alt27 = 2;
						}
						else if (((LA27_1>='\u0000' && LA27_1<='#')||(LA27_1>='%' && LA27_1<='[')||(LA27_1>=']' && LA27_1<='\uFFFF')))
						{
							alt27 = 3;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						} finally { DebugExitDecision(27); }
						switch (alt27)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:306:8: '$'
							{
							DebugLocation(306, 8);
							Match('$'); if (state.failed) return;
							DebugLocation(306, 15);
							if (state.backtracking == 0)
							{
								builder.Append("$");
							}

							}
							break;
						case 2:
							DebugEnterAlt(2);
							// Language\\Template.g3:307:7: '\\\\'
							{
							DebugLocation(307, 7);
							Match('\\'); if (state.failed) return;
							DebugLocation(307, 14);
							if (state.backtracking == 0)
							{
								builder.Append("\\");
							}

							}
							break;
						case 3:
							DebugEnterAlt(3);
							// Language\\Template.g3:308:7: ch=~ ( '$' | '\\\\' )
							{
							DebugLocation(308, 9);
							ch= input.LA(1);
							input.Consume();
							state.failed=false;
							DebugLocation(308, 22);
							if (state.backtracking == 0)
							{
								builder.Append("\\" + (char)ch);
							}

							}
							break;

						}
						} finally { DebugExitSubRule(27); }


						}
						break;

					}
					} finally { DebugExitSubRule(28); }


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:311:5: ind= INDENT
					{
					DebugLocation(311, 8);
					int indStart801 = CharIndex;
					int indStartLine801 = Line;
					int indStartCharPos801 = CharPositionInLine;
					mINDENT(); if (state.failed) return;
					ind = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, indStart801, CharIndex-1);
					ind.Line = indStartLine801;
					ind.CharPositionInLine = indStartCharPos801;
					DebugLocation(312, 4);
					if (state.backtracking == 0)
					{

										loopStartIndex = builder.Length;
										col = CharPositionInLine - (ind!=null?ind.Text:default(string)).Length;

										builder.Append( (ind!=null?ind.Text:default(string)) );
										if ( col==0 && input.LA(1)=='$' )
										{
											// store indent in ASTExpr not in a literal
											currentIndent=(ind!=null?ind.Text:default(string));
											//text.setLength(loopStartIndex); // reset length to wack text
											builder.Length = loopStartIndex; //= Text.Substring( 0, loopStartIndex );
										}
										else
										{
											currentIndent=null;
										}
									
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:329:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
					{
					DebugLocation(329, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(329, 39);
					if (state.backtracking == 0)
					{
						builder.Append((char)ch);
					}

					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }

			DebugLocation(331, 3);
			if (state.backtracking == 0)
			{
				Text = builder.ToString();
			}
			DebugLocation(332, 3);
			if (state.backtracking == 0)
			{
				if (Text.Length==0) {_channel = Hidden;}
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LITERAL", 9);
			LeaveRule("LITERAL", 9);
			LeaveRule_LITERAL();
		}
	}
	// $ANTLR end "LITERAL"

	partial void EnterRule_EXPR();
	partial void LeaveRule_EXPR();

	// $ANTLR start "EXPR"
	[GrammarRule("EXPR")]
	private void mEXPR(out string _text)
	{
		EnterRule_EXPR();
		EnterRule("EXPR", 10);
		TraceIn("EXPR", 10);
		try
		{
			CommonToken st = default(CommonToken);
			CommonToken ESC1 = default(CommonToken);
			int ch = 0;


				_text = string.Empty;
				string subtext = string.Empty;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\Template.g3:344:2: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
			DebugEnterAlt(1);
			// Language\\Template.g3:344:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
			{
			DebugLocation(344, 4);
			// Language\\Template.g3:344:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
			int cnt32=0;
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=5;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1=='\\'))
				{
					alt32 = 1;
				}
				else if ((LA32_1=='{'))
				{
					alt32 = 2;
				}
				else if ((LA32_1=='+'||LA32_1=='='))
				{
					alt32 = 3;
				}
				else if (((LA32_1>='\u0000' && LA32_1<='#')||(LA32_1>='%' && LA32_1<='*')||(LA32_1>=',' && LA32_1<='<')||(LA32_1>='>' && LA32_1<='[')||(LA32_1>=']' && LA32_1<='z')||(LA32_1>='|' && LA32_1<='\uFFFF')))
				{
					alt32 = 4;
				}


				} finally { DebugExitDecision(32); }
				switch (alt32)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:344:6: ESC
					{
					DebugLocation(344, 6);
					int ESC1Start863 = CharIndex;
					int ESC1StartLine863 = Line;
					int ESC1StartCharPos863 = CharPositionInLine;
					mESC(); if (state.failed) return;
					ESC1 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC1Start863, CharIndex-1);
					ESC1.Line = ESC1StartLine863;
					ESC1.CharPositionInLine = ESC1StartCharPos863;
					DebugLocation(344, 16);
					if (state.backtracking == 0)
					{
						builder.Append((ESC1!=null?ESC1.Text:default(string)));
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:345:5: st= SUBTEMPLATE
					{
					DebugLocation(345, 7);
					int stStart879 = CharIndex;
					int stStartLine879 = Line;
					int stStartCharPos879 = CharPositionInLine;
					mSUBTEMPLATE(); if (state.failed) return;
					st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart879, CharIndex-1);
					st.Line = stStartLine879;
					st.CharPositionInLine = stStartCharPos879;
					DebugLocation(345, 23);
					if (state.backtracking == 0)
					{
						builder.Append((st!=null?st.Text:default(string)));
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:346:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
					{
					DebugLocation(346, 5);
					// Language\\Template.g3:346:5: ( '=' | '+' )
					int alt30=2;
					try { DebugEnterSubRule(30);
					try { DebugEnterDecision(30, false);
					int LA30_1 = input.LA(1);

					if ((LA30_1=='='))
					{
						alt30 = 1;
					}
					else if ((LA30_1=='+'))
					{
						alt30 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 30, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(30); }
					switch (alt30)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:346:7: '='
						{
						DebugLocation(346, 7);
						Match('='); if (state.failed) return;
						DebugLocation(346, 16);
						if (state.backtracking == 0)
						{
							builder.Append('=');
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\Template.g3:347:6: '+'
						{
						DebugLocation(347, 6);
						Match('+'); if (state.failed) return;
						DebugLocation(347, 15);
						if (state.backtracking == 0)
						{
							builder.Append('+');
						}

						}
						break;

					}
					} finally { DebugExitSubRule(30); }

					DebugLocation(349, 4);
					// Language\\Template.g3:349:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
					int alt31=3;
					try { DebugEnterSubRule(31);
					try { DebugEnterDecision(31, false);
					int LA31_1 = input.LA(1);

					if ((LA31_1=='\"'||LA31_1=='<'))
					{
						alt31 = 1;
					}
					else if ((LA31_1=='{'))
					{
						alt31 = 2;
					}
					else if (((LA31_1>='\u0000' && LA31_1<='!')||(LA31_1>='#' && LA31_1<=';')||(LA31_1>='=' && LA31_1<='z')||(LA31_1>='|' && LA31_1<='\uFFFF')))
					{
						alt31 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(31); }
					switch (alt31)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:349:6: TEMPLATE[out subtext]
						{
						DebugLocation(349, 6);
						mTEMPLATE(out subtext); if (state.failed) return;
						DebugLocation(349, 28);
						if (state.backtracking == 0)
						{
							builder.Append(subtext);
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\Template.g3:350:6: st= SUBTEMPLATE
						{
						DebugLocation(350, 8);
						int stStart937 = CharIndex;
						int stStartLine937 = Line;
						int stStartCharPos937 = CharPositionInLine;
						mSUBTEMPLATE(); if (state.failed) return;
						st = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, stStart937, CharIndex-1);
						st.Line = stStartLine937;
						st.CharPositionInLine = stStartCharPos937;
						DebugLocation(350, 23);
						if (state.backtracking == 0)
						{
							builder.Append((st!=null?st.Text:default(string)));
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// Language\\Template.g3:351:6: ch=~ ( '\"' | '<' | '{' )
						{
						DebugLocation(351, 8);
						ch= input.LA(1);
						input.Consume();
						state.failed=false;
						DebugLocation(351, 25);
						if (state.backtracking == 0)
						{
							builder.Append((char)ch);
						}

						}
						break;

					}
					} finally { DebugExitSubRule(31); }


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\Template.g3:353:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
					{
					DebugLocation(353, 7);
					ch= input.LA(1);
					input.Consume();
					state.failed=false;
					DebugLocation(353, 32);
					if (state.backtracking == 0)
					{
						builder.Append((char)ch);
					}

					}
					break;

				default:
					if (cnt32 >= 1)
						goto loop32;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee32 = new EarlyExitException( 32, input );
					DebugRecognitionException(eee32);
					throw eee32;
				}
				cnt32++;
			}
			loop32:
				;

			} finally { DebugExitSubRule(32); }

			DebugLocation(355, 3);
			if (state.backtracking == 0)
			{
				_text = builder.ToString();
			}

			}

		}
		finally
		{
			TraceOut("EXPR", 10);
			LeaveRule("EXPR", 10);
			LeaveRule_EXPR();
		}
	}
	// $ANTLR end "EXPR"

	partial void EnterRule_TEMPLATE();
	partial void LeaveRule_TEMPLATE();

	// $ANTLR start "TEMPLATE"
	[GrammarRule("TEMPLATE")]
	private void mTEMPLATE(out string _text)
	{
		EnterRule_TEMPLATE();
		EnterRule("TEMPLATE", 11);
		TraceIn("TEMPLATE", 11);
		try
		{
			CommonToken ESC2 = default(CommonToken);
			int ch = 0;


				_text = string.Empty;
				System.Text.StringBuilder builder = new System.Text.StringBuilder();

			// Language\\Template.g3:365:2: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n' |ch= . )* '>>' )
			int alt38=2;
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1=='\"'))
			{
				alt38 = 1;
			}
			else if ((LA38_1=='<'))
			{
				alt38 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 38, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:365:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
				{
				DebugLocation(365, 4);
				Match('\"'); if (state.failed) return;
				DebugLocation(366, 3);
				if (state.backtracking == 0)
				{
					builder.Append('"');
				}
				DebugLocation(367, 3);
				// Language\\Template.g3:367:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
				try { DebugEnterSubRule(33);
				while (true)
				{
					int alt33=3;
					try { DebugEnterDecision(33, false);
					int LA33_1 = input.LA(1);

					if ((LA33_1=='\\'))
					{
						alt33 = 1;
					}
					else if (((LA33_1>='\u0000' && LA33_1<='!')||(LA33_1>='#' && LA33_1<='[')||(LA33_1>=']' && LA33_1<='\uFFFF')))
					{
						alt33 = 2;
					}


					} finally { DebugExitDecision(33); }
					switch ( alt33 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:367:5: ESC
						{
						DebugLocation(367, 5);
						int ESC2Start1023 = CharIndex;
						int ESC2StartLine1023 = Line;
						int ESC2StartCharPos1023 = CharPositionInLine;
						mESC(); if (state.failed) return;
						ESC2 = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, ESC2Start1023, CharIndex-1);
						ESC2.Line = ESC2StartLine1023;
						ESC2.CharPositionInLine = ESC2StartCharPos1023;
						DebugLocation(367, 14);
						if (state.backtracking == 0)
						{
							builder.Append((ESC2!=null?ESC2.Text:default(string)));
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\Template.g3:368:5: ch=~ ( '\\\\' | '\"' )
						{
						DebugLocation(368, 7);
						ch= input.LA(1);
						input.Consume();
						state.failed=false;
						DebugLocation(368, 20);
						if (state.backtracking == 0)
						{
							builder.Append((char)ch);
						}

						}
						break;

					default:
						goto loop33;
					}
				}

				loop33:
					;

				} finally { DebugExitSubRule(33); }

				DebugLocation(370, 3);
				Match('\"'); if (state.failed) return;
				DebugLocation(371, 3);
				if (state.backtracking == 0)
				{

								builder.Append('"');
								_text = builder.ToString();
							
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Template.g3:375:4: '<<' ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )? ( ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n' |ch= . )* '>>'
				{
				DebugLocation(375, 4);
				Match("<<"); if (state.failed) return;

				DebugLocation(376, 3);
				if (state.backtracking == 0)
				{

								builder.Append("<<");
							
				}
				DebugLocation(379, 4);
				// Language\\Template.g3:379:4: ( ( '\\r' | '\\n' )=> ( '\\r' )? '\\n' )?
				int alt35=2;
				try { DebugEnterSubRule(35);
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1=='\r'))
				{
					int LA35_2 = input.LA(2);

					if ((LA35_2=='\n'))
					{
						int LA35_3 = input.LA(3);

						if ((EvaluatePredicate(synpred14_Template_fragment)))
						{
							alt35 = 1;
						}
					}
				}
				else if ((LA35_1=='\n'))
				{
					int LA35_2 = input.LA(2);

					if ((EvaluatePredicate(synpred14_Template_fragment)))
					{
						alt35 = 1;
					}
				}
				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:379:6: ( '\\r' | '\\n' )=> ( '\\r' )? '\\n'
					{
					DebugLocation(379, 21);
					// Language\\Template.g3:379:21: ( '\\r' )?
					int alt34=2;
					try { DebugEnterSubRule(34);
					try { DebugEnterDecision(34, false);
					int LA34_1 = input.LA(1);

					if ((LA34_1=='\r'))
					{
						alt34 = 1;
					}
					} finally { DebugExitDecision(34); }
					switch (alt34)
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:379:22: '\\r'
						{
						DebugLocation(379, 22);
						Match('\r'); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(34); }

					DebugLocation(379, 29);
					Match('\n'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(35); }

				DebugLocation(381, 3);
				// Language\\Template.g3:381:3: ( ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n' |ch= . )*
				try { DebugEnterSubRule(37);
				while (true)
				{
					int alt37=3;
					try { DebugEnterDecision(37, false);
					int LA37_1 = input.LA(1);

					if ((LA37_1=='>'))
					{
						int LA37_2 = input.LA(2);

						if ((LA37_2=='>'))
						{
							int LA37_3 = input.LA(3);

							if (((LA37_3>='\u0000' && LA37_3<='\uFFFF')))
							{
								alt37 = 2;
							}


						}
						else if (((LA37_2>='\u0000' && LA37_2<='=')||(LA37_2>='?' && LA37_2<='\uFFFF')))
						{
							alt37 = 2;
						}


					}
					else if ((LA37_1=='\r'))
					{
						int LA37_2 = input.LA(2);

						if ((EvaluatePredicate(synpred15_Template_fragment)))
						{
							alt37 = 1;
						}
						else if ((true))
						{
							alt37 = 2;
						}


					}
					else if ((LA37_1=='\n'))
					{
						int LA37_2 = input.LA(2);

						if ((EvaluatePredicate(synpred15_Template_fragment)))
						{
							alt37 = 1;
						}
						else if ((true))
						{
							alt37 = 2;
						}


					}
					else if (((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')))
					{
						alt37 = 2;
					}


					} finally { DebugExitDecision(37); }
					switch ( alt37 )
					{
					case 1:
						DebugEnterAlt(1);
						// Language\\Template.g3:381:5: ( ( '\\r' )? '\\n>>' )=> ( '\\r' )? '\\n'
						{
						DebugLocation(381, 23);
						// Language\\Template.g3:381:23: ( '\\r' )?
						int alt36=2;
						try { DebugEnterSubRule(36);
						try { DebugEnterDecision(36, false);
						int LA36_1 = input.LA(1);

						if ((LA36_1=='\r'))
						{
							alt36 = 1;
						}
						} finally { DebugExitDecision(36); }
						switch (alt36)
						{
						case 1:
							DebugEnterAlt(1);
							// Language\\Template.g3:381:24: '\\r'
							{
							DebugLocation(381, 24);
							Match('\r'); if (state.failed) return;

							}
							break;

						}
						} finally { DebugExitSubRule(36); }

						DebugLocation(381, 31);
						Match('\n'); if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Language\\Template.g3:382:5: ch= .
						{
						DebugLocation(382, 7);

						ch = input.LA(1);

						MatchAny(); if (state.failed) return;
						DebugLocation(382, 10);
						if (state.backtracking == 0)
						{
							builder.Append((char)ch);
						}

						}
						break;

					default:
						goto loop37;
					}
				}

				loop37:
					;

				} finally { DebugExitSubRule(37); }

				DebugLocation(384, 3);
				Match(">>"); if (state.failed) return;

				DebugLocation(385, 3);
				if (state.backtracking == 0)
				{

								builder.Append(">>");
								_text = builder.ToString();
							
				}

				}
				break;

			}
		}
		finally
		{
			TraceOut("TEMPLATE", 11);
			LeaveRule("TEMPLATE", 11);
			LeaveRule_TEMPLATE();
		}
	}
	// $ANTLR end "TEMPLATE"

	partial void EnterRule_IF_EXPR();
	partial void LeaveRule_IF_EXPR();

	// $ANTLR start "IF_EXPR"
	[GrammarRule("IF_EXPR")]
	private void mIF_EXPR()
	{
		EnterRule_IF_EXPR();
		EnterRule("IF_EXPR", 12);
		TraceIn("IF_EXPR", 12);
		try
		{
			// Language\\Template.g3:393:2: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
			DebugEnterAlt(1);
			// Language\\Template.g3:393:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
			{
			DebugLocation(393, 4);
			// Language\\Template.g3:393:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
			int cnt39=0;
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=5;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1=='\\'))
				{
					alt39 = 1;
				}
				else if ((LA39_1=='{'))
				{
					alt39 = 2;
				}
				else if ((LA39_1=='('))
				{
					alt39 = 3;
				}
				else if (((LA39_1>='\u0000' && LA39_1<='\'')||(LA39_1>='*' && LA39_1<='[')||(LA39_1>=']' && LA39_1<='z')||(LA39_1>='|' && LA39_1<='\uFFFF')))
				{
					alt39 = 4;
				}


				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:393:6: ESC
					{
					DebugLocation(393, 6);
					mESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:394:5: SUBTEMPLATE
					{
					DebugLocation(394, 5);
					mSUBTEMPLATE(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:395:5: NESTED_PARENS
					{
					DebugLocation(395, 5);
					mNESTED_PARENS(); if (state.failed) return;

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Language\\Template.g3:396:5: ~ ( '\\\\' | '{' | '(' | ')' )
					{
					DebugLocation(396, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt39 >= 1)
						goto loop39;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee39 = new EarlyExitException( 39, input );
					DebugRecognitionException(eee39);
					throw eee39;
				}
				cnt39++;
			}
			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

		}
		finally
		{
			TraceOut("IF_EXPR", 12);
			LeaveRule("IF_EXPR", 12);
			LeaveRule_IF_EXPR();
		}
	}
	// $ANTLR end "IF_EXPR"

	partial void EnterRule_ESC_CHAR();
	partial void LeaveRule_ESC_CHAR();

	// $ANTLR start "ESC_CHAR"
	[GrammarRule("ESC_CHAR")]
	private void mESC_CHAR(out char uc)
	{
		EnterRule_ESC_CHAR();
		EnterRule("ESC_CHAR", 13);
		TraceIn("ESC_CHAR", 13);
		try
		{
			CommonToken a = default(CommonToken);
			CommonToken b = default(CommonToken);
			CommonToken c = default(CommonToken);
			CommonToken d = default(CommonToken);


				uc = '\0';

			// Language\\Template.g3:406:2: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
			int alt40=5;
			try { DebugEnterDecision(40, false);
			int LA40_1 = input.LA(1);

			if ((LA40_1=='\\'))
			{
				switch (input.LA(2))
				{
				case 'n':
					{
					alt40 = 1;
					}
					break;
				case 'r':
					{
					alt40 = 2;
					}
					break;
				case 't':
					{
					alt40 = 3;
					}
					break;
				case ' ':
					{
					alt40 = 4;
					}
					break;
				case 'u':
					{
					alt40 = 5;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 40, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 40, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:406:4: '\\\\n'
				{
				DebugLocation(406, 4);
				Match("\\n"); if (state.failed) return;

				DebugLocation(406, 10);
				if (state.backtracking == 0)
				{
					uc = '\n';
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Language\\Template.g3:407:4: '\\\\r'
				{
				DebugLocation(407, 4);
				Match("\\r"); if (state.failed) return;

				DebugLocation(407, 10);
				if (state.backtracking == 0)
				{
					uc = '\r';
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Language\\Template.g3:408:4: '\\\\t'
				{
				DebugLocation(408, 4);
				Match("\\t"); if (state.failed) return;

				DebugLocation(408, 10);
				if (state.backtracking == 0)
				{
					uc = '\t';
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Language\\Template.g3:409:4: '\\\\ '
				{
				DebugLocation(409, 4);
				Match("\\ "); if (state.failed) return;

				DebugLocation(409, 10);
				if (state.backtracking == 0)
				{
					uc = ' ';
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Language\\Template.g3:410:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
				{
				DebugLocation(410, 4);
				Match("\\u"); if (state.failed) return;

				DebugLocation(410, 11);
				int aStart1234 = CharIndex;
				int aStartLine1234 = Line;
				int aStartCharPos1234 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				a = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, aStart1234, CharIndex-1);
				a.Line = aStartLine1234;
				a.CharPositionInLine = aStartCharPos1234;
				DebugLocation(410, 17);
				int bStart1238 = CharIndex;
				int bStartLine1238 = Line;
				int bStartCharPos1238 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				b = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, bStart1238, CharIndex-1);
				b.Line = bStartLine1238;
				b.CharPositionInLine = bStartCharPos1238;
				DebugLocation(410, 23);
				int cStart1242 = CharIndex;
				int cStartLine1242 = Line;
				int cStartCharPos1242 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				c = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, cStart1242, CharIndex-1);
				c.Line = cStartLine1242;
				c.CharPositionInLine = cStartCharPos1242;
				DebugLocation(410, 29);
				int dStart1246 = CharIndex;
				int dStartLine1246 = Line;
				int dStartCharPos1246 = CharPositionInLine;
				mHEX(); if (state.failed) return;
				d = new CommonToken(input, TokenTypes.Invalid, TokenChannels.Default, dStart1246, CharIndex-1);
				d.Line = dStartLine1246;
				d.CharPositionInLine = dStartCharPos1246;
				DebugLocation(411, 3);
				if (state.backtracking == 0)
				{
					uc = (char)int.Parse((a!=null?a.Text:default(string))+(b!=null?b.Text:default(string))+(c!=null?c.Text:default(string))+(d!=null?d.Text:default(string)), System.Globalization.NumberStyles.AllowHexSpecifier);
				}

				}
				break;

			}
		}
		finally
		{
			TraceOut("ESC_CHAR", 13);
			LeaveRule("ESC_CHAR", 13);
			LeaveRule_ESC_CHAR();
		}
	}
	// $ANTLR end "ESC_CHAR"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	private void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 14);
		TraceIn("ESC", 14);
		try
		{
			// Language\\Template.g3:416:2: ( '\\\\' . )
			DebugEnterAlt(1);
			// Language\\Template.g3:416:4: '\\\\' .
			{
			DebugLocation(416, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(416, 9);
			MatchAny(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ESC", 14);
			LeaveRule("ESC", 14);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_HEX();
	partial void LeaveRule_HEX();

	// $ANTLR start "HEX"
	[GrammarRule("HEX")]
	private void mHEX()
	{
		EnterRule_HEX();
		EnterRule("HEX", 15);
		TraceIn("HEX", 15);
		try
		{
			// Language\\Template.g3:421:2: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
			DebugEnterAlt(1);
			// Language\\Template.g3:
			{
			DebugLocation(421, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HEX", 15);
			LeaveRule("HEX", 15);
			LeaveRule_HEX();
		}
	}
	// $ANTLR end "HEX"

	partial void EnterRule_SUBTEMPLATE();
	partial void LeaveRule_SUBTEMPLATE();

	// $ANTLR start "SUBTEMPLATE"
	[GrammarRule("SUBTEMPLATE")]
	private void mSUBTEMPLATE()
	{
		EnterRule_SUBTEMPLATE();
		EnterRule("SUBTEMPLATE", 16);
		TraceIn("SUBTEMPLATE", 16);
		try
		{
			// Language\\Template.g3:426:2: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
			DebugEnterAlt(1);
			// Language\\Template.g3:426:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
			{
			DebugLocation(426, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(427, 3);
			// Language\\Template.g3:427:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=4;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1=='{'))
				{
					alt41 = 1;
				}
				else if ((LA41_1=='\\'))
				{
					alt41 = 2;
				}
				else if (((LA41_1>='\u0000' && LA41_1<='[')||(LA41_1>=']' && LA41_1<='z')||LA41_1=='|'||(LA41_1>='~' && LA41_1<='\uFFFF')))
				{
					alt41 = 3;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:427:5: SUBTEMPLATE
					{
					DebugLocation(427, 5);
					mSUBTEMPLATE(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:428:5: ESC
					{
					DebugLocation(428, 5);
					mESC(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:429:5: ~ ( '{' | '\\\\' | '}' )
					{
					DebugLocation(429, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }

			DebugLocation(431, 3);
			Match('}'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("SUBTEMPLATE", 16);
			LeaveRule("SUBTEMPLATE", 16);
			LeaveRule_SUBTEMPLATE();
		}
	}
	// $ANTLR end "SUBTEMPLATE"

	partial void EnterRule_NESTED_PARENS();
	partial void LeaveRule_NESTED_PARENS();

	// $ANTLR start "NESTED_PARENS"
	[GrammarRule("NESTED_PARENS")]
	private void mNESTED_PARENS()
	{
		EnterRule_NESTED_PARENS();
		EnterRule("NESTED_PARENS", 17);
		TraceIn("NESTED_PARENS", 17);
		try
		{
			// Language\\Template.g3:436:2: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
			DebugEnterAlt(1);
			// Language\\Template.g3:436:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
			{
			DebugLocation(436, 4);
			Match('('); if (state.failed) return;
			DebugLocation(437, 3);
			// Language\\Template.g3:437:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
			int cnt42=0;
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=4;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1=='('))
				{
					alt42 = 1;
				}
				else if ((LA42_1=='\\'))
				{
					alt42 = 2;
				}
				else if (((LA42_1>='\u0000' && LA42_1<='\'')||(LA42_1>='*' && LA42_1<='[')||(LA42_1>=']' && LA42_1<='\uFFFF')))
				{
					alt42 = 3;
				}


				} finally { DebugExitDecision(42); }
				switch (alt42)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:437:5: NESTED_PARENS
					{
					DebugLocation(437, 5);
					mNESTED_PARENS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Language\\Template.g3:438:5: ESC
					{
					DebugLocation(438, 5);
					mESC(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Language\\Template.g3:439:5: ~ ( '(' | '\\\\' | ')' )
					{
					DebugLocation(439, 5);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt42 >= 1)
						goto loop42;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee42 = new EarlyExitException( 42, input );
					DebugRecognitionException(eee42);
					throw eee42;
				}
				cnt42++;
			}
			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(441, 3);
			Match(')'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("NESTED_PARENS", 17);
			LeaveRule("NESTED_PARENS", 17);
			LeaveRule_NESTED_PARENS();
		}
	}
	// $ANTLR end "NESTED_PARENS"

	partial void EnterRule_INDENT();
	partial void LeaveRule_INDENT();

	// $ANTLR start "INDENT"
	[GrammarRule("INDENT")]
	private void mINDENT()
	{
		EnterRule_INDENT();
		EnterRule("INDENT", 18);
		TraceIn("INDENT", 18);
		try
		{
			// Language\\Template.g3:446:2: ( ( ' ' | '\\t' )+ )
			DebugEnterAlt(1);
			// Language\\Template.g3:446:4: ( ' ' | '\\t' )+
			{
			DebugLocation(446, 4);
			// Language\\Template.g3:446:4: ( ' ' | '\\t' )+
			int cnt43=0;
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1=='\t'||LA43_1==' '))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:
					{
					DebugLocation(446, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt43 >= 1)
						goto loop43;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee43 = new EarlyExitException( 43, input );
					DebugRecognitionException(eee43);
					throw eee43;
				}
				cnt43++;
			}
			loop43:
				;

			} finally { DebugExitSubRule(43); }


			}

		}
		finally
		{
			TraceOut("INDENT", 18);
			LeaveRule("INDENT", 18);
			LeaveRule_INDENT();
		}
	}
	// $ANTLR end "INDENT"

	partial void EnterRule_COMMENT();
	partial void LeaveRule_COMMENT();

	// $ANTLR start "COMMENT"
	[GrammarRule("COMMENT")]
	private void mCOMMENT()
	{
		EnterRule_COMMENT();
		EnterRule("COMMENT", 19);
		TraceIn("COMMENT", 19);
		try
		{

				int startCol = CharPositionInLine;

			// Language\\Template.g3:455:2: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
			DebugEnterAlt(1);
			// Language\\Template.g3:455:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
			{
			DebugLocation(455, 4);
			Match("$!"); if (state.failed) return;

			DebugLocation(455, 9);
			// Language\\Template.g3:455:9: ( . )*
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1=='!'))
				{
					int LA44_2 = input.LA(2);

					if ((LA44_2=='$'))
					{
						alt44 = 2;
					}
					else if (((LA44_2>='\u0000' && LA44_2<='#')||(LA44_2>='%' && LA44_2<='\uFFFF')))
					{
						alt44 = 1;
					}


				}
				else if (((LA44_1>='\u0000' && LA44_1<=' ')||(LA44_1>='\"' && LA44_1<='\uFFFF')))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch ( alt44 )
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:455:9: .
					{
					DebugLocation(455, 9);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop44;
				}
			}

			loop44:
				;

			} finally { DebugExitSubRule(44); }

			DebugLocation(455, 12);
			Match("!$"); if (state.failed) return;

			DebugLocation(455, 17);
			// Language\\Template.g3:455:17: ({...}? => ( '\\r' )? '\\n' )?
			int alt46=2;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1=='\n'||LA46_1=='\r') && ((startCol==0)))
			{
				alt46 = 1;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:455:19: {...}? => ( '\\r' )? '\\n'
				{
				DebugLocation(455, 19);
				if (!((startCol==0)))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "COMMENT", "startCol==0");
				}
				DebugLocation(455, 37);
				// Language\\Template.g3:455:37: ( '\\r' )?
				int alt45=2;
				try { DebugEnterSubRule(45);
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1=='\r'))
				{
					alt45 = 1;
				}
				} finally { DebugExitDecision(45); }
				switch (alt45)
				{
				case 1:
					DebugEnterAlt(1);
					// Language\\Template.g3:455:38: '\\r'
					{
					DebugLocation(455, 38);
					Match('\r'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(45); }

				DebugLocation(455, 45);
				Match('\n'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(46); }


			}

		}
		finally
		{
			TraceOut("COMMENT", 19);
			LeaveRule("COMMENT", 19);
			LeaveRule_COMMENT();
		}
	}
	// $ANTLR end "COMMENT"

	partial void EnterRule_LINE_BREAK();
	partial void LeaveRule_LINE_BREAK();

	// $ANTLR start "LINE_BREAK"
	[GrammarRule("LINE_BREAK")]
	private void mLINE_BREAK()
	{
		EnterRule_LINE_BREAK();
		EnterRule("LINE_BREAK", 20);
		TraceIn("LINE_BREAK", 20);
		try
		{
			// Language\\Template.g3:460:2: ( '$\\\\\\\\$' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )? )
			DebugEnterAlt(1);
			// Language\\Template.g3:460:4: '$\\\\\\\\$' ( INDENT )? ( '\\r' )? '\\n' ( INDENT )?
			{
			DebugLocation(460, 4);
			Match("$\\\\$"); if (state.failed) return;

			DebugLocation(460, 13);
			// Language\\Template.g3:460:13: ( INDENT )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1=='\t'||LA47_1==' '))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:460:13: INDENT
				{
				DebugLocation(460, 13);
				mINDENT(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(47); }

			DebugLocation(460, 21);
			// Language\\Template.g3:460:21: ( '\\r' )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1=='\r'))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:460:21: '\\r'
				{
				DebugLocation(460, 21);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(48); }

			DebugLocation(460, 27);
			Match('\n'); if (state.failed) return;
			DebugLocation(460, 32);
			// Language\\Template.g3:460:32: ( INDENT )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1=='\t'||LA49_1==' '))
			{
				alt49 = 1;
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:460:32: INDENT
				{
				DebugLocation(460, 32);
				mINDENT(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(49); }


			}

		}
		finally
		{
			TraceOut("LINE_BREAK", 20);
			LeaveRule("LINE_BREAK", 20);
			LeaveRule_LINE_BREAK();
		}
	}
	// $ANTLR end "LINE_BREAK"

	public override void mTokens()
	{
		// Language\\Template.g3:1:8: ( NEWLINE | ACTION | LITERAL )
		int alt50=3;
		try { DebugEnterDecision(50, false);
		int LA50_1 = input.LA(1);

		if ((LA50_1=='\n'||LA50_1=='\r'))
		{
			alt50 = 1;
		}
		else if ((LA50_1=='$'))
		{
			alt50 = 2;
		}
		else if (((LA50_1>='\u0000' && LA50_1<='\t')||(LA50_1>='\u000B' && LA50_1<='\f')||(LA50_1>='\u000E' && LA50_1<='#')||(LA50_1>='%' && LA50_1<='\uFFFF')))
		{
			alt50 = 3;
		}
		else
		{
			if (state.backtracking>0) {state.failed=true; return;}
			NoViableAltException nvae = new NoViableAltException("", 50, 0, input, 1);
			DebugRecognitionException(nvae);
			throw nvae;
		}
		} finally { DebugExitDecision(50); }
		switch (alt50)
		{
		case 1:
			DebugEnterAlt(1);
			// Language\\Template.g3:1:10: NEWLINE
			{
			DebugLocation(1, 10);
			mNEWLINE(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Language\\Template.g3:1:18: ACTION
			{
			DebugLocation(1, 18);
			mACTION(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Language\\Template.g3:1:25: LITERAL
			{
			DebugLocation(1, 25);
			mLITERAL(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_Template_fragment();
	partial void LeaveRule_synpred1_Template_fragment();

	// $ANTLR start synpred1_Template
	private void synpred1_Template_fragment()
	{
		EnterRule_synpred1_Template_fragment();
		EnterRule("synpred1_Template_fragment", 22);
		TraceIn("synpred1_Template_fragment", 22);
		try
		{
			// Language\\Template.g3:214:4: ( LINE_BREAK )
			DebugEnterAlt(1);
			// Language\\Template.g3:214:5: LINE_BREAK
			{
			DebugLocation(214, 5);
			mLINE_BREAK(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_Template_fragment", 22);
			LeaveRule("synpred1_Template_fragment", 22);
			LeaveRule_synpred1_Template_fragment();
		}
	}
	// $ANTLR end synpred1_Template

	partial void EnterRule_synpred2_Template_fragment();
	partial void LeaveRule_synpred2_Template_fragment();

	// $ANTLR start synpred2_Template
	private void synpred2_Template_fragment()
	{
		EnterRule_synpred2_Template_fragment();
		EnterRule("synpred2_Template_fragment", 23);
		TraceIn("synpred2_Template_fragment", 23);
		try
		{
			// Language\\Template.g3:215:5: ( '$\\\\' )
			DebugEnterAlt(1);
			// Language\\Template.g3:215:6: '$\\\\'
			{
			DebugLocation(215, 6);
			Match("$\\"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred2_Template_fragment", 23);
			LeaveRule("synpred2_Template_fragment", 23);
			LeaveRule_synpred2_Template_fragment();
		}
	}
	// $ANTLR end synpred2_Template

	partial void EnterRule_synpred3_Template_fragment();
	partial void LeaveRule_synpred3_Template_fragment();

	// $ANTLR start synpred3_Template
	private void synpred3_Template_fragment()
	{
		EnterRule_synpred3_Template_fragment();
		EnterRule("synpred3_Template_fragment", 24);
		TraceIn("synpred3_Template_fragment", 24);
		try
		{
			// Language\\Template.g3:222:5: ( '$!' )
			DebugEnterAlt(1);
			// Language\\Template.g3:222:6: '$!'
			{
			DebugLocation(222, 6);
			Match("$!"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred3_Template_fragment", 24);
			LeaveRule("synpred3_Template_fragment", 24);
			LeaveRule_synpred3_Template_fragment();
		}
	}
	// $ANTLR end synpred3_Template

	partial void EnterRule_synpred4_Template_fragment();
	partial void LeaveRule_synpred4_Template_fragment();

	// $ANTLR start synpred4_Template
	private void synpred4_Template_fragment()
	{
		EnterRule_synpred4_Template_fragment();
		EnterRule("synpred4_Template_fragment", 25);
		TraceIn("synpred4_Template_fragment", 25);
		try
		{
			// Language\\Template.g3:224:7: ( '$if' ( ' ' | '(' ) )
			DebugEnterAlt(1);
			// Language\\Template.g3:224:8: '$if' ( ' ' | '(' )
			{
			DebugLocation(224, 8);
			Match("$if"); if (state.failed) return;

			DebugLocation(224, 14);
			if (input.LA(1)==' '||input.LA(1)=='(')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred4_Template_fragment", 25);
			LeaveRule("synpred4_Template_fragment", 25);
			LeaveRule_synpred4_Template_fragment();
		}
	}
	// $ANTLR end synpred4_Template

	partial void EnterRule_synpred5_Template_fragment();
	partial void LeaveRule_synpred5_Template_fragment();

	// $ANTLR start synpred5_Template
	private void synpred5_Template_fragment()
	{
		EnterRule_synpred5_Template_fragment();
		EnterRule("synpred5_Template_fragment", 26);
		TraceIn("synpred5_Template_fragment", 26);
		try
		{
			// Language\\Template.g3:231:6: ( '$elseif' ( ' ' | '(' ) )
			DebugEnterAlt(1);
			// Language\\Template.g3:231:7: '$elseif' ( ' ' | '(' )
			{
			DebugLocation(231, 7);
			Match("$elseif"); if (state.failed) return;

			DebugLocation(231, 17);
			if (input.LA(1)==' '||input.LA(1)=='(')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred5_Template_fragment", 26);
			LeaveRule("synpred5_Template_fragment", 26);
			LeaveRule_synpred5_Template_fragment();
		}
	}
	// $ANTLR end synpred5_Template

	partial void EnterRule_synpred6_Template_fragment();
	partial void LeaveRule_synpred6_Template_fragment();

	// $ANTLR start synpred6_Template
	private void synpred6_Template_fragment()
	{
		EnterRule_synpred6_Template_fragment();
		EnterRule("synpred6_Template_fragment", 27);
		TraceIn("synpred6_Template_fragment", 27);
		try
		{
			// Language\\Template.g3:238:6: ( '$else$' )
			DebugEnterAlt(1);
			// Language\\Template.g3:238:7: '$else$'
			{
			DebugLocation(238, 7);
			Match("$else$"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred6_Template_fragment", 27);
			LeaveRule("synpred6_Template_fragment", 27);
			LeaveRule_synpred6_Template_fragment();
		}
	}
	// $ANTLR end synpred6_Template

	partial void EnterRule_synpred7_Template_fragment();
	partial void LeaveRule_synpred7_Template_fragment();

	// $ANTLR start synpred7_Template
	private void synpred7_Template_fragment()
	{
		EnterRule_synpred7_Template_fragment();
		EnterRule("synpred7_Template_fragment", 28);
		TraceIn("synpred7_Template_fragment", 28);
		try
		{
			// Language\\Template.g3:245:6: ( '$endif$' )
			DebugEnterAlt(1);
			// Language\\Template.g3:245:7: '$endif$'
			{
			DebugLocation(245, 7);
			Match("$endif$"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred7_Template_fragment", 28);
			LeaveRule("synpred7_Template_fragment", 28);
			LeaveRule_synpred7_Template_fragment();
		}
	}
	// $ANTLR end synpred7_Template

	partial void EnterRule_synpred8_Template_fragment();
	partial void LeaveRule_synpred8_Template_fragment();

	// $ANTLR start synpred8_Template
	private void synpred8_Template_fragment()
	{
		EnterRule_synpred8_Template_fragment();
		EnterRule("synpred8_Template_fragment", 29);
		TraceIn("synpred8_Template_fragment", 29);
		try
		{
			// Language\\Template.g3:255:5: ( '$@' )
			DebugEnterAlt(1);
			// Language\\Template.g3:255:6: '$@'
			{
			DebugLocation(255, 6);
			Match("$@"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred8_Template_fragment", 29);
			LeaveRule("synpred8_Template_fragment", 29);
			LeaveRule_synpred8_Template_fragment();
		}
	}
	// $ANTLR end synpred8_Template

	partial void EnterRule_synpred9_Template_fragment();
	partial void LeaveRule_synpred9_Template_fragment();

	// $ANTLR start synpred9_Template
	private void synpred9_Template_fragment()
	{
		EnterRule_synpred9_Template_fragment();
		EnterRule("synpred9_Template_fragment", 30);
		TraceIn("synpred9_Template_fragment", 30);
		try
		{
			// Language\\Template.g3:270:8: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\Template.g3:
			{
			DebugLocation(270, 8);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred9_Template_fragment", 30);
			LeaveRule("synpred9_Template_fragment", 30);
			LeaveRule_synpred9_Template_fragment();
		}
	}
	// $ANTLR end synpred9_Template

	partial void EnterRule_synpred10_Template_fragment();
	partial void LeaveRule_synpred10_Template_fragment();

	// $ANTLR start synpred10_Template
	private void synpred10_Template_fragment()
	{
		EnterRule_synpred10_Template_fragment();
		EnterRule("synpred10_Template_fragment", 31);
		TraceIn("synpred10_Template_fragment", 31);
		try
		{
			// Language\\Template.g3:273:9: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\Template.g3:
			{
			DebugLocation(273, 9);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred10_Template_fragment", 31);
			LeaveRule("synpred10_Template_fragment", 31);
			LeaveRule_synpred10_Template_fragment();
		}
	}
	// $ANTLR end synpred10_Template

	partial void EnterRule_synpred11_Template_fragment();
	partial void LeaveRule_synpred11_Template_fragment();

	// $ANTLR start synpred11_Template
	private void synpred11_Template_fragment()
	{
		EnterRule_synpred11_Template_fragment();
		EnterRule("synpred11_Template_fragment", 32);
		TraceIn("synpred11_Template_fragment", 32);
		try
		{
			// Language\\Template.g3:277:8: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\Template.g3:
			{
			DebugLocation(277, 8);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred11_Template_fragment", 32);
			LeaveRule("synpred11_Template_fragment", 32);
			LeaveRule_synpred11_Template_fragment();
		}
	}
	// $ANTLR end synpred11_Template

	partial void EnterRule_synpred12_Template_fragment();
	partial void LeaveRule_synpred12_Template_fragment();

	// $ANTLR start synpred12_Template
	private void synpred12_Template_fragment()
	{
		EnterRule_synpred12_Template_fragment();
		EnterRule("synpred12_Template_fragment", 33);
		TraceIn("synpred12_Template_fragment", 33);
		try
		{
			// Language\\Template.g3:278:8: ( '$@end$' )
			DebugEnterAlt(1);
			// Language\\Template.g3:278:9: '$@end$'
			{
			DebugLocation(278, 9);
			Match("$@end$"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred12_Template_fragment", 33);
			LeaveRule("synpred12_Template_fragment", 33);
			LeaveRule_synpred12_Template_fragment();
		}
	}
	// $ANTLR end synpred12_Template

	partial void EnterRule_synpred13_Template_fragment();
	partial void LeaveRule_synpred13_Template_fragment();

	// $ANTLR start synpred13_Template
	private void synpred13_Template_fragment()
	{
		EnterRule_synpred13_Template_fragment();
		EnterRule("synpred13_Template_fragment", 34);
		TraceIn("synpred13_Template_fragment", 34);
		try
		{
			// Language\\Template.g3:305:6: ( EOF )
			DebugEnterAlt(1);
			// Language\\Template.g3:305:7: EOF
			{
			DebugLocation(305, 7);
			Match(EOF); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_Template_fragment", 34);
			LeaveRule("synpred13_Template_fragment", 34);
			LeaveRule_synpred13_Template_fragment();
		}
	}
	// $ANTLR end synpred13_Template

	partial void EnterRule_synpred14_Template_fragment();
	partial void LeaveRule_synpred14_Template_fragment();

	// $ANTLR start synpred14_Template
	private void synpred14_Template_fragment()
	{
		EnterRule_synpred14_Template_fragment();
		EnterRule("synpred14_Template_fragment", 35);
		TraceIn("synpred14_Template_fragment", 35);
		try
		{
			// Language\\Template.g3:379:6: ( '\\r' | '\\n' )
			DebugEnterAlt(1);
			// Language\\Template.g3:
			{
			DebugLocation(379, 6);
			if (input.LA(1)=='\n'||input.LA(1)=='\r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred14_Template_fragment", 35);
			LeaveRule("synpred14_Template_fragment", 35);
			LeaveRule_synpred14_Template_fragment();
		}
	}
	// $ANTLR end synpred14_Template

	partial void EnterRule_synpred15_Template_fragment();
	partial void LeaveRule_synpred15_Template_fragment();

	// $ANTLR start synpred15_Template
	private void synpred15_Template_fragment()
	{
		EnterRule_synpred15_Template_fragment();
		EnterRule("synpred15_Template_fragment", 36);
		TraceIn("synpred15_Template_fragment", 36);
		try
		{
			// Language\\Template.g3:381:5: ( ( '\\r' )? '\\n>>' )
			DebugEnterAlt(1);
			// Language\\Template.g3:381:6: ( '\\r' )? '\\n>>'
			{
			DebugLocation(381, 6);
			// Language\\Template.g3:381:6: ( '\\r' )?
			int alt51=2;
			try { DebugEnterSubRule(51);
			try { DebugEnterDecision(51, false);
			int LA51_1 = input.LA(1);

			if ((LA51_1=='\r'))
			{
				alt51 = 1;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// Language\\Template.g3:381:6: '\\r'
				{
				DebugLocation(381, 6);
				Match('\r'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(51); }

			DebugLocation(381, 12);
			Match("\n>>"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("synpred15_Template_fragment", 36);
			LeaveRule("synpred15_Template_fragment", 36);
			LeaveRule_synpred15_Template_fragment();
		}
	}
	// $ANTLR end synpred15_Template

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}

} // namespace Antlr3.ST.Language
